<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/usr/share/haxe/std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<impl><class path="_Any.Any_Impl_" params="" file="/usr/share/haxe/std/Any.hx" private="1" module="Any"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Array" params="T" file="/usr/share/haxe/std/lua/_std/Array.hx">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method" line="30">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method" line="37">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method" line="45">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method" line="54">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method" line="59">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method" line="70">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method" line="84">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method" line="102">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method" line="124">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method" line="142">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method" line="150">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" get="inline" set="null" line="157">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method" line="173">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<indexOf public="1" set="method" line="192">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="208">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" get="inline" set="null" line="226">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<map public="1" params="S" get="inline" set="null" line="230">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="234">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<iterator public="1" get="inline" set="null" line="238">
			<f a=""><t path="Iterator"><c path="Array.T"/></t></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<resize public="1" set="method" line="246">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method" line="26">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/usr/share/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="lua.lib.lrexlib.Rex" params="" file="/usr/share/haxe/std/lua/lib/lrexlib/Rex.hx" extern="1">
		<create public="1" get="inline" set="null" line="29" static="1">
			<f a="expr:flag">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<x path="Int"/>
					<c path="String"/>
				</x>
				<c path="lua.lib.lrexlib.Rex"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<match public="1" set="method" static="1">
			<f a="patt:subj:?init:?ef">
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>The function searches for the first match of the regexp `patt` in the
		string `subj`, starting from offset `init`, subject to flags `cf` and `ef`.

		@return matched string, or array of strings.</haxe_doc>
		</match>
		<find public="1" set="method" static="1">
			<f a="patt:subj:?init:?ef">
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>The function searches for the first match of the regexp patt in the string
		`subj`, starting from offset `init`, subject to flags `cf` and `ef`.</haxe_doc>
		</find>
		<split public="1" set="method" static="1">
			<f a="subj:sep:?cf:?ef">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<x path="Int"/>
				<x path="Int"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>The function is intended for use in the generic for Lua construct. It is
		used for splitting a subject string `subj` into parts (sections). The `sep`
		parameter is a regular expression pattern representing separators between
		the sections.</haxe_doc>
		</split>
		<count public="1" set="method" static="1">
			<f a="subj:patt:cf:ef">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>This function counts matches of the pattern `patt` in the string `subj`.</haxe_doc>
		</count>
		<flags public="1" set="method" static="1"><f a="?tb">
	<d/>
	<d/>
</f></flags>
		<gmatch public="1" set="method" static="1">
			<f a="subj:patt:?cf:?ef">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<x path="Int"/>
				<x path="Int"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>The function is intended for use in the generic for Lua construct. It
		returns an iterator for repeated matching of the pattern patt in the
		string `subj`, subject to flags `cf` and `ef`.</haxe_doc>
		</gmatch>
		<gsub public="1" set="method" static="1">
			<f a="subj:patt:repl:?n:?cf:?ef">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>This function searches for all matches of the pattern `patt` in the string
		`subj` and replaces them according to the parameters `repl` and `n`.</haxe_doc>
		</gsub>
		<tfind public="1" set="method">
			<f a="subj:?init:?ef">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>The function searches for the first match of the regexp in the string
		`subj`, starting from offset `init`, subject to execution flags `ef`.</haxe_doc>
		</tfind>
		<exec public="1" set="method">
			<f a="subj:?init:?ef">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>This function searches for the first match of the regexp in the string
		`subj`, starting from offset `init`, subject to execution flags `ef`.</haxe_doc>
		</exec>
		<meta><m n=":luaRequire"><e>"rex_pcre"</e></m></meta>
	</class>
	<class path="lua.lib.luautf8.Utf8" params="" file="/usr/share/haxe/std/lua/lib/luautf8/Utf8.hx" extern="1">
		<len public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Receives a string and returns its length. The empty string `""` has
		length `0`. Embedded zeros are counted, so `"a\000bc\000"` has length `5`.</haxe_doc>
		</len>
		<char public="1" set="method" static="1">
			<f a="codes">
				<x path="haxe.extern.Rest"><x path="Int"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Receives zero or more integers. Returns a string with length equal to the
		number of arguments, in which each character has the internal numerical
		code equal to its corresponding argument.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</char>
		<sub public="1" set="method" static="1">
			<f a="str:start:?end">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.lib.luautf8.StringSub"/>
			</f>
			<haxe_doc>Returns the substring of `str` that starts at `start` and continues until `end`;
		`start` and `end` can be negative. If `end` is absent, then it is assumed to be
		equal to `-1` (which is the same as the string length).
		In particular, the call `sub(str,1,end)` returns a prefix of `str`
		with length `end`, and `sub(str, -end)` returns a suffix of `str` with
		length `start`.</haxe_doc>
		</sub>
		<charCodeAt public="1" set="method" static="1">
			<f a="str:index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the character code at position `index` of `str`.</haxe_doc>
		</charCodeAt>
		<find public="1" set="method" static="1">
			<f a="str:target:?start:?plain">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="lua.lib.luautf8.StringFind"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string `str`.
		If it finds a match, then `find` returns the indices of `str` where this
		occurrence starts and ends.

		@param target If the target has captures, then in a successful match the
			   captured values are also returned, after the two indices.
		@param start specifies where to start the search; its default value is `1`
			   and can be negative.
		@param plain turns off the pattern matching facilities, so the function does
			   a plain "find substring" operation, with no characters in pattern
			   being considered "magic". Note that if plain is given, then `start` must be given as well.</haxe_doc>
		</find>
		<byte public="1" set="method" static="1">
			<f a="str:?index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the internal numerical codes of the characters `str[index]`.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</byte>
		<gsub public="1" set="method" static="1">
			<f a="str:pattern:replace:?n">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
			<overloads>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<c path="String"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
			</overloads>
		</gsub>
		<gmatch public="1" set="method" static="1">
			<f a="str:pattern">
				<c path="String"/>
				<c path="String"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
			<overloads><gmatch public="1" set="method">
	<f a="str:pattern:match:?n">
		<c path="String"/>
		<c path="String"/>
		<f a=""><c path="String"/></f>
		<x path="Int"/>
		<f a="">
			<c path="String"/>
			<x path="Void"/>
		</f>
	</f>
	<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
</gmatch></overloads>
		</gmatch>
		<match public="1" set="method" static="1">
			<f a="str:pattern:?n">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string s. If it finds one,
		then match returns the captures from the pattern; otherwise it returns `null`.
		If pattern specifies no captures, then the whole match is returned.
		The optional argument `n` specifies where to start the search;
		its default value is `1` and can be negative.</haxe_doc>
		</match>
		<upper public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all lowercase
		letters changed to uppercase. All other characters are left unchanged.
		The definition of what a lowercase letter is depends on the current locale.</haxe_doc>
		</upper>
		<lower public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all uppercase
		letters changed to lowercase. All other characters are left unchanged.
		The definition of what an uppercase letter is depends on the current locale.</haxe_doc>
		</lower>
		<codes public="1" set="method" static="1"><f a="str">
	<c path="String"/>
	<f a=""><c path="lua.lib.luautf8.StringCodePoint"/></f>
</f></codes>
		<haxe_doc>These are all externs for the lua-utf8 library, which functions
	as an additional set of string tools.

	Note that all relevant indexes are "1" based.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":luaRequire"><e>"lua-utf8"</e></m>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/share/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/share/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/usr/share/haxe/std/EnumValue.hx" private="1" module="EnumValue"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Main" params="" file="src/Main.hx"><main public="1" set="method" line="11" static="1">
	<f a=""><x path="Void"/></f>
	<meta><m n=":keep"/></meta>
</main></class>
	<typedef path="Map" params="K:V" file="/usr/share/haxe/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/usr/share/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/usr/share/haxe/std/lua/_std/Math.hx">
		<isNaN public="1" set="method" line="48" static="1"><f a="f">
	<x path="Float"/>
	<x path="Bool"/>
</f></isNaN>
		<isFinite public="1" set="method" line="51" static="1"><f a="f">
	<x path="Float"/>
	<x path="Bool"/>
</f></isFinite>
		<min public="1" set="method" line="101" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="String" params="" file="/usr/share/haxe/std/lua/_std/String.hx">
		<__oldindex static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></__oldindex>
		<__index set="method" line="43" static="1">
			<f a="s:k">
				<d/>
				<d/>
				<d/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</__index>
		<fromCharCode public="1" get="inline" set="null" line="156" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" get="inline" set="null" line="59">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" get="inline" set="null" line="62">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<indexOf public="1" get="inline" set="null" line="65">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex` (if `startIndex` is posivite
		or 0) or `max(this.length + startIndex, 0)` (if `startIndex` is negative).

		If `startIndex` exceeds `this.length`, -1 is returned.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" get="inline" set="null" line="77">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" get="inline" set="null" line="91">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<toString public="1" get="inline" set="null" line="117">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" get="inline" set="null" line="121">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<charAt public="1" get="inline" set="null" line="136">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" get="inline" set="null" line="140">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" get="inline" set="null" line="144">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" get="inline" set="null" line="39">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/share/haxe/std/lua/_std/Std.hx">
		<string public="1" set="method" line="42" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="46" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<typedef path="_String.BaseString" params="" file="/usr/share/haxe/std/lua/_std/String.hx" private="1" module="String"><c path="lua.lib.luautf8.Utf8"/></typedef>
	<class path="gmod.gclass.Angle" params="" file="src/gmod/gclass/Angle.hx" extern="1">
		<pitch public="1"><x path="Float"/></pitch>
		<yaw public="1"><x path="Float"/></yaw>
		<roll public="1"><x path="Float"/></roll>
		<Add public="1" set="method">
			<f a="angle">
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the values of the argument angle to the orignal angle. This functions the same as angle1 + angle2 without creating a new angle object, skipping object construction and garbage collection. 
		
		
		Name | Description
		--- | ---
		`angle` | The angle to add.</haxe_doc>
		</Add>
		<Normalize public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Normalizes the angles by applying a module with 360 to pitch, yaw and roll. 
		
		
		___
		### Lua Examples
		#### Example 1
		Example usage of the function
		
		```lua 
		local a = Angle( 0, 181, 1 )
		a:Normalize()
		print( a )
		```
		**Output:**
		
		0.000 -179.000 1.000</haxe_doc>
		</Normalize>
		<SetUnpacked public="1" set="method">
			<f a="p:y:r">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the p, y, and r of the angle. 
		
		
		Name | Description
		--- | ---
		`p` | 
		`y` | 
		`r` |</haxe_doc>
		</SetUnpacked>
		<Set public="1" set="method">
			<f a="originalAngle">
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies pitch, yaw and roll from the second angle to the first. 
		
		
		Name | Description
		--- | ---
		`originalAngle` | The angle to copy the values from.</haxe_doc>
		</Set>
		<IsZero public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the pitch, yaw and roll are 0 or not. 
		
		
		**Returns:** Whether the pitch, yaw and roll are 0 or not.</haxe_doc>
		</IsZero>
		<Up public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns a normal vector facing in the direction that points up relative to the angle's direction. 
		
		
		**Returns:** The up direction of the angle.</haxe_doc>
		</Up>
		<Sub public="1" set="method">
			<f a="angle">
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Subtracts the values of the argument angle to the orignal angle. This functions the same as angle1 - angle2 without creating a new angle object, skipping object construction and garbage collection. 
		
		
		Name | Description
		--- | ---
		`angle` | The angle to subtract.</haxe_doc>
		</Sub>
		<Right public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns a normal vector facing in the direction that points right relative to the angle's direction. 
		
		
		**Returns:** The right direction of the angle</haxe_doc>
		</Right>
		<Div public="1" set="method">
			<f a="scalar">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Divides all values of the original angle by a scalar. This functions the same as angle1 / num without creating a new angle object, skipping object construction and garbage collection. 
		
		
		Name | Description
		--- | ---
		`scalar` | The number to divide by.</haxe_doc>
		</Div>
		<RotateAroundAxis public="1" set="method">
			<f a="axis:rotation">
				<c path="gmod.gclass.Vector"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Rotates the angle around the specified axis by the specified degrees. 
		
		
		Name | Description
		--- | ---
		`axis` | The axis to rotate around.
		`rotation` | The degrees to rotate around the specified axis.</haxe_doc>
		</RotateAroundAxis>
		<Forward public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns a normal vector facing in the direction that the angle points. 
		
		
		**Returns:** The forward direction of the angle</haxe_doc>
		</Forward>
		<Zero public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Sets pitch, yaw and roll to 0. This function is faster than doing it manually.</haxe_doc>
		</Zero>
		<ToTable public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns the angle as a table with three elements. 
		
		
        **Returns:** The table with elements 1 = p, 2 = y, 3 = r.</haxe_doc>
		</ToTable>
		<Unpack public="1" set="method">
			<f a=""><c path="gmod.gclass.AngleUnpackReturn"/></f>
			<haxe_doc>Returns the p, y, and r of the angle. 
		
		
		Name | Description
		--- | ---
		`a` | p, pitch, x, or Angle[1].
		`b` | y, yaw, or Angle[2].
		`c` | r, roll, r, or Angle[3].</haxe_doc>
		</Unpack>
		<SnapTo public="1" set="method">
			<f a="axis:target">
				<c path="String"/>
				<x path="Float"/>
				<c path="gmod.gclass.Angle"/>
			</f>
			<haxe_doc>Snaps the angle to nearest interval of degrees. 
		
		
		Name | Description
		--- | ---
		`axis` | The component/axis to snap. Can be either "p"/"pitch", "y"/"yaw" or "r"/"roll".
		`target` | The target angle snap interval
		
		
		**Returns:** The snapped angle.
		
		___
		### Lua Examples
		#### Example 1
		Example usage
		
		```lua 
		print( Angle( 0, 92, 0 ):SnapTo( "y", 90 ) )
		print( Angle( 0, 115, 0 ):SnapTo( "y", 45 ) )
		print( Angle( 12, 98, 167 ):SnapTo( "p", 30 ):SnapTo( "y", 45 ):SnapTo( "r", 45 ) )
		```
		**Output:**
		
		Angle( 0, 90, 0 )
		Angle( 0, 135, 0 )
		Angle( 0, 90, -180 )</haxe_doc>
		</SnapTo>
		<Mul public="1" set="method">
			<f a="scalar">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Multiplies a scalar to all the values of the orignal angle. This functions the same as num * angle without creating a new angle object, skipping object construction and garbage collection. 
		
		
		Name | Description
		--- | ---
		`scalar` | The number to multiply.</haxe_doc>
		</Mul>
		<haxe_doc><![CDATA[List of all possible functions to manipulate angles. 
	
	Created by Angle & many more functions.]]></haxe_doc>
	</class>
	<class path="gmod.gclass.AngleUnpackReturn" params="" file="src/gmod/gclass/Angle.hx" module="gmod.gclass.Angle" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.CTakeDamageInfo" params="" file="src/gmod/gclass/CTakeDamageInfo.hx" extern="1">
		<GetReportedPosition public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the initial, unmodified position where the damage occured. 
		
		
		**Returns:** position</haxe_doc>
		</GetReportedPosition>
		<SetDamageCustom public="1" set="method">
			<f a="DamageType">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the custom damage type. This is used by Day of Defeat: Source and Team Fortress 2 for extended damage info, but isn't used in Garry's Mod by default. 
		
		
		Name | Description
		--- | ---
		`DamageType` | Any integer - can be based on your own custom enums.</haxe_doc>
		</SetDamageCustom>
		<IsBulletDamage public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the damage was caused by a bullet. 
		
		
		**Returns:** isBulletDmg</haxe_doc>
		</IsBulletDamage>
		<SetInflictor public="1" set="method">
			<f a="inflictor">
				<t path="gmod.types.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the inflictor of the damage for example a weapon. 
		
		For hitscan/bullet weapons this should the weapon. For projectile ( rockets, etc ) weapons this should be the projectile. 
		
		 
		Name | Description
		--- | ---
		`inflictor` | The new inflictor.</haxe_doc>
		</SetInflictor>
		<GetInflictor public="1" set="method">
			<f a=""><t path="gmod.types.Entity"/></f>
			<haxe_doc>Returns the inflictor of the damage. This is not necessarily a weapon. 
		
		For hitscan weapons this is the weapon. For projectile weapons this is the projectile. For a more reliable method of getting the weapon that damaged an entity, use GetAttacker with GetActiveWeapon. 
		
		 
		**Returns:** The inflictor</haxe_doc>
		</GetInflictor>
		<SetAttacker public="1" set="method">
			<f a="ent">
				<t path="gmod.types.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the attacker ( character who originated the attack ) of the damage, for example a player or an NPC. 
		
		
		Name | Description
		--- | ---
		`ent` | The entity to be set as the attacker.</haxe_doc>
		</SetAttacker>
		<GetDamageCustom public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gets the custom damage type. This is used by Day of Defeat: Source and Team Fortress 2 for extended damage info, but isn't used in Garry's Mod by default. 
		
		
		**Returns:** The custom damage type</haxe_doc>
		</GetDamageCustom>
		<GetAttacker public="1" set="method">
			<f a=""><t path="gmod.types.Entity"/></f>
			<haxe_doc>Returns the attacker ( character who originated the attack ), for example a player or an NPC that shot the weapon. 
		
		
		**Returns:** The attacker</haxe_doc>
		</GetAttacker>
		<GetBaseDamage public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the initial unmodified by skill level ( game.GetSkillLevel ) damage. 
		
		
		**Returns:** baseDamage</haxe_doc>
		</GetBaseDamage>
		<SetDamageBonus public="1" set="method">
			<f a="damage">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the bonus damage. Bonus damage isn't automatically applied, so this will have no outer effect by default. 
		
		
		Name | Description
		--- | ---
		`damage` | The extra damage to be added.</haxe_doc>
		</SetDamageBonus>
		<SetDamageType public="1" set="method">
			<f a="type">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the damage type. 
		
		
		Name | Description
		--- | ---
		`type` | The damage type, see DMG_ Enums.</haxe_doc>
		</SetDamageType>
		<IsDamageType public="1" set="method">
			<f a="dmgType">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whenever the damageinfo contains the damage type specified. 
		
		
		Name | Description
		--- | ---
		`dmgType` | Damage type to test. See DMG_ Enums.
		
		
		**Returns:** Whether this damage contains specified damage type or not</haxe_doc>
		</IsDamageType>
		<SetDamagePosition public="1" set="method">
			<f a="pos">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the position of where the damage gets applied to. 
		
		
		Name | Description
		--- | ---
		`pos` | The position where the damage will be applied.</haxe_doc>
		</SetDamagePosition>
		<SetAmmoType public="1" set="method">
			<f a="ammoType">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the ammo type used by the weapon that inflicted the damage. 
		
		
		Name | Description
		--- | ---
		`ammoType` | Ammo type ID
		
		
		___
		### Lua Examples
		#### Example 1
		Creates a new DamageInfo object and sets the ammo that caused the damage to AR2 ammo
		
		```lua 
		local dmginfo = DamageInfo()
		
		dmginfo:SetAmmoType( game.GetAmmoID( 'AR2' ) )
		```</haxe_doc>
		</SetAmmoType>
		<GetDamagePosition public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the position where the damage was or is going to be applied to. 
		
		Can be set using CTakeDamageInfo:SetDamagePosition. 
		
		 
		**Returns:** The damage position</haxe_doc>
		</GetDamagePosition>
		<GetAmmoType public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the ammo type used by the weapon that inflicted the damage. 
		
		
		**Returns:** Ammo type ID</haxe_doc>
		</GetAmmoType>
		<SetDamageForce public="1" set="method">
			<f a="force">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the directional force of the damage. 
		
		
		Name | Description
		--- | ---
		`force` | The vector to set the force to.</haxe_doc>
		</SetDamageForce>
		<IsExplosionDamage public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whenever the damageinfo contains explosion damage. 
		
		
		**Returns:** isExplDamage</haxe_doc>
		</IsExplosionDamage>
		<ScaleDamage public="1" set="method">
			<f a="scale">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scales the damage by the given value. 
		
		
		Name | Description
		--- | ---
		`scale` | Value to scale the damage with.</haxe_doc>
		</ScaleDamage>
		<GetDamageType public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a bitflag which indicates the damage type(s) of the damage. 
		
		Consider using CTakeDamageInfo:IsDamageType instead. Value returned by this function can contain multiple damage types. 
		
		 
		**Returns:** Damage type(s), a combination of DMG_ Enums</haxe_doc>
		</GetDamageType>
		<AddDamage public="1" set="method">
			<f a="damageIncrease">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Increases the damage by damageIncrease. 
		
		
		Name | Description
		--- | ---
		`damageIncrease` | The damage to add.</haxe_doc>
		</AddDamage>
		<GetDamageBonus public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gets the current bonus damage. 
		
		
		**Returns:** Bonus damage</haxe_doc>
		</GetDamageBonus>
		<GetMaxDamage public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the maximum damage. 
		
		
		**Returns:** maxDmg</haxe_doc>
		</GetMaxDamage>
		<GetDamageForce public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns a vector representing the damage force. 
		
		Can be set with CTakeDamageInfo:SetDamageForce. 
		
		 
		**Returns:** The damage force</haxe_doc>
		</GetDamageForce>
		<SetMaxDamage public="1" set="method">
			<f a="maxDamage">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the maximum damage the object can cause. 
		
		
		Name | Description
		--- | ---
		`maxDamage` | Maximum damage value.</haxe_doc>
		</SetMaxDamage>
		<SubtractDamage public="1" set="method">
			<f a="damage">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Subtracts the specified amount from the damage. 
		
		
		Name | Description
		--- | ---
		`damage` | Value to subtract.</haxe_doc>
		</SubtractDamage>
		<SetDamage public="1" set="method">
			<f a="damage">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the amount of damage. 
		
		
		Name | Description
		--- | ---
		`damage` | The value to set the absolute damage to.</haxe_doc>
		</SetDamage>
		<SetReportedPosition public="1" set="method">
			<f a="pos">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the origin of the damage. 
		
		
		Name | Description
		--- | ---
		`pos` | The location of where the damage is originating</haxe_doc>
		</SetReportedPosition>
		<GetDamage public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the total damage. 
		
		
		**Returns:** damage</haxe_doc>
		</GetDamage>
		<IsFallDamage public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whenever the damageinfo contains fall damage. 
		
		
		**Returns:** isFallDmg</haxe_doc>
		</IsFallDamage>
		<haxe_doc>A class used to store and modify all the data concerning a damage event. An empty CTakeDamageInfo object can be created with DamageInfo 
	
	List of hooks that this object is passed to:</haxe_doc>
	</class>
	<class path="gmod.gclass.Entity" params="" file="src/gmod/gclass/Entity.hx" extern="1">
		<SetNetworkedInt public="1" set="method">
			<f a="key:?value">
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: SetNWInt instead.
		
		Sets a networked integer value at specified index on the entity. 
		
		The value then can be accessed with Entity:GetNetworkedInt both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set</haxe_doc>
		</SetNetworkedInt>
		<WaterLevel public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns an integer that represents how deep in water the entity is. 
		
		
		**Returns:** The water level.</haxe_doc>
		</WaterLevel>
		<GetDTEntity public="1" set="method">
			<f a="key">
				<x path="Float"/>
				<c path="gmod.gclass.Entity"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Returns an entity stored in the datatable of the entity. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 63. Specifies what key to grab from datatable.
		
		
		**Returns:** Requested entity.</haxe_doc>
		</GetDTEntity>
		<GetPoseParameterName public="1" set="method">
			<f a="id">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns name of given pose parameter 
		
		
		Name | Description
		--- | ---
		`id` | Id of the pose paremeter
		
		
		**Returns:** Name of given pose parameter</haxe_doc>
		</GetPoseParameterName>
		<GetOwner public="1" set="method">
			<f a=""><c path="gmod.gclass.Entity"/></f>
			<haxe_doc>Returns the owner entity of this entity. See Entity:SetOwner for more info. 
		
		
		**Returns:** The owner entity of this entity.</haxe_doc>
		</GetOwner>
		<GetTouchTrace public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns the last trace used in the collision callbacks such as ENTITY:StartTouch, ENTITY:Touch and ENTITY:EndTouch. 
		
		
		**Returns:** The TraceResult structure
		
		___
		### Lua Examples
		#### Example 1
		Dispatches an explosion at the point of impact with another entity.
		
		```lua 
		function ENT:Touch( otherEntity )
		    local tr = self:GetTouchTrace()
		    local hitPos = tr.HitPos
		
		    local effectdata = EffectData()
		    effectdata:SetOrigin( hitPos )
		    util.Effect( "Explosion", effectdata )
		
		end
		```</haxe_doc>
		</GetTouchTrace>
		<Remove public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes the entity it is used on. 
		
		
		___
		### Lua Examples
		#### Example 1
		
		
		```lua 
		ents.FindByClass( "prop_physics" )[1]:Remove()
		```
		**Output:**
		
		Removes whichever prop is first found or errors if no entity was found.</haxe_doc>
		</Remove>
		<GetBoneName public="1" set="method">
			<f a="index">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns name of given bone id. 
		
		
		Name | Description
		--- | ---
		`index` | ID of bone to lookup name of
		
		
		**Returns:** The name of given bone nil in case we failed or entity doesn't have a model "__INVALIDBONE__" in case the name cannot be read or the index is out of range.
		
		___
		### Lua Examples
		#### Example 1
		Will print name of bone name with id 0 for first player.
		
		```lua 
		print( Entity( 1 ):GetBoneName( 0 ) )
		```
		**Output:**
		
		ValveBiped.Bip01_Pelvis
		
		#### Example 2
		Prints all the bones of an entity.
		
		```lua 
		function PrintBones(ent)
		    for i=0, ent:GetBoneCount()-1 do
		        print(i,ent:GetBoneName(i))
		    end
		end
		```</haxe_doc>
		</GetBoneName>
		<GetBaseVelocity public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the entity's base velocity which is their velocity due to forces applied by other entities. This includes entity-on-entity collision or riding a treadmill. 
		
		
		**Returns:** The base velocity of the entity.</haxe_doc>
		</GetBaseVelocity>
		<GetRenderFX public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns current render FX of the entity. 
		
		
		**Returns:** The current render FX of the entity. See kRenderFx_ Enums</haxe_doc>
		</GetRenderFX>
		<GetDTBool public="1" set="method">
			<f a="key">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Get a boolean stored in the datatable of the entity. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 63. Specifies what key to grab from datatable.
		
		
		**Returns:** Requested boolean.</haxe_doc>
		</GetDTBool>
		<SetPersistent public="1" set="method">
			<f a="persist">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets whether or not the given entity is persistent. A persistent entity will be saved on server shutdown and loaded back when the server starts up. Additionally, by default persistent entities cannot be grabbed with the physgun and tools cannot be used on them. 
		
		In sandbox, this can be set on an entity by opening the context menu, right clicking the entity, and choosing "Make Persistent". 
		
		 
		Name | Description
		--- | ---
		`persist` | Whether or not the entity should be persistent.</haxe_doc>
		</SetPersistent>
		<IsOnGround public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the entity is on ground or not. 
		
		Internally, this checks if FL_ONGROUND is set on the entity. 
		
		 This function is an alias of Entity:OnGround. 
		
		 
		**Returns:** Whether the entity is on ground or not.
		
		___
		### Lua Examples
		#### Example 1
		Demonstrates the use of this function.
		
		```lua 
		print( Entity( 1 ):IsOnGround() )
		print( IsValid( Entity( 1 ):GetGroundEntity() ) ) -- This should give the exact output as the first line
		```
		**Output:**
		
		Outputs 'true' to the console if the player 1 is on ground.</haxe_doc>
		</IsOnGround>
		<GetBoneSurfaceProp public="1" set="method">
			<f a="bone">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the surface property of the specified bone. 
		
		
		Name | Description
		--- | ---
		`bone` | The bone id. See Entity: LookupBone.
		
		
		**Returns:** The surface property of the bone to be used with util. GetSurfaceIndex or an empty string on failure.</haxe_doc>
		</GetBoneSurfaceProp>
		<GetMaxHealth public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the max health that the entity was given. It can be set via Entity:SetMaxHealth. 
		
		
		**Returns:** Max health.
		
		___
		### Lua Examples
		#### Example 1
		Prints the maximum health set for player 1.
		
		```lua 
		print( Entity( 1 ):GetMaxHealth() )
		```
		**Output:**
		
		By default, 100.</haxe_doc>
		</GetMaxHealth>
		<GetVelocity public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the entity's velocity. 
		
		
		**Returns:** The velocity of the entity.</haxe_doc>
		</GetVelocity>
		<SetEyeTarget public="1" set="method">
			<f a="pos">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sets the position an entity's eyes look toward. 
		
		
		Name | Description
		--- | ---
		`pos` | The world position the entity is looking toward.
		
		
		___
		### Lua Examples
		#### Example 1
		Makes an NPC (self) look into a nearby player's eyes.
		
		```lua 
		for p, ply in pairs(player.GetAll()) do
		    if(ply:EyePos():Distance(self:EyePos()) <= 60) then
		        self:SetEyeTarget(ply:EyePos())
		        break
		    end
		end
		```
		
		#### Example 2
		Makes an entity look at a vector the way the eyeposer does it
		
		```lua 
		local lookat = Vector( 0, 0, 0 )
		
		local attachment = ent:GetAttachment( ent:LookupAttachment( "eyes" ) )
		local LocalPos, LocalAng = WorldToLocal( lookat, Angle( 0, 0, 0 ), attachment.Pos, attachment.Ang )
		ent:SetEyeTarget( LocalPos )
		```]]></haxe_doc>
		</SetEyeTarget>
		<GetModelScale public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gets the selected entity's model scale. 
		
		
		**Returns:** Scale of that entity's model.
		
		___
		### Lua Examples
		#### Example 1
		This example shows how one can get the model scale of their self.
		
		```lua 
		lua_run_cl print(LocalPlayer():GetModelScale())
		```
		**Output:**
		
		1</haxe_doc>
		</GetModelScale>
		<GetBoneMatrix public="1" set="method">
			<f a="boneID">
				<x path="Float"/>
				<c path="gmod.gclass.VMatrix"/>
			</f>
			<haxe_doc>Returns the matrix (position / rotation transform) of a given bone entity. 
		
		
		Name | Description
		--- | ---
		`boneID` | The bone to retrieve matrix of. Bones clientside and serverside will differ
		
		
		**Returns:** The matrix Some entities don't update animation every frame such as prop_physics and won't have accurate bone matrix.</haxe_doc>
		</GetBoneMatrix>
		<IsDormant public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the entity is dormant or not. Client/server entities become dormant when they leave the PVS on the server. Client side entities can decide for themselves whether to become dormant. This mainly applies to PVS. 
		
		
		**Returns:** Whether the entity is dormant or not.</haxe_doc>
		</IsDormant>
		<SetMoveType public="1" set="method">
			<f a="movetype">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the entity's move type. This should be called before initializing the physics object on the entity, unless it will override SetMoveType such as Entity:PhysicsInitBox. 
		
		Despite existing on client, it doesn't actually do anything on client. 
		
		 
		Name | Description
		--- | ---
		`movetype` | The new movetype, see MOVETYPE_ Enums</haxe_doc>
		</SetMoveType>
		<GetNumPoseParameters public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the number of pose parameters this entity has. 
		
		
		**Returns:** Amount of pose parameters the entity has
		
		___
		### Lua Examples
		#### Example 1
		Prints all the entities poses.The entity used to generate the output is a model of the combine helicopter.
		
		```lua 
		for i=0, ent:GetNumPoseParameters() - 1 do
		    local min, max = ent:GetPoseParameterRange( i )
		    print( ent:GetPoseParameterName( i ) .. ' ' .. min .. " / " .. max )
		end
		```
		**Output:**
		
		weapon_pitch -90 / 20 weapon_yaw -40 / 40 rudder -45 / 45</haxe_doc>
		</GetNumPoseParameters>
		<SetVelocity public="1" set="method">
			<f a="velocity">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the entity's velocity. For entities with physics, consider using PhysObj:SetVelocity on the PhysObj of the entity. 
		
		
		Name | Description
		--- | ---
		`velocity` | The new velocity to set.</haxe_doc>
		</SetVelocity>
		<ManipulateBoneAngles public="1" set="method">
			<f a="boneID:ang">
				<x path="Float"/>
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets custom bone angles. 
		
		
		Name | Description
		--- | ---
		`boneID` | Index of the bone you want to manipulate
		`ang` | Angle to apply. The angle is relative to the original bone angle, not relative to the world or the entity.
		
		
		___
		### Lua Examples
		#### Example 1
		This example shows the network usage impact of repeatedly using bone manipulation serverside.To see the difference, type in client's console: net_graph 3The rotation is not smooth when using Entity:SetNWFloat() because it does not update the value on every frame.
		
		```lua 
		local server_only = true -- Change the value!
		
		if server_only then
		    if SERVER then
		        hook.Add( "Think", "bone_manipulation_test", function()
		            for _,ent in ipairs( ents.FindByModel( "models/buggy.mdl" ) ) do
		                ent:ManipulateBoneAngles( 28, Angle( 0,0,RealTime()*180 ) )
		            end
		        end )
		    else
		        hook.Add( "Think", "bone_manipulation_test", function()
		        end )
		    end
		else
		    if SERVER then
		        hook.Add( "Think", "bone_manipulation_test", function()
		            for _,ent in ipairs( ents.FindByModel( "models/buggy.mdl" ) ) do
		                ent:SetNWFloat( "bone_manipulation_test", RealTime()*180 ) -- Entity:SetNW....() do not broadcast new values instantly
		            end
		        end )
		    else
		        hook.Add( "Think", "bone_manipulation_test", function()
		            for _,ent in ipairs( ents.GetAll() ) do
		                if ent:GetModel() == "models/buggy.mdl" then
		                    ent:ManipulateBoneAngles( 28, Angle( 0,0,ent:GetNWFloat( "bone_manipulation_test" ) ) )
		                end
		            end
		        end )
		    end
		end
		```
		**Output:**
		
		Rotation of the ammo box of all HL2 buggies.</haxe_doc>
		</ManipulateBoneAngles>
		<ManipulateBoneJiggle public="1" set="method">
			<f a="boneID:enabled">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Manipulates the bone's jiggle status. This allows non jiggly bones to become jiggly. 
		
		
		Name | Description
		--- | ---
		`boneID` | Index of the bone you want to manipulate.
		`enabled` | 0 = No Jiggle 1 = Jiggle
		
		
		___
		### Lua Examples
		#### Example 1
		Turn everyone into jelly mode
		
		```lua 
		for k, v in pairs(player.GetAll()) do
		    local i = 0
		
		    while i < v:GetBoneCount() do
		        v:ManipulateBoneJiggle(i, 1)
		        i = i + 1
		    end
		end
		```]]></haxe_doc>
		</ManipulateBoneJiggle>
		<SetLocalAngularVelocity public="1" set="method">
			<f a="angVel">
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the entity's angular velocity (rotation speed). 
		
		
		Name | Description
		--- | ---
		`angVel` | The angular velocity to set.</haxe_doc>
		</SetLocalAngularVelocity>
		<GetFlexScale public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the flex scale of the entity. 
		
		
		**Returns:** The flex scale</haxe_doc>
		</GetFlexScale>
		<GetSequenceList public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns a list of all sequences ( animations ) the model has. 
		
		
		**Returns:** The list of all sequences ( animations ) the model has. The indices start with 0!
		
		___
		### Lua Examples
		#### Example 1
		Example showing table structure. Prints a list of player model sequences.
		
		```lua 
		PrintTable( Entity(1):GetSequenceList() )
		```
		**Output:**
		
		0	=	ragdoll
		1	=	reference
		2	=	idle_all_01
		3	=	idle_all_02
		4	=	idle_all_angry
		5	=	idle_all_scared
		6	=	idle_all_cower
		7	=	cidle_all
		8	=	swim_idle_all
		9	=	sit
		10	=	menu_walk
		11	=	menu_combine
		12	=	menu_gman
		13	=	walk_all
		-- The rest of the sequences</haxe_doc>
		</GetSequenceList>
		<GetSequenceCount public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the amount of sequences ( animations ) the entity's model has. 
		
		
		**Returns:** The amount of sequences ( animations ) the entity's model has.</haxe_doc>
		</GetSequenceCount>
		<SetModel public="1" set="method">
			<f a="modelName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the model of the entity. 
		
		
		Name | Description
		--- | ---
		`modelName` | New model value.</haxe_doc>
		</SetModel>
		<GetNetworkedVarTable public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should be using Entity: GetNWVarTable instead.
		
		Returns all the networked variables in an entity. 
		
		
		**Returns:** Key-Value table of all networked variables.
		
		___
		### Lua Examples
		#### Example 1
		Prints all NWVars that exist for Player 1.
		
		```lua 
		PrintTable( Entity(1):GetNWVarTable() )
		```
		**Output:**
		
		UserGroup	=	owner</haxe_doc>
		</GetNetworkedVarTable>
		<SetDTEntity public="1" set="method">
			<f a="key:ent">
				<x path="Float"/>
				<c path="gmod.gclass.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Sets the specified entity on this entity's datatable. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 31.
		`ent` | The entity to write on this entity's datatable.</haxe_doc>
		</SetDTEntity>
		<DTVar public="1" set="method">
			<f a="Type:ID:Name">
				<c path="String"/>
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		Sets up a self.dt.NAME alias for a Data Table variable. 
		
		
		Name | Description
		--- | ---
		`Type` | The type of the DTVar being set up. It can be one of the following: 'Int', 'Float', 'Vector', 'Angle', 'Bool', 'Entity' or 'String'
		`ID` | The ID of the DTVar. Can be between 0 and 3 for strings, 0 and 31 for everything else.
		`Name` | Name by which you will refer to DTVar. It must be a valid variable name. (No spaces!)
		
		
		___
		### Lua Examples
		#### Example 1
		Sets up two float networked variables, TargetZ and Speed
		
		```lua 
		function ENT:SetupDataTables()
		
		    self:DTVar( "Float", 0, "TargetZ" )
		    self:DTVar( "Float", 1, "Speed" )
		
		end
		```</haxe_doc>
		</DTVar>
		<GetAttachments public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns a table containing all attachments of the given entitys model. Returns an empty table or nil in case it's model has no attachments. 
		
		
		**Returns:** Attachment data. See AttachmentData structure.
		
		___
		### Lua Examples
		#### Example 1
		All the attachments present on the Kliener player model
		
		```lua 
		PrintTable(LocalPlayer():GetAttachments())
		```
		**Output:**
		
		1: id = 1 name = eyes 2: id = 2 name = lefteye 3: id = 3 name = righteye 4: id = 4 name = nose 5: id = 5 name = mouth 6: id = 6 name = tie 7: id = 7 name = pen 8: id = 8 name = chest 9: id = 9 name = hips 10: id = 10 name = lefthand 11: id = 11 name = righthand 12: id = 12 name = forward 13: id = 13 name = anim_attachment_RH 14: id = 14 name = anim_attachment_LH 15: id = 15 name = anim_attachment_head</haxe_doc>
		</GetAttachments>
		<GetNetworkOrigin public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Gets networked origin for entity. 
		
		
		**Returns:** origin</haxe_doc>
		</GetNetworkOrigin>
		<IsWorld public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns if the entity is the map's Entity[0] worldspawn 
		
		
		**Returns:** isWorld
		
		___
		### Lua Examples
		#### Example 1
		Stool boilerplate for the ignite tool
		
		```lua 
		function TOOL:LeftClick( trace )
		 local ent = trace.Entity
		 if!ent or!ent:IsValid() or ent:IsPlayer() or ent:IsWorld() then return false end
		 ...
		```
		**Output:**
		
		LeftClick will not run for no ent, invalid ents, players, or worldspawn.</haxe_doc>
		</IsWorld>
		<GetModelBounds public="1" set="method">
			<f a=""><c path="gmod.gclass.EntityGetModelBoundsReturn"/></f>
			<haxe_doc>Returns the entity's model bounds. This is different than the collision bounds/hull. This is not scaled with Entity:SetModelScale, and will return the model's original, unmodified mins and maxs. 
		
		
		Name | Description
		--- | ---
		`a` | The minimum vector of the bounds
		`b` | The maximum vector of the bounds</haxe_doc>
		</GetModelBounds>
		<LookupBone public="1" set="method">
			<f a="boneName">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Gets the bone index of the given bone name, returns nothing if the bone does not exist. 
		
		
		Name | Description
		--- | ---
		`boneName` | The name of the bone. Common generic bones ( for player models and some HL2 models ): ValveBiped.Bip01_Head1 ValveBiped.Bip01_Spine ValveBiped.Anim_Attachment_RH Common hand bones (left hand equivalents also available, replace _R_ with _L_) ValveBiped.Bip01_R_Hand ValveBiped.Bip01_R_Forearm ValveBiped.Bip01_R_Foot ValveBiped.Bip01_R_Thigh ValveBiped.Bip01_R_Calf ValveBiped.Bip01_R_Shoulder ValveBiped.Bip01_R_Elbow
		
		
		**Returns:** Index of the given bone name</haxe_doc>
		</LookupBone>
		<Weapon_SetActivity public="1" set="method">
			<f a="act:duration">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the activity of the entity's active weapon. 
		
		
		Name | Description
		--- | ---
		`act` | Activity number. See ACT_ Enums.
		`duration` | How long the animation should take in seconds.</haxe_doc>
		</Weapon_SetActivity>
		<SetSkin public="1" set="method">
			<f a="skinIndex">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the skin of the entity. 
		
		
		Name | Description
		--- | ---
		`skinIndex` | 0-based index of the skin to use.</haxe_doc>
		</SetSkin>
		<FindBodygroupByName public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Searches for bodygroup with given name. 
		
		
		Name | Description
		--- | ---
		`name` | The bodygroup name to search for.
		
		
		**Returns:** Bodygroup ID, -1 if not found</haxe_doc>
		</FindBodygroupByName>
		<IsEFlagSet public="1" set="method">
			<f a="flag">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks if given flag is set or not. 
		
		
		Name | Description
		--- | ---
		`flag` | The engine flag to test, see EFL_ Enums
		
		
		**Returns:** Is set or not</haxe_doc>
		</IsEFlagSet>
		<GetBoneContents public="1" set="method">
			<f a="bone">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the contents of the specified bone. 
		
		
		Name | Description
		--- | ---
		`bone` | The bone id. See Entity: LookupBone.
		
		
		**Returns:** The contents as a CONTENTS_ Enums or 0 on failure.</haxe_doc>
		</GetBoneContents>
		<GetLocalPos public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns entity's position relative to it's parent. 
		
		
		**Returns:** Relative position</haxe_doc>
		</GetLocalPos>
		<GetAngles public="1" set="method">
			<f a=""><c path="gmod.gclass.Angle"/></f>
			<haxe_doc>Gets the angles of given entity. 
		
		
		**Returns:** The angles of the entity.
		
		___
		### Lua Examples
		#### Example 1
		Prints the 1st player's angles.
		
		```lua 
		print( player.GetByID(1):GetAngles() )
		```
		**Output:**
		
		Something like "0.000 34.529 0.000" in console.</haxe_doc>
		</GetAngles>
		<GetSequenceMovement public="1" set="method">
			<f a="sequenceId:startCycle:endCyclnde">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="gmod.gclass.EntityGetSequenceMovementReturn"/>
			</f>
			<haxe_doc>Returns the delta movement and angles of a sequence of the entity's model. 
		
		
		Name | Description
		--- | ---
		`sequenceId` | The sequence index. See Entity: GetSequenceName.
		`startCycle` | The sequence start cycle. 0 is the start of the animation, 1 is the end.
		`endCyclnde` | The sequence end cycle. 0 is the start of the animation, 1 is the end. Values like 2, etc are allowed.
		
		
		Name | Description
		--- | ---
		`a` | Whether the operation was successful
		`b` | The delta vector of the animation, how much the model's origin point moved.
		`c` | The delta angle of the animation.</haxe_doc>
		</GetSequenceMovement>
		<SetCycle public="1" set="method">
			<f a="value">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the progress of the current animation to a specific value between 0 and 1. 
		
		
		Name | Description
		--- | ---
		`value` | The desired cycle value
		
		
		___
		### Lua Examples
		#### Example 1
		Set the entity to be half way through its current sequence
		
		```lua 
		ent:SetCycle( .5 )
		```</haxe_doc>
		</SetCycle>
		<IsSolid public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns if the entity is solid or not. Very useful for determining if the entity is a trigger or not. 
		
		
		**Returns:** Whether the entity is solid or not.</haxe_doc>
		</IsSolid>
		<GetNetworkedEntity public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<c path="gmod.gclass.Entity"/>
				<c path="gmod.gclass.Entity"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: GetNWEntity instead.
		
		Retrieves a networked float value at specified index on the entity that is set by Entity:SetNetworkedEntity. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. ( If it isn't set )
		
		
		**Returns:** The retrieved value</haxe_doc>
		</GetNetworkedEntity>
		<SetFlexWeight public="1" set="method">
			<f a="flex:weight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the flex weight. 
		
		
		Name | Description
		--- | ---
		`flex` | The ID of the flex to modify weight of
		`weight` | The new weight to set</haxe_doc>
		</SetFlexWeight>
		<SetShouldPlayPickupSound public="1" set="method">
			<f a="?playsound">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets whether or not the entity should make a physics contact sound when it's been picked up by a player. 
		
		
		Name | Description
		--- | ---
		`playsound` | True to play the pickup sound, false otherwise.
		
		
		___
		### Lua Examples
		#### Example 1
		Enable pickup sound on all entities.
		
		```lua 
		function GM:OnEntityCreated(ent)
		    ent:SetShouldPlayPickupSound(true)
		end
		```</haxe_doc>
		</SetShouldPlayPickupSound>
		<ManipulateBoneScale public="1" set="method">
			<f a="boneID:scale">
				<x path="Float"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets custom bone scale. 
		
		
		Name | Description
		--- | ---
		`boneID` | Index of the bone you want to manipulate
		`scale` | Scale vector to apply. Note that the scale is relative to the original bone scale, not relative to the world or the entity. BUG The vector will be normalised if its longer than 32 units. Issue Tracker: #1249</haxe_doc>
		</ManipulateBoneScale>
		<SetSaveValue public="1" set="method">
			<f a="name:value">
				<c path="String"/>
				<x path="Any"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Sets a save value for an entity. 
		
		
		Name | Description
		--- | ---
		`name` | Name of the save value to set
		`value` | Value to set
		
		
		**Returns:** Key successfully set
		
		___
		### Lua Examples
		#### Example 1
		Make all rollermines currently on the map friendly
		
		```lua 
		for k, v in pairs( ents.FindByClass( "npc_rollermine" ) ) do
		    v:SetSaveValue( "m_bHackedByAlyx", true )
		end
		```</haxe_doc>
		</SetSaveValue>
		<GetNWInt public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<haxe_doc>Retrieves a networked integer (whole number) value that was previously set by Entity:SetNWInt. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value (If it isn't set).
		
		
		**Returns:** The value associated with the key</haxe_doc>
		</GetNWInt>
		<SetNWInt public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a networked integer (whole number) value on the entity. 
		
		The value can then be accessed with Entity:GetNWInt both from client and server. 
		
		 See Entity:SetNWFloat for numbers that aren't integers. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set
		
		
		___
		### Lua Examples
		#### Example 1
		This will set the networked integer 'money' on all clients to 100.
		
		```lua 
		for k, v in ipairs( player.GetAll() ) do
		    v:SetNWInt( 'money', 100 )
		end
		```</haxe_doc>
		</SetNWInt>
		<SetCustomCollisionCheck public="1" set="method">
			<f a="enable">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Marks the entity to call GM:ShouldCollide. 
		
		
		Name | Description
		--- | ---
		`enable` | Enable or disable the custom collision check</haxe_doc>
		</SetCustomCollisionCheck>
		<GetNetworkedAngle public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<c path="gmod.gclass.Angle"/>
				<c path="gmod.gclass.Angle"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: GetNWAngle instead.
		
		Retrieves a networked angle value at specified index on the entity that is set by Entity:SetNetworkedAngle. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. ( If it isn't set )
		
		
		**Returns:** The retrieved value</haxe_doc>
		</GetNetworkedAngle>
		<IsWeapon public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Checks if the entity is a weapon or not. 
		
		
		**Returns:** Whether the entity is a weapon</haxe_doc>
		</IsWeapon>
		<GetFlexWeight public="1" set="method">
			<f a="flex">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns current weight ( value ) of the flex. 
		
		
		Name | Description
		--- | ---
		`flex` | The ID of the flex to get weight of
		
		
		**Returns:** The current weight of the flex</haxe_doc>
		</GetFlexWeight>
		<GetWorldTransformMatrix public="1" set="method">
			<f a=""><c path="gmod.gclass.VMatrix"/></f>
			<haxe_doc>Returns the position and angle of the entity as a 3x4 matrix (VMatrix is 4x4 so the fourth row goes unused). The first three columns store the angle as a rotation matrix, and the fourth column stores the position vector. 
		
		
		**Returns:** The position and angle matrix.</haxe_doc>
		</GetWorldTransformMatrix>
		<SetDTInt public="1" set="method">
			<f a="key:integer">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Sets the specified integer on the entity's datatable. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 31.
		`integer` | The integer to write on the entity's datatable. This will be cast to a 32-bit signed integer internally.</haxe_doc>
		</SetDTInt>
		<AddFlags public="1" set="method">
			<f a="flag">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds flags to the entity. 
		
		
		Name | Description
		--- | ---
		`flag` | Flag to add, see FL_ Enums</haxe_doc>
		</AddFlags>
		<TranslateBoneToPhysBone public="1" set="method">
			<f a="boneID">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the ID of a PhysObj attached to the given bone. To be used with Entity:GetPhysicsObjectNum. 
		
		See Entity:TranslatePhysBoneToBone for reverse function. 
		
		 
		Name | Description
		--- | ---
		`boneID` | The ID of a bone to look up the "physics root" bone of.
		
		
		**Returns:** The PhysObj ID of the given bone. -1 if we somehow cannot translate</haxe_doc>
		</TranslateBoneToPhysBone>
		<NetworkVarNotify public="1" set="method">
			<f a="name:callback">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Creates a callback that will execute when the given network variable changes - that is, when the Set<name> function is run. 
		
		
		Name | Description
		--- | ---
		`name` | Name of variable to track changes of
		`callback` | The function to call when the variable changes. It is passed 4 arugments: Entity entity - Entity whos variable changed (This will be variable called "self" in ENT:CallBack format.) string name - Name of changed variable any old - Old/current variable value any new - New variable value that it was set to
		
		
		___
		### Lua Examples
		#### Example 1
		Example usage
		
		```lua 
		function ENT:SetupDataTables()
		
		    self:NetworkVar( "Float", 0, "Amount" )
		    self:NetworkVar( "Vector", 1, "StartPos" )
		    self:NetworkVar( "Vector", 2, "EndPos" )
		
		    if ( SERVER ) then
		        self:NetworkVarNotify( "EndPos", self.OnVarChanged )
		    end
		
		end
		
		function ENT:OnVarChanged( name, old, new )
		    print( name, old, new )
		end
		```
		**Output:**
		
		Prints variable name, old value and new value whenever SetEndPos function is called]]></haxe_doc>
		</NetworkVarNotify>
		<GetBonePosition public="1" set="method">
			<f a="boneIndex">
				<x path="Float"/>
				<c path="gmod.gclass.EntityGetBonePositionReturn"/>
			</f>
			<haxe_doc>Returns the position and angle of the given attachment, relative to the world. 
		
		
		Name | Description
		--- | ---
		`boneIndex` | The bone index of the bone to get the position of. See Entity: LookupBone.
		
		
		Name | Description
		--- | ---
		`a` | The bone's position relative to the world.
		`b` | The bone's angle relative to the world.</haxe_doc>
		</GetBonePosition>
		<SetParentPhysNum public="1" set="method">
			<f a="bone">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the parent of an entity to another entity with the given physics bone number. Similar to Entity:SetParent, except it is parented to a physbone. This function is useful mainly for ragdolls. 
		
		
		Name | Description
		--- | ---
		`bone` | Physics bone number to attach to. Use 0 for objects with only one physics bone. (See Entity: GetPhysicsObjectNum)</haxe_doc>
		</SetParentPhysNum>
		<SkinCount public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the amount of skins the entity has. 
		
		
		**Returns:** The amount of skins the entity's model has.</haxe_doc>
		</SkinCount>
		<MakePhysicsObjectAShadow public="1" set="method">
			<f a="allowPhysicsMovement:allowPhysicsRotation">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Turns the Entity:GetPhysicsObject into a physics shadow. It's used internally for the Player's and NPC's physics object, and certain HL2 entities such as the crane. 
		
		A physics shadow can be used to have static entities that never move by setting both arguments to false. 
		
		 
		Name | Description
		--- | ---
		`allowPhysicsMovement` | Whether to allow the physics shadow to move under stress.
		`allowPhysicsRotation` | Whether to allow the physics shadow to rotate under stress.</haxe_doc>
		</MakePhysicsObjectAShadow>
		<InstallDataTable public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		Sets up Data Tables from entity to use with : .</haxe_doc>
		</InstallDataTable>
		<SetMaterial public="1" set="method">
			<f a="materialName:?forceMaterial">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the rendering material override of the entity. 
		
		To set a Lua material created with CreateMaterial, just prepend a "!" to the material name. 
		
		 
		Name | Description
		--- | ---
		`materialName` | New material name. Use an empty string ( "") to reset to the default materials.
		`forceMaterial` | Use it if you wish to apply material other than VertexLitGeneric (such as tools/toolswhite).</haxe_doc>
		</SetMaterial>
		<GetModelContents public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the contents of the entity's current model. 
		
		
		**Returns:** The contents of the entity's model. See CONTENTS_ Enums.</haxe_doc>
		</GetModelContents>
		<GetMoveType public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the entity's movetype 
		
		
		**Returns:** Move type. See MOVETYPE_ Enums</haxe_doc>
		</GetMoveType>
		<GetMaterials public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns all materials of the entity's model. 
		
		This function is unaffected by Entity:SetSubMaterial as it returns the original materials. 
		
		 
		**Returns:** A table containing full paths to the materials of the model. BUG This table is limited to 127 materials, even if the entity has more. Issue Tracker: #3216</haxe_doc>
		</GetMaterials>
		<GetRight public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the rightward vector of the entity, as a normalized direction vector 
		
		
		**Returns:** rightDir</haxe_doc>
		</GetRight>
		<EmitSound public="1" set="method">
			<f a="soundName:?soundLevel:?pitchPercent:?volume:?channel">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Plays a sound on an entity. If run clientside, the sound will only be heard locally. 
		
		If used on a player or NPC character with the mouth rigged, the character will "lip-sync". This does not work with all sound files. 
		
		 It is recommended to use sound scripts ( see sound.Add ) over direct file paths. This will allow you to use Entity:StopSound to stop the played sound scripts. 
		
		 
		Name | Description
		--- | ---
		`soundName` | The name of the sound to be played. WARNING The string will cannot have whitespace at the start or end. You can remove this with string.Trim.
		`soundLevel` | A modifier for the distance this sound will reach, acceptable range is 0 to 511. 100 means no adjustment to the level. See SNDLVL_ Enums Will not work if a sound script is used.
		`pitchPercent` | The pitch applied to the sound. The acceptable range is from 0 to 255. 100 means the pitch is not changed.
		`volume` | The volume, from 0 to 1.
		`channel` | The sound channel, see CHAN_ Enums. Will not work if a sound script is used.
		
		
		___
		### Lua Examples
		#### Example 1
		Plays sound from the first player on the server.
		
		```lua 
		Entity(1):EmitSound( "path/to/sound.wav", 75, 100, 1, CHAN_AUTO ) -- Same as below
		Entity(1):EmitSound( "path/to/sound.wav" ) -- You can remove the arguments that have default values.
		```</haxe_doc>
		</EmitSound>
		<SetNetworkedVarProxy public="1" set="method">
			<f a="name:callback">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should be using Entity: SetNWVarProxy instead.
		
		Sets callback function to be called when given NWVar changes. 
		
		
		Name | Description
		--- | ---
		`name` | The name of the NWVar to add callback for.
		`callback` | The function to be called when the NWVar changes.</haxe_doc>
		</SetNetworkedVarProxy>
		<GetMoveParent public="1" set="method">
			<f a=""><c path="gmod.gclass.Entity"/></f>
			<haxe_doc>Returns the movement parent of this entity. 
		
		See Entity:SetMoveParent for more info. 
		
		 
		**Returns:** The movement parent of this entity.</haxe_doc>
		</GetMoveParent>
		<SetTable public="1" set="method">
			<f a="tab">
				<t path="lua.AnyTable"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Changes the table that can be accessed by indexing an entity. Each entity starts with its own table by default. 
		
		
		Name | Description
		--- | ---
		`tab` | Table for the entity to use</haxe_doc>
		</SetTable>
		<OBBCenter public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the center of an entity's bounding box as a local vector. 
		
		
		**Returns:** OBBCenter</haxe_doc>
		</OBBCenter>
		<ManipulateBonePosition public="1" set="method">
			<f a="boneID:pos">
				<x path="Float"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets custom bone offsets. 
		
		
		Name | Description
		--- | ---
		`boneID` | Index of the bone you want to manipulate
		`pos` | Position vector to apply Note that the position is relative to the original bone position, not relative to the world or the entity.</haxe_doc>
		</ManipulateBonePosition>
		<GetSequenceName public="1" set="method">
			<f a="index">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>Return the name of the sequence for the index provided. Refer to Entity:GetSequence to find the current active sequence on this entity. 
		
		
		Name | Description
		--- | ---
		`index` | The index of the sequence to look up.
		
		
		**Returns:** Name of the sequence.</haxe_doc>
		</GetSequenceName>
		<GetNoDraw public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns if the entity's rendering and transmitting has been disabled. 
		
		
		**Returns:** Whether the entity's rendering and transmitting has been disabled.</haxe_doc>
		</GetNoDraw>
		<GetNWBool public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<haxe_doc>Retrieves a networked boolean value at specified index on the entity that is set by Entity:SetNWBool. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. (If it isn't set)
		
		
		**Returns:** The value associated with the key</haxe_doc>
		</GetNWBool>
		<SetBodyGroups public="1" set="method">
			<f a="bodygroups">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the bodygroups from a string. A convenience function for Entity:SetBodygroup. 
		
		
		Name | Description
		--- | ---
		`bodygroups` | Body groups to set. Each single-digit number in the string represents a separate bodygroup. This make it impossible to set any bodygroup to a value higher than 9! For that you need to use Entity: SetBodygroup.
		
		
		___
		### Lua Examples
		#### Example 1
		Example of the format
		
		```lua 
		Entity(1):SetBodyGroups( "021" )
		```
		**Output:**
		
		Sets first bodygroup value to 0, second to 2 and third to 1.</haxe_doc>
		</SetBodyGroups>
		<GetBoneCount public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the amount of bones in the entity. 
		
		
		**Returns:** The amount of bones in given entity; -1 on failure.
		
		___
		### Lua Examples
		#### Example 1
		Prints amount of bones in player 1
		
		```lua 
		print( Entity(1):GetBoneCount() )
		```
		**Output:**
		
		The amount of bones in player 1, which normally would be 68.</haxe_doc>
		</GetBoneCount>
		<GetDTAngle public="1" set="method">
			<f a="key">
				<x path="Float"/>
				<c path="gmod.gclass.Angle"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Get an angle stored in the datatable of the entity. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 63. Specifies what key to grab from datatable.
		
		
		**Returns:** Requested angle.</haxe_doc>
		</GetDTAngle>
		<WorldSpaceCenter public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the center of the entity according to its collision model. 
		
		
		**Returns:** The center of the entity</haxe_doc>
		</WorldSpaceCenter>
		<GetPhysicsObjectNum public="1" set="method">
			<f a="physNum">
				<x path="Float"/>
				<c path="gmod.gclass.PhysObj"/>
			</f>
			<haxe_doc><![CDATA[Returns a specific physics object from an entity with multiple PhysObjects (like ragdolls) 
		
		See also Entity:TranslateBoneToPhysBone. 
		
		 
		Name | Description
		--- | ---
		`physNum` | The number corresponding to the PhysObj to grab. Starts at 0.
		
		
		**Returns:** The physics object
		
		___
		### Lua Examples
		#### Example 1
		When run, if the player is dead it will throw their ragdoll up in the air by their head.
		
		```lua 
		if (!LocalPlayer():Alive() && LocalPlayer():GetRagdollEntity() ) then
		    local ent = LocalPlayer():GetRagdollEntity()
		    local head = ent:GetPhysicsObjectNum( 10 ) // 10 is usually the bone number of the head.
		    head:ApplyForceCenter( Vector( 0, 0, 6000 ) )
		end
		```
		
		#### Example 2
		Example function that applies force to all physics objects of given entity.
		
		```lua 
		function ApplySomeForce( ent )
		    for i = 0, ent:GetPhysicsObjectCount() - 1 do
		        local phys = ent:GetPhysicsObjectNum( i )
		        phys:ApplyForceCenter( Vector( 0, 0, 10000 ) )
		    end
		end
		```]]></haxe_doc>
		</GetPhysicsObjectNum>
		<PhysicsInitSphere public="1" set="method">
			<f a="radius:physmat">
				<x path="Float"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Makes the physics object of the entity a sphere. 
		
		
		Name | Description
		--- | ---
		`radius` | The radius of the sphere.
		`physmat` | Physical material from surfaceproperties.txt or added with physenv. AddSurfaceData.
		
		
		**Returns:** Returns true on success, false otherwise</haxe_doc>
		</PhysicsInitSphere>
		<EyePos public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the position of an Player/NPC's view. 
		
		
		**Returns:** View position of the entity.</haxe_doc>
		</EyePos>
		<GetHitboxSet public="1" set="method">
			<f a=""><c path="gmod.gclass.EntityGetHitboxSetReturn"/></f>
			<haxe_doc>Returns entity's current hit box set 
		
		
		Name | Description
		--- | ---
		`a` | The current hit box set id, or no value if the entity doesn't have hit boxes
		`b` | The current hit box set name, or no value if the entity doesn't have hit boxes</haxe_doc>
		</GetHitboxSet>
		<SetPlaybackRate public="1" set="method">
			<f a="fSpeed">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows you to set how fast an entity's animation will play, with 1.0 being the default speed. 
		
		
		Name | Description
		--- | ---
		`fSpeed` | How fast the animation will play.
		
		
		___
		### Lua Examples
		#### Example 1
		Makes Entity(1)'s viewmodel play animations 50% slower.
		
		```lua 
		Entity(1):GetViewModel():SetPlaybackRate(0.5)
		```
		**Output:**
		
		Entity(1)'s viewmodel now plays animations 50% slower.</haxe_doc>
		</SetPlaybackRate>
		<SetOwner public="1" set="method">
			<f a="?owner">
				<c path="gmod.gclass.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the owner of this entity, disabling all physics interaction with it. 
		
		
		Name | Description
		--- | ---
		`owner` | The entity to be set as owner.
		
		
		___
		### Lua Examples
		#### Example 1
		Taken from Garry's Flechette gun , shoots a hunter's flechette and sets the owner of the flechette to the player using the weapon.
		
		```lua 
		function SWEP:PrimaryAttack()
		    self:SetNextPrimaryFire( CurTime() + 0.1 )
		    
		    if (!SERVER) then return end
		
		    local Forward = self.Owner:EyeAngles():Forward()
		
		    local ent = ents.Create( "hunter_flechette" )
		    
		    if ( IsValid( ent ) ) then
		
		        ent:SetPos( self.Owner:GetShootPos() + Forward * 32 )
		        ent:SetAngles( self.Owner:EyeAngles() )
		        ent:Spawn()
		        ent:SetVelocity( Forward * 2000 )
		        ent:SetOwner( self.Owner )
		    end
		end
		```</haxe_doc>
		</SetOwner>
		<GetPos public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Gets the position of entity in world. 
		
		
		**Returns:** The position of the entity.
		
		___
		### Lua Examples
		#### Example 1
		Utility command that would give you the position of the entity you are looking at.
		
		```lua 
		concommand.Add( "entity_pos", function( ply )
		    local tr = ply:GetEyeTrace()
		    if ( IsValid( tr.Entity ) ) then
		        print( "Entity position:", tr.Entity:GetPos() )
		    else
		        print( "Crosshair position:", tr.HitPos )
		    end
		end )
		```</haxe_doc>
		</GetPos>
		<GetNetworkedVarProxy public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="haxe.Function"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should be using Entity: GetNWVarProxy instead.
		
		Returns callback function for given NWVar of this entity. 
		
		
		Name | Description
		--- | ---
		`name` | The name of the NWVar to get callback of.
		
		
		**Returns:** The callback of given NWVar, if any.
		
		___
		### Lua Examples
		#### Example 1
		Prints callback function of a NWVar called "Key" of Player 1.
		
		```lua 
		print( Entity(1):GetNetworkedVarProxy( "Key" ) )
		Entity(1):SetNetworkedVarProxy( "Key", print )
		print( Entity(1):GetNetworkedVarProxy( "Key" ) )
		```</haxe_doc>
		</GetNetworkedVarProxy>
		<GetLocalAngles public="1" set="method">
			<f a=""><c path="gmod.gclass.Angle"/></f>
			<haxe_doc>Returns the rotation of the entity relative to its parent entity. 
		
		
		**Returns:** Relative angle</haxe_doc>
		</GetLocalAngles>
		<LookupSequence public="1" set="method">
			<f a="name">
				<c path="String"/>
				<c path="gmod.gclass.EntityLookupSequenceReturn"/>
			</f>
			<haxe_doc>Returns sequence ID from its name. 
		
		
		Name | Description
		--- | ---
		`name` | Sequence name
		
		
		Name | Description
		--- | ---
		`a` | Sequence ID for that name. This will differ for models with same sequence names. Will be -1 whether the sequence is invalid.
		`b` | The sequence duration 0 if the sequence is invalid</haxe_doc>
		</LookupSequence>
		<HasBoneManipulations public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether or not the bone manipulation functions have ever been called on given entity. 
		
		Related functions are Entity:ManipulateBonePosition, Entity:ManipulateBoneAngles, Entity:ManipulateBoneJiggle, and Entity:ManipulateBoneScale. 
		
		 
		**Returns:** True if the entity has been bone manipulated, false otherwise.</haxe_doc>
		</HasBoneManipulations>
		<EntIndex public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gets the unique entity index of an entity. 
		
		
		**Returns:** The index of the entity. -1 for clientside-only or serverside-only entities.
		
		___
		### Lua Examples
		#### Example 1
		Demonstrates the use of this function.
		
		```lua 
		print( player.GetAll()[1]:EntIndex() )
		```
		**Output:**
		
		1</haxe_doc>
		</EntIndex>
		<RemoveCallback public="1" set="method">
			<f a="hook:callbackid">
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes a callback previously added with Entity:AddCallback 
		
		
		Name | Description
		--- | ---
		`hook` | The hook name to remove. See Entity Callbacks
		`callbackid` | The callback id previously retrieved with the return of Entity: AddCallback or Entity: GetCallbacks</haxe_doc>
		</RemoveCallback>
		<SetVar public="1" set="method">
			<f a="key:value">
				<x path="Any"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows to quickly set variable to entity's Entity:GetTable. 
		
		
		Name | Description
		--- | ---
		`key` | Key of the value to set
		`value` | Value to set the variable to</haxe_doc>
		</SetVar>
		<SetNWBool public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a networked boolean value on the entity. 
		
		The value can then be accessed with Entity:GetNWBool both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set
		
		
		___
		### Lua Examples
		#### Example 1
		Sets a networked boolean with a key of "VIP" and a value of true on a player.
		
		```lua 
		player:SetNWBool( "VIP", true )
		print( player:GetNWBool( "VIP" ) )
		```
		**Output:**
		
		true</haxe_doc>
		</SetNWBool>
		<PhysicsInit public="1" set="method">
			<f a="solidType">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Initializes the physics object of the entity using its current model. Deletes the previous physics object if it existed and the new object creation was successful. 
		
		If the entity's current model has no physics mesh associated to it, no physics object will be created and the previous object will still exist, if applicable. 
		
		 
		Name | Description
		--- | ---
		`solidType` | The solid type of the physics object to create, see SOLID_ Enums. Should be SOLID_VPHYSICS in most cases. NOTE Using SOLID_NONE will only delete the current physics object - it does not create a new one.
		
		
		**Returns:** Returns true on success, false otherwise.</haxe_doc>
		</PhysicsInit>
		<GetModel public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Gets the model of given entity. 
		
		
		**Returns:** The entity's model. Will be a filesystem path for most models. This will be nil for entities which cannot have models, such as point entities.</haxe_doc>
		</GetModel>
		<GetMaterial public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the material override for this entity. 
		
		Returns an empty string if no material override exists. Use Entity:GetMaterials to list it's default materials. 
		
		 
		**Returns:** material</haxe_doc>
		</GetMaterial>
		<GetCycle public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the frame of the currently played sequence. This will be a number between 0 and 1 as a representation of sequence progress. 
		
		
		**Returns:** The frame of the currently played sequence</haxe_doc>
		</GetCycle>
		<IsMarkedForDeletion public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns if the entity is going to be deleted in the next frame. 
		
		
		**Returns:** If the entity is going to be deleted.</haxe_doc>
		</IsMarkedForDeletion>
		<ResetSequence public="1" set="method">
			<f a="sequence">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Plays an animation on the entity. This may not always work on engine entities. 
		
		
		Name | Description
		--- | ---
		`sequence` | The sequence to play. Also accepts strings. NOTE If set to a string, the function will automatically call Entity:LookupSequence to retrieve the sequence ID as a number.
		
		
		___
		### Lua Examples
		#### Example 1
		Minimal code needed to make sequences work as expected on custom "anim" type entities.In this example, when the player uses the crate, it will open, and when they use it again, it will close.
		
		```lua 
		ENT.Base = "base_anim"
		ENT.Spawnable = true
		ENT.AutomaticFrameAdvance = true
		
		ENT.PrintName = "Animation Test"
		ENT.Category = "My Entity Category"
		
		function ENT:Initialize()
		    if ( SERVER ) then -- Only set this stuff on the server, it is networked to clients automatically
		        self:SetModel( "models/items/ammocrate_ar2.mdl" ) -- Set the model
		        self:PhysicsInit( SOLID_VPHYSICS ) -- Initialize physics
		        self:SetUseType( SIMPLE_USE ) -- Make sure ENT:Use is ran only once per use ( per press of the use button on the entity, by default the E key )
		    end
		end
		
		function ENT:Think()
		    if ( SERVER ) then -- Only set this stuff on the server
		        self:NextThink( CurTime() ) -- Set the next think for the serverside hook to be the next frame/tick
		        return true -- Return true to let the game know we want to apply the self:NextThink() call
		    end
		end
		
		if ( SERVER ) then -- This hook is only available on the server
		    function ENT:Use( activator, caller ) -- If a player uses this entity, play an animation
		        if (!self.Opened ) then -- If we are not "opened"
		            self:ResetSequence( "open" ) -- Play the open sequence
		            self.Opened = true -- We are now opened
		        else
		            self:ResetSequence( "close" ) -- Play the close sequence
		            self.Opened = false -- We are now closed
		        end
		    end
		end
		```</haxe_doc>
		</ResetSequence>
		<SetMoveCollide public="1" set="method">
			<f a="moveCollideType">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the move collide type of the entity. The move collide is the way a physics object reacts to hitting an object - will it bounce, slide? 
		
		
		Name | Description
		--- | ---
		`moveCollideType` | The move collide type, see MOVECOLLIDE_ Enums</haxe_doc>
		</SetMoveCollide>
		<GetDTFloat public="1" set="method">
			<f a="key">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Get a float stored in the datatable of the entity. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 31. Specifies what key to grab from datatable.
		
		
		**Returns:** Requested float.</haxe_doc>
		</GetDTFloat>
		<SetAttachment public="1" set="method">
			<f a="ent:attachment">
				<c path="gmod.gclass.Entity"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should be using Entity: SetParent instead.
		
		Parents the sprite to an attachment on another model. 
		
		Works only on env_sprite. 
		
		 Despite existing on client, it doesn't actually do anything on client. 
		
		 
		Name | Description
		--- | ---
		`ent` | The entity to attach/parent to
		`attachment` | The attachment ID to parent to</haxe_doc>
		</SetAttachment>
		<GetRotatedAABB public="1" set="method">
			<f a="min:max">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.EntityGetRotatedAABBReturn"/>
			</f>
			<haxe_doc>Returns the min and max of the entity's axis-aligned bounding box. 
		
		
		Name | Description
		--- | ---
		`min` | Minimum extent of the bounding box.
		`max` | Maximum extent of the bounding box.
		
		
		Name | Description
		--- | ---
		`a` | Minimum extent of the AABB
		`b` | Maximum extent of the AABB
		
		
		___
		### Lua Examples
		#### Example 1
		The entity's AABB center (regardless of model origin) is stored in 'pos'.
		
		```lua 
		local a, b = ent:GetRotatedAABB( v:OBBMins(), v:OBBMaxs() )
		local pos = ( ent:GetPos() + ( a + b ) / 2 )
		```
		**Output:**
		
		pos has the coordinates of the AABB center.</haxe_doc>
		</GetRotatedAABB>
		<GetCollisionGroup public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the entity's collision group 
		
		
		**Returns:** The collision group. See COLLISION_GROUP_ Enums</haxe_doc>
		</GetCollisionGroup>
		<GetParentPhysNum public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>If the entity is parented to an entity that has a model with multiple physics objects (like a ragdoll), this is used to retrieve what physics object number the entity is parented to on it's parent. 
		
		
		**Returns:** The physics object id, or nil if the entity has no parent</haxe_doc>
		</GetParentPhysNum>
		<BoundingRadius public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the distance between the center of the bounding box and the furthest bounding box corner. 
		
		
		**Returns:** The radius of the bounding box.</haxe_doc>
		</BoundingRadius>
		<SetRenderMode public="1" set="method">
			<f a="renderMode">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the render mode of the entity. 
		
		
		Name | Description
		--- | ---
		`renderMode` | New render mode to set, see RENDERMODE_ Enums.</haxe_doc>
		</SetRenderMode>
		<LocalToWorld public="1" set="method">
			<f a="lpos">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Converts a vector local to an entity into a worldspace vector 
		
		
		Name | Description
		--- | ---
		`lpos` | The local vector
		
		
		**Returns:** The translated to world coordinates vector
		
		___
		### Lua Examples
		#### Example 1
		Produces a worldvector 100 units in front of the center of the entity, taking into account the entity's angle
		
		```lua 
		return ent:LocalToWorld(Vector(100,0,0))
		```</haxe_doc>
		</LocalToWorld>
		<GetParentAttachment public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the attachment index of the entity's parent. Returns 0 if the entity is not parented to a specific attachment or if it isn't parented at all. 
		
		This is set by second argument of Entity:SetParent or the SetParentAttachment input. 
		
		 
		**Returns:** The parented attachment index</haxe_doc>
		</GetParentAttachment>
		<GetManipulateBonePosition public="1" set="method">
			<f a="boneId">
				<x path="Float"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Gets the entity's position manipulation of the given bone. This is relative to the default position, so it is zero when unmodified. 
		
		
		Name | Description
		--- | ---
		`boneId` | The bone's ID
		
		
		**Returns:** The entity's position manipulation of the given bone.</haxe_doc>
		</GetManipulateBonePosition>
		<GetBoneParent public="1" set="method">
			<f a="bone">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns parent bone of given bone. 
		
		
		Name | Description
		--- | ---
		`bone` | The bode ID of the bone to get parent of
		
		
		**Returns:** Parent bone ID or -1 if we failed for some reason.</haxe_doc>
		</GetBoneParent>
		<StartMotionController public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Starts a motion controller in the physics engine tied to this entity's PhysObj, which enables the use of ENTITY:PhysicsSimulate. 
		
		The motion controller can later be destroyed via Entity:StopMotionController. 
		
		 Motion controllers are used internally to control other Entities' PhysObjects, such as the Gravity Gun, +use pickup and the Physics Gun. 
		
		 This function should be called every time you recreate the Entity's PhysObj. Or alternatively you should call Entity:AddToMotionController on the new PhysObj. 
		
		 Also see Entity:AddToMotionController and Entity:RemoveFromMotionController.</haxe_doc>
		</StartMotionController>
		<GetDTInt public="1" set="method">
			<f a="key">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Get an integer stored in the datatable of the entity. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 63. Specifies what key to grab from datatable.
		
		
		**Returns:** 32-bit signed integer</haxe_doc>
		</GetDTInt>
		<GetTransmitWithParent public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the TransmitWithParent flag is set or not. 
		
		
		**Returns:** Is the TransmitWithParent flag is set or not</haxe_doc>
		</GetTransmitWithParent>
		<GetSpawnEffect public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[Returns if we should show a spawn effect on spawn on this entity. 
		
		
		**Returns:** The flag to allow or disallow the spawn effect.
		
		___
		### Lua Examples
		#### Example 1
		Taken from sandbox's cl_init.lua
		
		```lua 
		function GM:NetworkEntityCreated( ent )
		
		    --
		    -- If the entity wants to use a spawn effect
		    -- then create a propspawn effect if the entity was
		    -- created within the last second (this function gets called
		    -- on every entity when joining a server)
		    --
		
		    if ( ent:GetSpawnEffect() && ent:GetCreationTime() > ( CurTime() - 1.0 ) ) then
		    
		        local ed = EffectData()
		        ed:SetEntity( ent )
		        util.Effect( "propspawn", ed, true, true )
		
		    end
		
		end
		```
		**Output:**
		
		Checks if the entity has the spawnEffect flag set to true and checks if it was created in the last second, and then shows the propspawn effect.]]></haxe_doc>
		</GetSpawnEffect>
		<GetMoveCollide public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the move collide type of the entity. The move collide is the way a physics object reacts to hitting an object - will it bounce, slide? 
		
		
		**Returns:** The move collide type, see MOVECOLLIDE_ Enums</haxe_doc>
		</GetMoveCollide>
		<IsWidget public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the entity is a widget or not. 
		
		This is used by the "Edit Bones" context menu property. 
		
		 
		**Returns:** Whether the entity is a widget or not.</haxe_doc>
		</IsWidget>
		<GetSolidFlags public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns solid flag(s) of an entity. 
		
		
		**Returns:** The flag(s) of the entity, see FSOLID_ Enums.</haxe_doc>
		</GetSolidFlags>
		<IsConstrained public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[Returns true if the entity has constraints attached to it 
		
		
		**Returns:** Whether the entity is constrained or not.
		
		___
		### Lua Examples
		#### Example 1
		From entities/prop_effect.lua
		
		```lua 
		function ENT:PhysicsUpdate( physobj )
		
		    if ( CLIENT ) then return end
		
		    -- Don't do anything if the player isn't holding us
		    if (!self:IsPlayerHolding() &&!self:IsConstrained() ) then
		        physobj:SetVelocity( Vector(0,0,0) )
		        physobj:Sleep() 
		    end
		end
		```]]></haxe_doc>
		</IsConstrained>
		<GetSkin public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the skin index of the current skin. 
		
		
		**Returns:** skinIndex</haxe_doc>
		</GetSkin>
		<EyeAngles public="1" set="method">
			<f a=""><c path="gmod.gclass.Angle"/></f>
			<haxe_doc>Returns the direction a player/npc/ragdoll is looking as a world-oriented angle. 
		
		
		**Returns:** eyeAng
		
		___
		### Lua Examples
		#### Example 1
		Print the local player's angles
		
		```lua 
		print(LocalPlayer():EyeAngles())
		```
		**Output:**
		
		When looking straight down, it might return Angle(89,-175.38,0)</haxe_doc>
		</EyeAngles>
		<GetFlexBounds public="1" set="method">
			<f a="flex">
				<x path="Float"/>
				<c path="gmod.gclass.EntityGetFlexBoundsReturn"/>
			</f>
			<haxe_doc>Returns acceptable value range for the flex. 
		
		
		Name | Description
		--- | ---
		`flex` | The ID of the flex to look up bounds of
		
		
		Name | Description
		--- | ---
		`a` | The minimum value for this flex
		`b` | The maximum value for this flex</haxe_doc>
		</GetFlexBounds>
		<SetBoneController public="1" set="method">
			<f a="boneControllerID:value">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the specified value on the bone controller with the given ID of this entity, it's used in HL1 to change the head rotation of NPCs, turret aiming and so on. 
		
		
		Name | Description
		--- | ---
		`boneControllerID` | The ID of the bone controller to set the value to. Goes from 0 to 3.
		`value` | The value to set on the specified bone controller.</haxe_doc>
		</SetBoneController>
		<SetNWAngle public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a networked angle value on the entity. 
		
		The value can then be accessed with Entity:GetNWAngle both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set
		
		
		___
		### Lua Examples
		#### Example 1
		This will set the networked angle 'direction' on all clients that is pointing straight up.
		
		```lua 
		for k, v in pairs( player.GetAll() ) do
		    v:SetNWAngle( 'direction', Angle( -90, 0, 0 ) )
		end
		```</haxe_doc>
		</SetNWAngle>
		<GetBodygroup public="1" set="method">
			<f a="id">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Gets the exact value for specific bodygroup of given entity. 
		
		
		Name | Description
		--- | ---
		`id` | The id of bodygroup to get value of. Starts from 0.
		
		
		**Returns:** Current bodygroup. Starts from 0.
		
		___
		### Lua Examples
		#### Example 1
		Gets the value of bodygroup 2 of entity player 1 is aiming at.
		
		```lua 
		print( Entity(1):GetEyeTrace().Entity:GetBodygroup(2) )
		```
		**Output:**
		
		"1" in console, if player 1 is aiming at airboat.</haxe_doc>
		</GetBodygroup>
		<GetManipulateBoneAngles public="1" set="method">
			<f a="boneID">
				<x path="Float"/>
				<c path="gmod.gclass.Angle"/>
			</f>
			<haxe_doc>Gets the entity's angle manipulation of the given bone. This is relative to the default angle, so the angle is zero when unmodified. 
		
		
		Name | Description
		--- | ---
		`boneID` | The bone's ID
		
		
		**Returns:** The entity's angle manipulation of the given bone.</haxe_doc>
		</GetManipulateBoneAngles>
		<GetPhysicsObjectCount public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the number of physics objects an entity has (usually 1 for non-ragdolls) 
		
		
		**Returns:** numObjects
		
		___
		### Lua Examples
		#### Example 1
		Finds all the Physics Objects in a ragdoll and applies an upward force
		
		```lua 
		for i=0, ragdoll:GetPhysicsObjectCount() - 1 do -- "ragdoll" being a ragdoll entity
		 
		    local phys = ragdoll:GetPhysicsObjectNum(i)
		    phys:ApplyForceCenter( Vector( 0, 0, 10000 ) )
		
		end
		```</haxe_doc>
		</GetPhysicsObjectCount>
		<ViewModelIndex public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the index of this view model, it can be used to identify which one of the player's view models this entity is. 
		
		
		**Returns:** View model index, ranges from 0 to 2, nil if the entity is not a view model</haxe_doc>
		</ViewModelIndex>
		<GetBodyGroups public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns a list of all bodygroups of the entity. 
		
		
		**Returns:** Bodygroups as a table of BodyGroupData structures if the entity can have bodygroups.</haxe_doc>
		</GetBodyGroups>
		<NearestPoint public="1" set="method">
			<f a="position">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Performs a Ray OBBox intersection from the given position to the origin of the OBBox with the entity and returns the hit position on the OBBox 
		
		
		Name | Description
		--- | ---
		`position` | The vector to start the intersection from.
		
		
		**Returns:** The nearest hit point of the entity's bounding box in world coordinates.</haxe_doc>
		</NearestPoint>
		<GetNetworkedFloat public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: GetNWFloat instead.
		
		Retrieves a networked float value at specified index on the entity that is set by Entity:SetNetworkedFloat. 
		
		Seems to be the same as Entity:GetNetworkedInt. 
		
		 
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. ( If it isn't set )
		
		
		**Returns:** The retrieved value</haxe_doc>
		</GetNetworkedFloat>
		<PhysicsInitBox public="1" set="method">
			<f a="mins:maxs">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Makes the physics object of the entity a AABB. 
		
		
		Name | Description
		--- | ---
		`mins` | The minimum position of the box. This is automatically ordered with the maxs.
		`maxs` | The maximum position of the box. This is automatically ordered with the mins.
		
		
		**Returns:** Returns true on success, nil otherwise. This fails when the game cannot create any more PhysCollides.</haxe_doc>
		</PhysicsInitBox>
		<GetNWVarProxy public="1" set="method">
			<f a="key">
				<x path="Any"/>
				<x path="haxe.Function"/>
			</f>
			<haxe_doc>Returns callback function for given NWVar of this entity. 
		
		
		Name | Description
		--- | ---
		`key` | The key of the NWVar to get callback of.
		
		
		**Returns:** The callback of given NWVar, or nil if not found.
		
		___
		### Lua Examples
		#### Example 1
		Prints callback function of a NWVar called "Key" of Player 1.
		
		```lua 
		print( Entity(1):GetNWVarProxy( "Key" ) )
		Entity(1):SetNWVarProxy( "Key", print )
		print( Entity(1):GetNWVarProxy( "Key" ) )
		```</haxe_doc>
		</GetNWVarProxy>
		<SetNetworkedVector public="1" set="method">
			<f a="key:?value">
				<c path="String"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: SetNWVector instead.
		
		Sets a networked vector value at specified index on the entity. 
		
		The value then can be accessed with Entity:GetNetworkedVector both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set</haxe_doc>
		</SetNetworkedVector>
		<SetNWString public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a networked string value on the entity. 
		
		The value can then be accessed with Entity:GetNWString both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set, up to 199 characters.
		
		
		___
		### Lua Examples
		#### Example 1
		Sets a networked string with a key of "Nickname" and a value of "John" on a player.
		
		```lua 
		player:SetNWString( "Nickname", "John" )
		print( player:GetNWString( "Nickname" ) )
		```
		**Output:**
		
		"John"</haxe_doc>
		</SetNWString>
		<SelectWeightedSequenceSeeded public="1" set="method">
			<f a="act:seed">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the sequence ID corresponding to given activity ID, and uses the provided seed for random selection. The seed should be the same server-side and client-side if used in a predicted environment. 
		
		See Entity:SelectWeightedSequence for a provided-seed version of this function. 
		
		 
		Name | Description
		--- | ---
		`act` | The activity ID, see ACT_ Enums.
		`seed` | The seed to use for randomly selecting a sequence in the case the activity ID has multiple sequences bound to it. Entity: SelectWeightedSequence uses the same seed as util. SharedRandom internally for this.
		
		
		**Returns:** The sequence ID</haxe_doc>
		</SelectWeightedSequenceSeeded>
		<SetEntity public="1" set="method">
			<f a="name:entity">
				<c path="String"/>
				<c path="gmod.gclass.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows you to set the Start or End entity attachment for the rope. 
		
		
		Name | Description
		--- | ---
		`name` | The name of the variable to modify. Accepted names are StartEntity and EndEntity.
		`entity` | The entity to apply to the specific attachment.
		
		
		___
		### Lua Examples
		#### Example 1
		As seen in the constraints module.
		
		```lua 
		local rope = ents.Create( "keyframe_rope" )
		
		-- Attachment point 1
		rope:SetEntity( "StartEntity",     Entity(1) )
		-- Attachment point 2
		rope:SetEntity( "EndEntity",     Entity(2) )
		```</haxe_doc>
		</SetEntity>
		<GetSubModels public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns a list of models included into the entity's model in the .qc file. 
		
		
		**Returns:** The list of models included into the entity's model in the .qc file.
		
		___
		### Lua Examples
		#### Example 1
		Example structure of the table. Prints into console sub models of a player model.
		
		```lua 
		PrintTable(Entity(1):GetSubModels() )
		```
		**Output:**
		
		1:
				name	=	models/m_anm.mdl
				id	=	0</haxe_doc>
		</GetSubModels>
		<SetDTFloat public="1" set="method">
			<f a="key:float">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Sets the specified float on the entity's datatable. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 31.
		`float` | The float to write on the entity's datatable.</haxe_doc>
		</SetDTFloat>
		<WorldToLocal public="1" set="method">
			<f a="wpos">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Converts a worldspace vector into a vector local to an entity 
		
		
		Name | Description
		--- | ---
		`wpos` | The world vector
		
		
		**Returns:** The local vector</haxe_doc>
		</WorldToLocal>
		<SetNetworkOrigin public="1" set="method">
			<f a="origin">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Virtually changes entity position for clients. Does the same thing as Entity:SetPos when used serverside. 
		
		
		Name | Description
		--- | ---
		`origin` | The position to make clients think this entity is at.</haxe_doc>
		</SetNetworkOrigin>
		<GetParent public="1" set="method">
			<f a=""><c path="gmod.gclass.Entity"/></f>
			<haxe_doc>Returns the parent entity of this entity. 
		
		
		**Returns:** parentEntity</haxe_doc>
		</GetParent>
		<IsRagdoll public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Checks if the entity is a ragdoll. 
		
		
		**Returns:** Is ragdoll or not</haxe_doc>
		</IsRagdoll>
		<PhysicsFromMesh public="1" set="method">
			<f a="vertices">
				<t path="lua.AnyTable"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Initializes the physics mesh of the entity from a triangle soup defined by a table of vertices. The resulting mesh is hollow, may contain holes, and always has a volume of 0. 
		
		While this is very useful for static geometry such as terrain displacements, it is advised to use Entity:PhysicsInitConvex or Entity:PhysicsInitMultiConvex for moving solid objects instead. 
		
		 Entity:EnableCustomCollisions needs to be called if you want players to collide with the entity correctly. 
		
		 
		Name | Description
		--- | ---
		`vertices` | A table consisting of MeshVertex structure (only the pos element is taken into account). Every 3 vertices define a triangle in the physics mesh.
		
		
		**Returns:** Returns true on success, nil otherwise.</haxe_doc>
		</PhysicsFromMesh>
		<GetSaveTable public="1" set="method">
			<f a="showAll">
				<x path="Bool"/>
				<t path="lua.AnyTable"/>
			</f>
			<haxe_doc>Returns a table of save values for an entity. 
		
		These tables are not the same between the client and the server, and different entities may have different fields. 
		
		 You can get the list different fields an entity has by looking at it's source code ( the 2013 SDK can be found online, https://github.com/ValveSoftware/source-sdk-2013 ). Accessible fields are defined by each DEFINE_FIELD and DEFINE_KEYFIELD inside the DATADESC block. 
		
		 Take the headcrab, for example: 
		
		 
		Name | Description
		--- | ---
		`showAll` | If set, shows all variables, not just the ones for save.
		
		
		**Returns:** A table containing all save values in key/value format. The value may be a sequential table (starting with 1) if the field in question is an array in engine.
		
		___
		### Lua Examples
		#### Example 1
		Get how long it has been since the player was damaged
		
		```lua 
		local meta = FindMetaTable( "Player" )
		
		function meta:GetLastDamageTime()
		    return self:GetSaveTable().m_flLastDamageTime
		end
		
		print( Entity( 1 ):GetLastDamageTime() )
		```
		**Output:**
		
		-31.965000152588
		
		#### Example 2
		Determine if a door is locked (only works on server side otherwise returns nil)
		
		```lua 
		function IsDoorLocked(ent)
		    return ent:GetSaveTable().m_bLocked
		end
		```
		**Output:**
		
		returns true if the door is locked
		
		#### Example 3
		Function DoorIsOpen( door ) that returns whether a door is open or not, for different door classes
		
		```lua 
		local TestingFunctions = {
		    ["func_door"] = function( self )
		        return ( self:GetSaveTable().m_toggle_state == 0 )
		    end,
		    ["func_door_rotating"] = function( self )
		        return ( self:GetSaveTable().m_toggle_state == 0 )
		    end,
		    ["prop_door_rotating"] = function( self )
		        return ( self:GetSaveTable().m_eDoorState ~= 0 )
		    end,
		}
		function DoorIsOpen( door )
		    local func = TestingFunctions[door:GetClass()]
		    if func then
		        return func( door )
		    end
		end
		```</haxe_doc>
		</GetSaveTable>
		<IsOnFire public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the entity is on fire. 
		
		
		**Returns:** Whether the entity is on fire or not.
		
		___
		### Lua Examples
		#### Example 1
		Demonstrates the use of this function.
		
		```lua 
		print( Entity(1):IsOnFire() )
		```
		**Output:**
		
		Outputs 'true' to the console if the player 1 is on fire.</haxe_doc>
		</IsOnFire>
		<GetModelRadius public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gets the models radius. 
		
		
		**Returns:** The radius of the model
		
		___
		### Lua Examples
		#### Example 1
		Example usage of the function, tested on player.
		
		```lua 
		print( Entity(1):GetModelRadius() )
		```
		**Output:**
		
		72</haxe_doc>
		</GetModelRadius>
		<DispatchTraceAttack public="1" set="method">
			<f a="damageInfo:traceRes:?dir">
				<c path="gmod.gclass.CTakeDamageInfo"/>
				<t path="lua.AnyTable"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Performs a trace attack. 
		
		
		Name | Description
		--- | ---
		`damageInfo` | The damage to apply.
		`traceRes` | Trace result to use to deal damage. See TraceResult structure
		`dir` | Direction of the attack.</haxe_doc>
		</DispatchTraceAttack>
		<SetDTVector public="1" set="method">
			<f a="key:vec">
				<x path="Float"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Sets the specified vector on the entity's datatable. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 31.
		`vec` | The vector to write on the entity's datatable.</haxe_doc>
		</SetDTVector>
		<SetSequence public="1" set="method">
			<f a="sequenceId">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the entity's model sequence. 
		
		If the specified sequence is already active, the animation will not be restarted. See Entity:ResetSequence for a function that restarts the animation even if it is already playing. 
		
		 In some cases you want to run Entity:ResetSequenceInfo to make this function run. 
		
		 
		Name | Description
		--- | ---
		`sequenceId` | The sequence to play. Also accepts strings. NOTE If set to a string, the function will automatically call Entity:LookupSequence to retrieve the sequence ID as a number.
		
		
		___
		### Lua Examples
		#### Example 1
		Set the entity to play the "idle" sequence.
		
		```lua 
		self:SetSequence( "idle" )
		```
		
		#### Example 2
		Set the entity to play the first sequence defined on the model (usually idle).
		
		```lua 
		self:SetSequence( 0 )
		```</haxe_doc>
		</SetSequence>
		<BoneHasFlag public="1" set="method">
			<f a="boneID:flag">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether the entity's bone has the flag or not. 
		
		
		Name | Description
		--- | ---
		`boneID` | Bone ID to test flag of.
		`flag` | The flag to test, see BONE_ Enums
		
		
		**Returns:** Whether the bone has that flag or not</haxe_doc>
		</BoneHasFlag>
		<AddToMotionController public="1" set="method">
			<f a="physObj">
				<c path="gmod.gclass.PhysObj"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds a PhysObject to the entity's motion controller so that ENTITY:PhysicsSimulate will be called for given PhysObject as well. 
		
		You must first create a motion controller with Entity:StartMotionController. 
		
		 You can remove added PhysObjects by using Entity:RemoveFromMotionController. 
		
		 
		Name | Description
		--- | ---
		`physObj` | The PhysObj to add to the motion controller.</haxe_doc>
		</AddToMotionController>
		<GetNWString public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<haxe_doc>Retrieves a networked string value at specified index on the entity that is set by Entity:SetNWString. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. (If it isn't set)
		
		
		**Returns:** The value associated with the key
		
		___
		### Lua Examples
		#### Example 1
		Prints the player's rank
		
		```lua 
		print( Entity(1):GetNWString( "usergroup" ) )
		```
		**Output:**
		
		"superadmin" in single-player</haxe_doc>
		</GetNWString>
		<GetBrushPlaneCount public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the amount of planes of non-nodraw brush model surfaces of the entity's model. 
		
		
		**Returns:** The amount of brush model planes of the entity's model. This will be 0 for any non-brush model.</haxe_doc>
		</GetBrushPlaneCount>
		<IsEffectActive public="1" set="method">
			<f a="effect">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether an entity has engine effect applied or not. 
		
		
		Name | Description
		--- | ---
		`effect` | The effect to check for, see EF_ Enums.
		
		
		**Returns:** whether an entity has the engine effect applied or not.</haxe_doc>
		</IsEffectActive>
		<StopMotionController public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stops the motion controller created with Entity:StartMotionController.</haxe_doc>
		</StopMotionController>
		<GetPlaybackRate public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the playback rate of the main sequence on this entity, with 1.0 being the default speed. 
		
		
		**Returns:** The playback rate.</haxe_doc>
		</GetPlaybackRate>
		<PhysWake public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Wakes up the entity's physics object 
		
		
		___
		### Lua Examples
		#### Example 1
		This is what the function does internally.
		
		```lua 
		local phys = self:GetPhysicsObject()
		if (phys:IsValid()) then
		    phys:Wake()
		end
		```</haxe_doc>
		</PhysWake>
		<SetAbsVelocity public="1" set="method">
			<f a="velocity">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the entity's velocity. 
		
		
		Name | Description
		--- | ---
		`velocity` | The new velocity to set.
		
		
		___
		### Lua Examples
		#### Example 1
		Makes Entity(1) fly upwards.
		
		```lua 
		Entity( 1 ):SetAbsVelocity( Vector( 0, 0, 500 ) )
		```</haxe_doc>
		</SetAbsVelocity>
		<CallOnRemove public="1" set="method">
			<f a="identifier:removeFunc:argn">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="haxe.extern.Rest"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Causes a specified function to be run if the entity is removed by any means. This can later be undone by Entity:RemoveCallOnRemove if you need it to not run. 
		
		
		Name | Description
		--- | ---
		`identifier` | Identifier of the function within CallOnRemove
		`removeFunc` | Function to be called on remove
		`argn...` | Optional arguments to pass to removeFunc. Do note that the first argument passed to the function will always be the entity being removed, and the arguments passed on here start after that.
		
		
		___
		### Lua Examples
		#### Example 1
		Stops an engine sound when the entity is removed
		
		```lua 
		Entity:CallOnRemove("StopEngineSound",function(ent) ent:StopSound( "enginenoise.wav" ) end)
		```</haxe_doc>
		</CallOnRemove>
		<WorldToLocalAngles public="1" set="method">
			<f a="ang">
				<c path="gmod.gclass.Angle"/>
				<c path="gmod.gclass.Angle"/>
			</f>
			<haxe_doc>Converts world angles to local angles ( local to the entity ) 
		
		
		Name | Description
		--- | ---
		`ang` | The world angles
		
		
		**Returns:** The local angles</haxe_doc>
		</WorldToLocalAngles>
		<GetFlexNum public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the number of flexes this entity has. 
		
		
		**Returns:** The number of flexes.</haxe_doc>
		</GetFlexNum>
		<SetKeyValue public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets Hammer key values on an entity. 
		
		You can look up which entities have what key values on the Valve Developer Community on entity pages. A list of basic entities can be found here. 
		
		 Alternatively you can look at the .fgd files shipped with Garry's Mod in the bin/ folder with a text editor to see the key values as they appear in Hammer. 
		
		 
		Name | Description
		--- | ---
		`key` | The internal key name
		`value` | The value to set
		
		
		___
		### Lua Examples
		#### Example 1
		Makes an NPC not drop his weapon and drop a healthkit on death, using SF Enumerations on a Combine Soldier.A list of spawnflags a Combine Soldier has can be found here.
		
		```lua 
		npc:SetKeyValue( "spawnflags", bit.bor( SF_NPC_NO_WEAPON_DROP, SF_NPC_DROP_HEALTHKIT ) )
		```</haxe_doc>
		</SetKeyValue>
		<GetChildren public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Gets the children of the entity - that is, every entity whose move parent is this entity. 
		
		
		**Returns:** A list of movement children entities
		
		___
		### Lua Examples
		#### Example 1
		Example usage and output
		
		```lua 
		-- ent is a prop_effect entity
		PrintTable( ent:GetChildren() )
		```
		**Output:**
		
		1 = Entity [184][prop_dynamic]</haxe_doc>
		</GetChildren>
		<GetElasticity public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the elasticity of this entity, used by some flying entities such as the Helicopter NPC to determine how much it should bounce around when colliding. 
		
		
		**Returns:** elasticity</haxe_doc>
		</GetElasticity>
		<GetParentWorldTransformMatrix public="1" set="method">
			<f a=""><c path="gmod.gclass.VMatrix"/></f>
			<haxe_doc>Returns the position and angle of the entity's move parent as a 3x4 matrix (VMatrix is 4x4 so the fourth row goes unused). The first three columns store the angle as a rotation matrix, and the fourth column stores the position vector. 
		
		
		**Returns:** The position and angle matrix. If the entity has no move parent, an identity matrix will be returned. If the entity is parented to attachment 0 or the parent isn't a BaseAnimating entity, the equivalent of Entity:GetMoveParent():GetWorldTransformMatrix() will be returned.</haxe_doc>
		</GetParentWorldTransformMatrix>
		<GibBreakClient public="1" set="method">
			<f a="force:?clr">
				<c path="gmod.gclass.Vector"/>
				<t path="lua.AnyTable"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Causes the entity to break into its current models gibs, if it has any. 
		
		You must call Entity:PrecacheGibs on the entity before using this function, or it will not create any gibs. 
		
		 If called on server, the gibs will be spawned on the currently connected clients and will not be synchronized. Otherwise the gibs will be spawned only for the client the function is called on. 
		
		 Note, that this function will not remove or hide the entity it is called on. 
		
		 For more expensive version of this function see Entity:GibBreakServer. 
		
		 
		Name | Description
		--- | ---
		`force` | The force to apply to the created gibs.
		`clr` | If set, this will be color of the broken gibs instead of the entity's color.
		
		
		___
		### Lua Examples
		#### Example 1
		A console command that breaks the prop the player is aiming at when they runt he command.
		
		```lua 
		concommand.Add( "break", function( ply )
		    local tr = ply:GetEyeTrace()
		    local ent = tr.Entity
		    if (!IsValid( ent ) ) then return end -- playing not looking at any entity, bail
		
		    ent:PrecacheGibs()
		    ent:GibBreakClient( tr.HitNormal * 100 ) -- Break in some direction
		end )
		```</haxe_doc>
		</GibBreakClient>
		<HasFlexManipulatior public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether or not the the entity has had flex manipulations performed with Entity:SetFlexWeight or Entity:SetFlexScale. 
		
		
		**Returns:** True if the entity has flex manipulations, false otherwise.
		
		___
		### Lua Examples
		#### Example 1
		Defines server-side function which manipulates all of an entity's flexes and prints true if the entity has flex manipulations.
		
		```lua 
		function FlexExample(ent)
		
		    if(!IsValid(ent)) then return end
		    
		    -- Loop through all flexes
		    for i = 0, ent:GetFlexNum()-1 do
		    
		        -- Set each flex to number ranging from 0.0 to 2.0
		        ent:SetFlexWeight(i, math.random()*2)
		        
		    end
		    
		    -- Print whether or not we have flex manipulations
		    print(ent:HasFlexManipulatior())
		
		end
		```
		**Output:**
		
		true</haxe_doc>
		</HasFlexManipulatior>
		<ClearPoseParameters public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Resets all pose parameters such as aim_yaw, aim_pitch and rotation.</haxe_doc>
		</ClearPoseParameters>
		<GetCustomCollisionCheck public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether this entity uses custom collision check set by Entity:SetCustomCollisionCheck. 
		
		
		**Returns:** Whether this entity uses custom collision check or not</haxe_doc>
		</GetCustomCollisionCheck>
		<LocalToWorldAngles public="1" set="method">
			<f a="ang">
				<c path="gmod.gclass.Angle"/>
				<c path="gmod.gclass.Angle"/>
			</f>
			<haxe_doc>Converts a local angle (local to the entity) to a world angle. 
		
		
		Name | Description
		--- | ---
		`ang` | The local angle
		
		
		**Returns:** The world angle</haxe_doc>
		</LocalToWorldAngles>
		<IsFlagSet public="1" set="method">
			<f a="flag">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Checks if given flag(s) is set or not. 
		
		
		Name | Description
		--- | ---
		`flag` | The engine flag(s) to test, see FL_ Enums
		
		
		**Returns:** Is set or not
		
		___
		### Lua Examples
		#### Example 1
		Checks if the player is on the ground.
		
		```lua 
		print( Entity( 1 ):IsFlagSet( FL_ONGROUND ))
		```</haxe_doc>
		</IsFlagSet>
		<PhysicsInitShadow public="1" set="method">
			<f a="?allowPhysicsMovement:?allowPhysicsRotation">
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Initializes the entity's physics object as a physics shadow. Removes the previous physics object if successful. This is used internally for the Player's and NPC's physics object, and certain HL2 entities such as the crane. 
		
		A physics shadow can be used to have static entities that never move by setting both arguments to false. 
		
		 
		Name | Description
		--- | ---
		`allowPhysicsMovement` | Whether to allow the physics shadow to move under stress.
		`allowPhysicsRotation` | Whether to allow the physics shadow to rotate under stress.
		
		
		**Returns:** Return true on success, nil otherwise.</haxe_doc>
		</PhysicsInitShadow>
		<UseClientSideAnimation public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Animations will be handled purely clientside instead of a fixed animtime, enabling interpolation. This does not affect layers and gestures.</haxe_doc>
		</UseClientSideAnimation>
		<IsScripted public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Checks if the entity is a SENT or a built-in entity. 
		
		
		**Returns:** Returns true if entity is scripted ( SENT ), false if not ( A built-in engine entity )</haxe_doc>
		</IsScripted>
		<SetNetworkedFloat public="1" set="method">
			<f a="key:?value">
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: SetNWFloat instead.
		
		Sets a networked float value at specified index on the entity. 
		
		The value then can be accessed with Entity:GetNetworkedFloat both from client and server. 
		
		 Seems to be the same as Entity:GetNetworkedInt. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set</haxe_doc>
		</SetNetworkedFloat>
		<SetCollisionBounds public="1" set="method">
			<f a="mins:maxs">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the collision bounds for the entity, which are used for triggers ( Entity:SetTrigger, ENTITY:Touch ), determining if rendering is necessary clientside, and collision ( If Entity:SetSolid set as SOLID_BBOX ). 
		
		Input bounds are relative to Entity:GetPos! See also Entity:SetCollisionBoundsWS. 
		
		 
		Name | Description
		--- | ---
		`mins` | The minimum vector of the bounds. The vector must be smaller than second argument on all axises.
		`maxs` | The maximum vector of the bounds. The vector must be bigger than first argument on all axises.</haxe_doc>
		</SetCollisionBounds>
		<Activate public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Activates the entity. This needs to be used on some entities (like constraints) after being spawned. 
		
		
		___
		### Lua Examples
		#### Example 1
		Spawns a 'sent_ball' on the player.
		
		```lua 
		function ENT:SpawnMe(ply)
		    local SpawningPos = ply:GetPos()
		    local ent = ents.Create("sent_ball")
		    ent:SetPos( SpawningPos ) 
		    ent:Spawn()
		    ent:Activate()
		end
		```</haxe_doc>
		</Activate>
		<GetBoneController public="1" set="method">
			<f a="boneID">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the value of the bone controller with the specified ID. 
		
		
		Name | Description
		--- | ---
		`boneID` | ID of the bone controller. Goes from 0 to 3.
		
		
		**Returns:** The value set on the bone controller.</haxe_doc>
		</GetBoneController>
		<GetForward public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the forward vector of the entity, as a normalized direction vector 
		
		
		**Returns:** forwardDir</haxe_doc>
		</GetForward>
		<FindTransitionSequence public="1" set="method">
			<f a="currentSequence:goalSequence">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a transition from the given start and end sequence. 
		
		This function was only used by HL1 entities and NPCs, before the advent of sequence blending and gestures. 
		
		 
		Name | Description
		--- | ---
		`currentSequence` | The currently playing sequence
		`goalSequence` | The goal sequence.
		
		
		**Returns:** The transition sequence, -1 if not available.</haxe_doc>
		</FindTransitionSequence>
		<GetLocalAngularVelocity public="1" set="method">
			<f a=""><c path="gmod.gclass.Angle"/></f>
			<haxe_doc>Returns the non-VPhysics angular velocity of the entity relative to its parent entity. 
		
		
		**Returns:** The velocity</haxe_doc>
		</GetLocalAngularVelocity>
		<GetManipulateBoneJiggle public="1" set="method">
			<f a="boneID">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the jiggle amount of the entity's bone. 
		
		See Entity:ManipulateBoneJiggle for more info. 
		
		 
		Name | Description
		--- | ---
		`boneID` | The bone ID
		
		
		**Returns:** Returns a value ranging from 0 to 255 depending on the value set with Entity: ManipulateBoneJiggle.</haxe_doc>
		</GetManipulateBoneJiggle>
		<OnGround public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns true if the entity is on the ground, and false if it isn't. 
		
		Internally, this checks if FL_ONGROUND is set on the entity. This is only updated for players and NPCs, and thus won't inherently work for other entities. 
		
		 
		**Returns:** Whether the entity is on the ground or not.
		
		___
		### Lua Examples
		#### Example 1
		Prints if Entity(1) is on the ground or not.
		
		```lua 
		print( Entity( 1 ):OnGround() )
		print( Entity( 1 ):IsFlagSet( FL_ONGROUND ) ) -- This should give exact same output as the first line
		```
		**Output:**
		
		In most cases, true.</haxe_doc>
		</OnGround>
		<GetDTString public="1" set="method">
			<f a="key">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Get a string stored in the datatable of the entity. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 3. Specifies what key to grab from datatable.
		
		
		**Returns:** Requested string.</haxe_doc>
		</GetDTString>
		<SetNetworkedEntity public="1" set="method">
			<f a="key:?value">
				<c path="String"/>
				<c path="gmod.gclass.Entity"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: SetNWEntity instead.
		
		Sets a networked entity value at specified index on the entity. 
		
		The value then can be accessed with Entity:GetNetworkedEntity both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set</haxe_doc>
		</SetNetworkedEntity>
		<SetNetworkedAngle public="1" set="method">
			<f a="key:?value">
				<c path="String"/>
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: SetNWAngle instead.
		
		Sets a networked angle value at specified index on the entity. 
		
		The value then can be accessed with Entity:GetNetworkedAngle both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set</haxe_doc>
		</SetNetworkedAngle>
		<SetAnimation public="1" set="method">
			<f a="playerAnim">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a player's third-person animation. Mainly used by Weapons to start the player's weapon attack and reload animations. 
		
		
		Name | Description
		--- | ---
		`playerAnim` | Player animation, see PLAYER_ Enums.</haxe_doc>
		</SetAnimation>
		<StopSound public="1" set="method">
			<f a="soundscript">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stops emitting the given sound script from the entity, especially useful for looping sound scripts. 
		
		
		Name | Description
		--- | ---
		`soundscript` | The name of the sound script to stop playback of.</haxe_doc>
		</StopSound>
		<SetCollisionBoundsWS public="1" set="method">
			<f a="vec1:vec2">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the collision bounds for the entity, which are used for triggers ( Entity:SetTrigger, ENTITY:Touch ), determining if rendering is necessary clientside, and collision ( If Entity:SetSolid set as SOLID_BBOX ). 
		
		Input bounds are in world coordinates! See also Entity:SetCollisionBounds. 
		
		 
		Name | Description
		--- | ---
		`vec1` | The first vector of the bounds.
		`vec2` | The second vector of the bounds.</haxe_doc>
		</SetCollisionBoundsWS>
		<GetNumBodyGroups public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the body group count of the entity. 
		
		
		**Returns:** Amount of bodygroups the entitys model has</haxe_doc>
		</GetNumBodyGroups>
		<PhysicsInitMultiConvex public="1" set="method">
			<f a="vertices">
				<t path="lua.AnyTable"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>An advanced version of Entity:PhysicsInitConvex which initializes a physics object from multiple convex meshes. This should be used for physics objects with a custom shape which cannot be represented by a single convex mesh. 
		
		If successful, the previous physics object will be removed. 
		
		 
		Name | Description
		--- | ---
		`vertices` | A table consisting of tables of Vectors. Each sub-table defines a set of points to be used in the computation of one convex mesh.
		
		
		**Returns:** Returns true on success, nil otherwise
		
		___
		### Lua Examples
		#### Example 1
		Creates a physics mesh for the entity which consists of two boxes.
		
		```lua 
		local min1 = Vector( -30, -10, 0 ) -- Box1 minimum corner
		local max1 = Vector( -10, 10, 20 ) -- Box1 maximum corner
		
		local min2 = Vector( 10, -5, 10 ) -- Box2 minimum corner
		local max2 = Vector( 30, 5, 40 ) -- Box2 maximum corner
		
		if SERVER then
		    function ENT:Initialize()
		        self:SetModel( "models/props_c17/oildrum001.mdl" )
		
		        -- Initializing the multi-convex physics mesh
		        self:PhysicsInitMultiConvex( {
		            { -- Each sub-table is a set of vertices of a convex piece, order doesn't matter
		                Vector( min1.x, min1.y, min1.z ), -- The first box vertices
		                Vector( min1.x, min1.y, max1.z ),
		                Vector( min1.x, max1.y, min1.z ),
		                Vector( min1.x, max1.y, max1.z ),
		                Vector( max1.x, min1.y, min1.z ),
		                Vector( max1.x, min1.y, max1.z ),
		                Vector( max1.x, max1.y, min1.z ),
		                Vector( max1.x, max1.y, max1.z ),
		            },
		            { -- All these tables together form a concave collision mesh
		                Vector( min2.x, min2.y, min2.z ), -- The second box vertices
		                Vector( min2.x, min2.y, max2.z ),
		                Vector( min2.x, max2.y, min2.z ),
		                Vector( min2.x, max2.y, max2.z ),
		                Vector( max2.x, min2.y, min2.z ),
		                Vector( max2.x, min2.y, max2.z ),
		                Vector( max2.x, max2.y, min2.z ),
		                Vector( max2.x, max2.y, max2.z ),
		            },
		        } )
		
		        self:SetSolid( SOLID_VPHYSICS ) -- Setting the solidity
		        self:SetMoveType( MOVETYPE_VPHYSICS ) -- Setting the movement type
		
		        self:EnableCustomCollisions( true ) -- Enabling the custom collision mesh
		
		        self:PhysWake() -- Enabling the physics motion
		    end
		else
		    local col = Color( 0, 0, 255, 255 )
		
		    -- Drawing collision boxes on the client
		    function ENT:Draw()
		        self:DrawModel()
		
		        local pos, ang = self:GetPos(), self:GetAngles()
		
		        render.DrawWireframeBox( pos, ang, min1, max1, col ) -- Drawing the first collision box
		        render.DrawWireframeBox( pos, ang, min2, max2, col ) -- Drawing the second collision box
		    end
		end
		```</haxe_doc>
		</PhysicsInitMultiConvex>
		<SetLocalAngles public="1" set="method">
			<f a="ang">
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets angles relative to angles of Entity:GetParent 
		
		
		Name | Description
		--- | ---
		`ang` | The local angle</haxe_doc>
		</SetLocalAngles>
		<RemoveSolidFlags public="1" set="method">
			<f a="flags">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes solid flag(s) from the entity. 
		
		
		Name | Description
		--- | ---
		`flags` | The flag(s) to remove, see FSOLID_ Enums.</haxe_doc>
		</RemoveSolidFlags>
		<PhysicsInitStatic public="1" set="method">
			<f a="solidType">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Initializes a static physics object of the entity using its current model. If successful, the previous physics object is removed. 
		
		This is what used by entities such as func_breakable, prop_dynamic, item_suitcharger, prop_thumper and npc_rollermine while it is in its "buried" state in the Half-Life 2 Campaign. 
		
		 If the entity's current model has no physics mesh associated to it, no physics object will be created. 
		
		 
		Name | Description
		--- | ---
		`solidType` | The solid type of the physics object to create, see SOLID_ Enums. Should be SOLID_VPHYSICS in most cases.
		
		
		**Returns:** Returns true on success, false otherwise. This will fail if the entity's current model has no associated physics mesh.</haxe_doc>
		</PhysicsInitStatic>
		<SetAngles public="1" set="method">
			<f a="angles">
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the angles of the entity. 
		
		
		Name | Description
		--- | ---
		`angles` | The new angles.</haxe_doc>
		</SetAngles>
		<FireBullets public="1" set="method">
			<f a="bulletInfo:?suppressHostEvents">
				<t path="lua.AnyTable"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Fires a bullet. 
		
		When used in a WEAPON hook such as WEAPON:Think or WEAPON:PrimaryAttack, it will use Player:LagCompensation internally. 
		
		 
		Name | Description
		--- | ---
		`bulletInfo` | The bullet data to be used. See the Bullet structure.
		`suppressHostEvents` | Has the effect of encasing the FireBullets call in SuppressHostEvents, only works in multiplayer.</haxe_doc>
		</FireBullets>
		<SetNWVector public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a networked vector value on the entity. 
		
		The value can then be accessed with Entity:GetNWVector both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set
		
		
		___
		### Lua Examples
		#### Example 1
		This will set the networked angle 'direction' on all clients to straight up.
		
		```lua 
		for k, v in pairs( player.GetAll() ) do
		    v:SetNWVector( 'direction', Vector( 0, 0, 1 ) )
		end
		```</haxe_doc>
		</SetNWVector>
		<GetCallbacks public="1" set="method">
			<f a="hook">
				<c path="String"/>
				<t path="lua.AnyTable"/>
			</f>
			<haxe_doc>Returns the specified hook callbacks for this entity added with Entity:AddCallback 
		
		The callbacks can then be removed with Entity:RemoveCallback. 
		
		 
		Name | Description
		--- | ---
		`hook` | The hook to retrieve the callbacks from, see Entity Callbacks for the possible hooks.
		
		
		**Returns:** A table containing the callbackid and function of all the callbacks for the specified hook</haxe_doc>
		</GetCallbacks>
		<SetMoveParent public="1" set="method">
			<f a="Parent">
				<c path="gmod.gclass.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the Movement Parent of an entity to another entity. 
		
		Similar to Entity:SetParent, except the object's coordinates are not translated automatically before parenting. 
		
		 
		Name | Description
		--- | ---
		`Parent` | The entity to change this entity's Movement Parent to.
		
		
		___
		### Lua Examples
		#### Example 1
		Sets the Movement Entity of a new entity to Player 1.
		
		```lua 
		local hat = ents.Create("prop_physics")
		//Position and angles are relative to our future parent.
		hat:SetPos(Vector(0,0,10))
		hat:SetAngles(Angle(0,90,0))
		
		hat:SetMoveParent(Entity(1))
		
		hat:Spawn()
		```</haxe_doc>
		</SetMoveParent>
		<GetSequence public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Return the index of the model sequence that is currently active for the entity. 
		
		
		**Returns:** The index of the model sequence.</haxe_doc>
		</GetSequence>
		<AddEffects public="1" set="method">
			<f a="effect">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Applies an engine effect to an entity. 
		
		
		Name | Description
		--- | ---
		`effect` | The effect to apply, see EF_ Enums.
		
		
		___
		### Lua Examples
		#### Example 1
		Adds a blinking effect to an entity.
		
		```lua 
		Entity:AddEffects( EF_ITEM_BLINK )
		```</haxe_doc>
		</AddEffects>
		<SetDTString public="1" set="method">
			<f a="key:str">
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Sets the specified string on the entity's datatable. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 3.
		`str` | The string to write on the entity's datatable, can't be more than 512 characters per string.</haxe_doc>
		</SetDTString>
		<IsPlayer public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Checks if the entity is a player or not. 
		
		
		**Returns:** Whether the entity is a player.
		
		___
		### Lua Examples
		#### Example 1
		Checks if two entities are players.
		
		```lua 
		print( player.GetByID( 1 ):IsPlayer() )
		print( ents.FindByClass( "prop_physics" )[ 1 ]:IsPlayer() )
		```</haxe_doc>
		</IsPlayer>
		<GetTable public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns the table that contains all values saved within the entity. 
		
		
		**Returns:** entTable</haxe_doc>
		</GetTable>
		<ObjectCaps public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the entity's capabilities as a bitfield. In the engine this function is mostly used to check the use type, the save/restore system and level transitions flags. 
		
		Even though the function is defined shared, it is not guaranteed to return the same value across states. 
		
		 
		**Returns:** The bitfield, a combination of the FCAP_ flags.</haxe_doc>
		</ObjectCaps>
		<GetNWFloat public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<haxe_doc>Retrieves a networked float value at specified index on the entity that is set by Entity:SetNWFloat. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. (If it isn't set)
		
		
		**Returns:** The value associated with the key</haxe_doc>
		</GetNWFloat>
		<SetSolidFlags public="1" set="method">
			<f a="flags">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets solid flag(s) for the entity. 
		
		This overrides any other flags the entity might have had. See Entity:AddSolidFlags for adding flags. 
		
		 
		Name | Description
		--- | ---
		`flags` | The flag(s) to set, see FSOLID_ Enums.
		
		
		___
		### Lua Examples
		#### Example 1
		Mimics Entity:SetTrigger call on the entity and adds FSOLID_USE_TRIGGER_BOUNDS flag to it.
		
		```lua 
		ent:SetSolidFlags( bit.bor( FSOLID_TRIGGER, FSOLID_USE_TRIGGER_BOUNDS ) )
		```</haxe_doc>
		</SetSolidFlags>
		<SetElasticity public="1" set="method">
			<f a="elasticity">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the elasticity of this entity, used by some flying entities such as the Helicopter NPC to determine how much it should bounce around when colliding. 
		
		
		Name | Description
		--- | ---
		`elasticity` | The elasticity to set.</haxe_doc>
		</SetElasticity>
		<StopLoopingSound public="1" set="method">
			<f a="id">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Stops a sound created by Entity:StartLoopingSound. 
		
		
		Name | Description
		--- | ---
		`id` | The sound ID returned by Entity: StartLoopingSound</haxe_doc>
		</StopLoopingSound>
		<IsVehicle public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Checks if the entity is a vehicle or not. 
		
		
		**Returns:** Whether the entity is a vehicle.</haxe_doc>
		</IsVehicle>
		<GetAttachment public="1" set="method">
			<f a="attachmentId">
				<x path="Float"/>
				<t path="lua.AnyTable"/>
			</f>
			<haxe_doc>Gets the orientation and position of the attachment by its ID, returns nothing if the attachment does not exist. 
		
		
		Name | Description
		--- | ---
		`attachmentId` | The internal ID of the attachment.
		
		
		**Returns:** The angle and position of the attachment. See the AngPos structure. Most notably, the table contains the keys "Ang" and "Pos".
		
		___
		### Lua Examples
		#### Example 1
		Grabs the muzzle position of a player's view model
		
		```lua 
		local vm = ply:GetViewModel()
		local obj = vm:LookupAttachment( "muzzle" )
		local muzzlepos = vm:GetAttachment( obj )
		```</haxe_doc>
		</GetAttachment>
		<SetNWEntity public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="gmod.gclass.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a networked entity value on the entity. 
		
		The value can then be accessed with Entity:GetNWEntity both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set
		
		
		___
		### Lua Examples
		#### Example 1
		This will set the networked entity 'owner' on all clients to themselves.
		
		```lua 
		for k, v in pairs( player.GetAll() ) do
		    v:SetNWEntity( "owner", v )
		end
		```</haxe_doc>
		</SetNWEntity>
		<SetNotSolid public="1" set="method">
			<f a="IsNotSolid">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets whether the entity is solid or not. 
		
		
		Name | Description
		--- | ---
		`IsNotSolid` | True will make the entity not solid, false will make it solid.</haxe_doc>
		</SetNotSolid>
		<StopParticles public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Stops any attached to the entity .pcf particles using ParticleEffectAttach. 
		
		On client, this is the same as Entity:StopParticleEmission. ( and you should use StopParticleEmission instead ) On server, this is the same as running Entity:StopParticleEmission on every client.</haxe_doc>
		</StopParticles>
		<SetLocalVelocity public="1" set="method">
			<f a="velocity">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the entity's local velocity which is their velocity due to movement in the world from forces such as gravity. Does not include velocity from entity-on-entity collision or other world movement. 
		
		
		Name | Description
		--- | ---
		`velocity` | The new velocity to set.</haxe_doc>
		</SetLocalVelocity>
		<IsNPC public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Checks if the entity is an NPC or not. 
		
		This will return false for NextBots. 
		
		 
		**Returns:** Whether the entity is an NPC.</haxe_doc>
		</IsNPC>
		<SetBoneMatrix public="1" set="method">
			<f a="boneid:matrix">
				<x path="Float"/>
				<c path="gmod.gclass.VMatrix"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the bone matrix of given bone to given matrix. See also Entity:GetBoneMatrix. 
		
		Despite existing serverside, it does nothing. 
		
		 
		Name | Description
		--- | ---
		`boneid` | The ID of the bone
		`matrix` | The matrix to set.
		
		
		___
		### Lua Examples
		#### Example 1
		Example usage of the function.Aim at an NPC and enter "bones_cl" into your console.
		
		```lua 
		if ( CLIENT ) then
		    concommand.Add( "bones_cl", function( ply )
		        local ent = ply:GetEyeTrace().Entity
		        if (!IsValid( ent ) ) then return end
		
		        ent:AddCallback( "BuildBonePositions", function( ent, numbones )
		            for i = 0, numbones - 1 do
		                local mat = ent:GetBoneMatrix( i )
		                if (!mat ) then continue end
		
		                local scale = mat:GetScale()
		                mat:Scale( Vector( 1, 1, 1 ) * 0.5 )
		                ent:SetBoneMatrix( i, mat )
		            end
		        end )
		    end )
		end
		```</haxe_doc>
		</SetBoneMatrix>
		<GetShouldServerRagdoll public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns if entity should create a server ragdoll on death or a client one. 
		
		
		**Returns:** Returns true if ragdoll will be created on server, false if on client</haxe_doc>
		</GetShouldServerRagdoll>
		<SetSolid public="1" set="method">
			<f a="solid_type">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the solidity of an entity. 
		
		
		Name | Description
		--- | ---
		`solid_type` | The solid type. See the SOLID_ Enums.</haxe_doc>
		</SetSolid>
		<GetChildBones public="1" set="method">
			<f a="boneid">
				<x path="Float"/>
				<t path="lua.AnyTable"/>
			</f>
			<haxe_doc>Returns ids of child bones of given bone. 
		
		
		Name | Description
		--- | ---
		`boneid` | Bone id to lookup children of
		
		
		**Returns:** A table of bone ids</haxe_doc>
		</GetChildBones>
		<ForcePlayerDrop public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Forces the Entity to be dropped, when it is being held by a player's gravitygun or physgun.</haxe_doc>
		</ForcePlayerDrop>
		<SetNoDraw public="1" set="method">
			<f a="shouldNotDraw">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets if the entity's model should render at all. 
		
		If set on the server, this entity will no longer network to clients, and for all intents and purposes cease to exist clientside. 
		
		 
		Name | Description
		--- | ---
		`shouldNotDraw` | true disables drawing</haxe_doc>
		</SetNoDraw>
		<OBBMins public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the lowest corner of an entity's bounding box as a local vector. 
		
		
		**Returns:** The local position of the lowest corner of the entity's oriented bounding box.</haxe_doc>
		</OBBMins>
		<SetPoseParameter public="1" set="method">
			<f a="poseName:poseValue">
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the specified pose parameter to the specified value. 
		
		You should call Entity:InvalidateBoneCache after calling this function. 
		
		 
		Name | Description
		--- | ---
		`poseName` | Name of the pose parameter.
		`poseValue` | The value to set the pose to.
		
		
		___
		### Lua Examples
		#### Example 1
		Copies pose parameters from one entity to another. Since Entity.GetPoseParameter returns pose parameter values 0-1 on the client, they have to be remapped to the range returned by Entity.GetPoseParameterRange before being set on the target entity.
		
		```lua 
		local function CopyPoseParams(pEntityFrom, pEntityTo)
		    if (SERVER) then
		        for i = 0, pEntityFrom:GetNumPoseParameters() - 1 do
		            local sPose = pEntityFrom:GetPoseParameterName(i)
		            pEntityTo:SetPoseParameter(sPose, pEntityFrom:GetPoseParameter(sPose))
		        end
		    else
		        for i = 0, pEntityFrom:GetNumPoseParameters() - 1 do
		            local flMin, flMax = pEntityFrom:GetPoseParameterRange(i)
		            local sPose = pEntityFrom:GetPoseParameterName(i)
		            pEntityTo:SetPoseParameter(sPose, math.Remap(pEntityFrom:GetPoseParameter(sPose), 0, 1, flMin, flMax))
		        end
		    end
		end
		```</haxe_doc>
		</SetPoseParameter>
		<StartLoopingSound public="1" set="method">
			<f a="sound">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Starts a "looping" sound. As with any other sound playing methods, this function expects the sound file to be looping itself and will not automatically loop a non looping sound file as one might expect. 
		
		This function is almost identical to CreateSound, with the exception of the sound being created in the STATIC channel and with normal attenuation. 
		
		 See also Entity:StopLoopingSound 
		
		 
		Name | Description
		--- | ---
		`sound` | Sound to play. Can be either a sound script or a filepath.
		
		
		**Returns:** The ID number of started sound starting with 0, or -1 if we failed for some reason.</haxe_doc>
		</StartLoopingSound>
		<SetCollisionGroup public="1" set="method">
			<f a="group">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sets the entity's collision group. 
		
		
		Name | Description
		--- | ---
		`group` | Collision group of the entity, see COLLISION_GROUP_ Enums
		
		
		___
		### Lua Examples
		#### Example 1
		Showcase function that produces reliable player-player nocollision for targets. First argument is any player entity, second is an optional number for min time. After min time elapsed, no-collision will turn off once we are not penetrating any players.Contains no fail-saves or checks.
		
		```lua 
		function ActivateNoCollision(target, min)
		
		    local oldCollision = target:GetCollisionGroup() or COLLISION_GROUP_PLAYER
		    target:SetCollisionGroup(COLLISION_GROUP_PASSABLE_DOOR) -- Players can walk through target
		
		    if (min and (tonumber(min) > 0)) then 
		
		        timer.Simple(min, function() --after 'min' seconds
		            timer.Create(target:SteamID64().."_checkBounds_cycle", 0.5, 0, function() -- check every half second
		                local penetrating = ( self:GetPhysicsObject() and self:GetPhysicsObject():IsPenetrating() ) or false --if we are penetrating an object
		                local tooNearPlayer = false --or inside a player's hitbox
		                for _, ply in pairs(player.GetAll()) do
		                    if target:GetPos():DistToSqr(ply:GetPos()) <= (80*80) then
		                        tooNearPlayer = true
		                    end
		                end
		                if not (penetrating and tooNearPlayer) then --if both false then 
		                    target:SetCollisionGroup(oldCollision) -- Stop no-colliding by returning the original collision group (or default player collision)
		                    timer.Destroy(target:SteamID64().."_checkBounds_cycle")
		                end
		            end)
		        end)
		    end
		end
		ActivateNoCollision(Entity( 1 ), 10)
		```
		**Output:**
		
		You can walk through the player for 10 seconds]]></haxe_doc>
		</SetCollisionGroup>
		<SetTransmitWithParent public="1" set="method">
			<f a="onoff">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>When this flag is set the entity will only transmit to the player when its parent is transmitted. This is useful for things like viewmodel attachments since without this flag they will transmit to everyone (and cause the viewmodels to transmit to everyone too). 
		
		
		Name | Description
		--- | ---
		`onoff` | Will set the TransmitWithParent flag on or off</haxe_doc>
		</SetTransmitWithParent>
		<GetAnimInfo public="1" set="method">
			<f a="animIndex">
				<x path="Float"/>
				<t path="lua.AnyTable"/>
			</f>
			<haxe_doc><![CDATA[Returns a table containing the number of frames, flags, name, and FPS of an entity's animation ID. 
		
		
		Name | Description
		--- | ---
		`animIndex` | The animation ID to look up
		
		
		**Returns:** Information about the animation, or nil if the index is out of bounds
		
		___
		### Lua Examples
		#### Example 1
		A function that finds an entity sequence's corresponding animation and returns the animation info.
		
		```lua 
		function GetAnimInfoSequence( ent, seq )
		
		    if(!IsValid( ent ) ) then return nil end
		
		    local seqname = ent:GetSequenceName( seq )
		    
		    if( seqname == "Unknown" ) then return nil end
		
		    local info = nil
		    local done = ent:GetAnimInfo(0).label    -- this is how we know when to stop
		    local i = 1
		
		    -- We don't want to increment too high or we will run into errors or possibly crashes
		    while(i < 1600) do    -- arbitrary failsafe
		    
		        info = ent:GetAnimInfo(i)
		        
		        if(string.find(info.label, "@"..seqname) or string.find(info.label, "a_"..seqname)) then
		            return info
		        end
		        
		        -- the first animation info is repeated when there are no animations left in the model
		        if(info.label == done) then break end
		        
		        i = i + 1
		        
		    end
		
		    return nil
		
		end
		```]]></haxe_doc>
		</GetAnimInfo>
		<SetGravity public="1" set="method">
			<f a="gravityMultiplier">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the gravity multiplier of the entity. 
		
		
		Name | Description
		--- | ---
		`gravityMultiplier` | Value which specifies the gravity multiplier.</haxe_doc>
		</SetGravity>
		<UseTriggerBounds public="1" set="method">
			<f a="enable:?boundSize">
				<x path="Bool"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Enables or disables trigger bounds. 
		
		This will give the entity a "trigger box" that extends around its bounding box by boundSize units in X/Y and (boundSize / 2) in +Z (-Z remains the same). The trigger box is world aligned and will work regardless of the object's solidity and collision group. 
		
		 Valve use trigger boxes for all pickup items. Their bloat size is 24, a surprisingly large figure. 
		
		 
		Name | Description
		--- | ---
		`enable` | Enable or disable the bounds.
		`boundSize` | The distance/size of the trigger bounds.</haxe_doc>
		</UseTriggerBounds>
		<IsLineOfSightClear public="1" set="method">
			<f a="target">
				<c path="gmod.gclass.Vector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if the target is in line of sight. This will only work on CBaseCombatCharacter entities. 
		
		
		Name | Description
		--- | ---
		`target` | The target to test. You can also supply an Entity instead of a Vector
		
		
		**Returns:** Returns true if the line of sight is clear</haxe_doc>
		</IsLineOfSightClear>
		<GetRagdollOwner public="1" set="method">
			<f a=""><c path="gmod.gclass.Entity"/></f>
			<haxe_doc>Returns the entity which the ragdoll came from. The opposite of Player:GetRagdollEntity. 
		
		
		**Returns:** The entity who owns the ragdoll.
		
		___
		### Lua Examples
		#### Example 1
		Loop through all player ragdolls and print their owners.
		
		```lua 
		for e, ent in pairs( ents.GetAll() ) do
		    if( IsValid( ent:GetRagdollOwner() ) ) then
		        print( ent:GetRagdollOwner() )
		    end
		end
		```
		**Output:**
		
		While a player is dead and their ragdoll is spawned this returns: Player [1][PlayerName]</haxe_doc>
		</GetRagdollOwner>
		<MuzzleFlash public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Fires the muzzle flash effect of the weapon the entity is carrying. This only creates a light effect and is often called alongside Weapon:SendWeaponAnim</haxe_doc>
		</MuzzleFlash>
		<GetNetworkedInt public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: GetNWInt instead.
		
		Retrieves a networked integer value at specified index on the entity that is set by Entity:SetNetworkedInt. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. ( If it isn't set )
		
		
		**Returns:** The retrieved value</haxe_doc>
		</GetNetworkedInt>
		<SetSubMaterial public="1" set="method">
			<f a="?index:?material">
				<x path="Float"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Overrides a single material on the model of this entity. 
		
		To set a Lua material created with CreateMaterial, just prepend a "!" to the material name. 
		
		 
		Name | Description
		--- | ---
		`index` | Index of the material to override, acceptable values are from 0 to 31. Indexes are by Entity:GetMaterials, but you have to subtract 1 from them. If called with no arguments, all sub materials will be reset.
		`material` | The material to override the default one with. Set to nil to revert to default material.</haxe_doc>
		</SetSubMaterial>
		<GetInternalVariable public="1" set="method">
			<f a="VariableName">
				<c path="String"/>
				<x path="Any"/>
			</f>
			<haxe_doc>An interface for accessing internal key values on entities. This function returns variables created with DEFINE_KEYFIELD in C++ entities. 
		
		See Entity:GetSaveTable for a more detailed explanation. 
		
		 
		Name | Description
		--- | ---
		`VariableName` | Name of variable corresponding to an entity save value.
		
		
		**Returns:** The internal variable value</haxe_doc>
		</GetInternalVariable>
		<RemoveFromMotionController public="1" set="method">
			<f a="physObj">
				<c path="gmod.gclass.PhysObj"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes a PhysObject from the entity's motion controller so that ENTITY:PhysicsSimulate will no longer be called for given PhysObject. 
		
		You must first create a motion controller with Entity:StartMotionController. 
		
		 
		Name | Description
		--- | ---
		`physObj` | The PhysObj to remove from the motion controller.</haxe_doc>
		</RemoveFromMotionController>
		<HasSpawnFlags public="1" set="method">
			<f a="spawnFlags">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Returns whether this entity has the specified spawnflags bits set. 
		
		
		Name | Description
		--- | ---
		`spawnFlags` | The spawnflag bits to check, see SF_ Enums.
		
		
		**Returns:** Whether the entity has that spawnflag set or not.
		
		___
		### Lua Examples
		#### Example 1
		As seen in sandbox's PhysgunPickup hook.
		
		```lua 
		function GM:PhysgunPickup( ply, ent )
		
		    -- Don't move physboxes if the mapper logic says no
		    if ( ent:GetClass() == "func_physbox" && ent:HasSpawnFlags( SF_PHYSBOX_MOTIONDISABLED ) ) then return false end
		
		    return true
		    
		end
		```]]></haxe_doc>
		</HasSpawnFlags>
		<GetVar public="1" set="method">
			<f a="key:?_default">
				<x path="Any"/>
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<haxe_doc>Retrieves a value from entity's Entity:GetTable. Set by Entity:SetVar. 
		
		
		Name | Description
		--- | ---
		`key` | Key of the value to retrieve
		`default` | A default value to fallback to if we couldn't retrieve the value from entity
		
		
		**Returns:** Retrieved value
		
		___
		### Lua Examples
		#### Example 1
		The 2 lines of code are functionally identical.
		
		```lua 
		print( Entity( 1 ):GetVar( "Test" ) )
		
		print( Entity( 1 ).Test )
		```</haxe_doc>
		</GetVar>
		<DrawShadow public="1" set="method">
			<f a="shouldDraw">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets whether an entity's shadow should be drawn. 
		
		
		Name | Description
		--- | ---
		`shouldDraw` | True to enable, false to disable shadow drawing.</haxe_doc>
		</DrawShadow>
		<OBBMaxs public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the highest corner of an entity's bounding box as a local vector. 
		
		
		**Returns:** The local position of the highest corner of the entity's oriented bounding box.</haxe_doc>
		</OBBMaxs>
		<GetFlexIDByName public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the ID of the flex based on given name. 
		
		
		Name | Description
		--- | ---
		`name` | The name of the flex to get the ID of. Case sensitive.
		
		
		**Returns:** The ID of flex nil if no flex with given name was found</haxe_doc>
		</GetFlexIDByName>
		<GetShouldPlayPickupSound public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Checks if the entity plays a sound when picked up by a player. 
		
		
		**Returns:** True if it plays the pickup sound, false otherwise.</haxe_doc>
		</GetShouldPlayPickupSound>
		<RemoveEffects public="1" set="method">
			<f a="effect">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes an engine effect applied to an entity. 
		
		
		Name | Description
		--- | ---
		`effect` | The effect to remove, see EF_ Enums.</haxe_doc>
		</RemoveEffects>
		<PhysicsDestroy public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Destroys the current physics object of an entity.</haxe_doc>
		</PhysicsDestroy>
		<GetManipulateBoneScale public="1" set="method">
			<f a="boneID">
				<x path="Float"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Gets the entity's scale manipulation of the given bone. Normal scale is Vector( 1, 1, 1 ) 
		
		
		Name | Description
		--- | ---
		`boneID` | The bone's ID
		
		
		**Returns:** The entity's scale manipulation of the given bone</haxe_doc>
		</GetManipulateBoneScale>
		<GetHitBoxBounds public="1" set="method">
			<f a="hitbox:group">
				<x path="Float"/>
				<x path="Float"/>
				<c path="gmod.gclass.EntityGetHitBoxBoundsReturn"/>
			</f>
			<haxe_doc>Gets the bounds (min and max corners) of a hit box. 
		
		
		Name | Description
		--- | ---
		`hitbox` | The number of the hit box.
		`group` | The group of the hit box. This should be 0 in most cases.
		
		
		Name | Description
		--- | ---
		`a` | Hit box mins. Will be nil if the hit box index was out of range.
		`b` | Hit box maxs. Will be nil if the hit box index was out of range.
		
		
		___
		### Lua Examples
		#### Example 1
		Displays the mins and maxs for the client's first hitbox in the first group, which is generally the head.
		
		```lua 
		local mins, maxs = LocalPlayer():GetHitBoxBounds(0, 0)
		print(mins, maxs)
		```
		**Output:**
		
		-1.250000 -6.500000 -3.190000 8.250000 3.500000 3.310000</haxe_doc>
		</GetHitBoxBounds>
		<GetSequenceInfo public="1" set="method">
			<f a="sequenceId">
				<x path="Float"/>
				<t path="lua.AnyTable"/>
			</f>
			<haxe_doc>Returns a table of information about an entity's sequence. 
		
		
		Name | Description
		--- | ---
		`sequenceId` | The sequence id of the entity.
		
		
		**Returns:** Table of information about the entity's sequence, or nil is ID is out of range. See SequenceInfo structure
		
		___
		### Lua Examples
		#### Example 1
		Draw each player's current sequence bounding box with sequence name, activity number, and activity name above their head.
		
		```lua 
		function GM:PostPlayerDraw( ply )
		
		    seqinfo = ply:GetSequenceInfo( ply:GetSequence() )
		    seqinfo.player = ply
		    
		    render.DrawWireframeBox( ply:GetPos(), ply:GetAngles(), seqinfo.bbmin, seqinfo.bbmax, color_white, true )
		    
		end
		
		function GM:HUDPaint()
		
		    local seqinfo, textpos = nil, nil
		
		    for p, ply in pairs(player.GetAll()) do
		    
		        seqinfo = ply:GetSequenceInfo(ply:GetSequence())
		        textpos = ( ply:GetPos() + Vector( 0, 0, seqinfo.bbmax.z + 10 ) ):ToScreen()
		    
		        if ( textpos.visible ) then
		            draw.SimpleText( seqinfo.label, "GModNotify", textpos.x, textpos.y, color_white, TEXT_ALIGN_CENTER )
		            draw.SimpleText( seqinfo.activity..": "..seqinfo.activityname, "GModNotify", textpos.x, textpos.y+20, color_white, TEXT_ALIGN_CENTER )
		        end
		    
		    end
		
		end
		```</haxe_doc>
		</GetSequenceInfo>
		<RemoveCallOnRemove public="1" set="method">
			<f a="identifier">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes a function previously added via Entity:CallOnRemove. 
		
		
		Name | Description
		--- | ---
		`identifier` | Identifier of the function within CallOnRemove
		
		
		___
		### Lua Examples
		#### Example 1
		Removes the call to stop an engine's sounds when the entity is removed
		
		```lua 
		Entity:RemoveCallOnRemove("StopEngineSound")
		```</haxe_doc>
		</RemoveCallOnRemove>
		<GetPersistent public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the entity is persistent or not. 
		
		See Entity:SetPersistent for more information on persistence. 
		
		 
		**Returns:** True if the entity is set to be persistent.</haxe_doc>
		</GetPersistent>
		<SetParent public="1" set="method">
			<f a="?parent:?attachmentId">
				<c path="gmod.gclass.Entity"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the parent of this entity, making it move with its parent. 
		
		
		Name | Description
		--- | ---
		`parent` | The entity to parent to. Setting this to nil will clear the parent.
		`attachmentId` | The attachment id to use when parenting, defaults to -1 or whatever the parent had set previously. NOTE You must call Entity:SetMoveType( MOVETYPE_NONE ) on the child for this argument to have any effect!</haxe_doc>
		</SetParent>
		<GetSequenceActivity public="1" set="method">
			<f a="seq">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Return activity id out of sequence id. Opposite of Entity:SelectWeightedSequence. 
		
		
		Name | Description
		--- | ---
		`seq` | The sequence ID
		
		
		**Returns:** The activity ID, ie ACT_ Enums</haxe_doc>
		</GetSequenceActivity>
		<EnableCustomCollisions public="1" set="method">
			<f a="useCustom">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Flags an entity as using custom lua defined collisions. Fixes entities having spongy player collisions or not hitting traces, such as after Entity:PhysicsFromMesh 
		
		
		Name | Description
		--- | ---
		`useCustom` | True to flag this entity
		
		
		___
		### Lua Examples
		#### Example 1
		Creates a mesh table, and assigns it as the entity's collisions
		
		```lua 
		function ENT:ProceduralPlatform()
		    local VERTICES = {},
		    for x = 1, 32, 1, do
		        for y = 1, 32, do
		            table.insert( VERTICES, { pos = ( self:GetPos() + Vector( 0, 0, 1 ) ) } );
		            table.insert( VERTICES, { pos = ( self:GetPos() + Vector( 0, y, 1 ) ) } );
		            table.insert( VERTICES, { pos = ( self:GetPos() + Vector( x, y, 1 ) ) } );
		
		            table.insert( VERTICES, { pos = ( self:GetPos() + Vector( 0, 0, 1 ) ) } );
		            table.insert( VERTICES, { pos = ( self:GetPos() + Vector( x, y, 1 ) ) } );
		            table.insert( VERTICES, { pos = ( self:GetPos() + Vector( x, 0, 1 ) ) } );
		        end
		    end
		    self:PhysicsFromMesh( VERTICES );
		    self:GetPhysicsObject():EnableMotion( false );
		    self:EnableCustomCollisions( true );
		end
		```</haxe_doc>
		</EnableCustomCollisions>
		<FollowBone public="1" set="method">
			<f a="?parent:boneid">
				<c path="gmod.gclass.Entity"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Makes an entity follow another entity's bone. 
		
		Internally this function calls Entity:SetParent( parent, boneid ) and Entity:AddEffects( EF_FOLLOWBONE ). 
		
		 
		Name | Description
		--- | ---
		`parent` | The entity to follow the bone of. If unset, removes the FollowBone effect.
		`boneid` | The bone to follow</haxe_doc>
		</FollowBone>
		<GetGravity public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gets the gravity multiplier of the entity. 
		
		
		**Returns:** gravityMultiplier</haxe_doc>
		</GetGravity>
		<GetEFlags public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a bit flag of all engine flags of the entity. 
		
		
		**Returns:** Engine flags, see EFL_ Enums</haxe_doc>
		</GetEFlags>
		<SetNetworkedString public="1" set="method">
			<f a="key:?value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: SetNWString instead.
		
		Sets a networked string value at specified index on the entity. 
		
		The value then can be accessed with Entity:GetNetworkedString both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set</haxe_doc>
		</SetNetworkedString>
		<SequenceDuration public="1" set="method">
			<f a="?seqid">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns length of currently played sequence. 
		
		
		Name | Description
		--- | ---
		`seqid` | A sequence ID to return the length specific sequence of instead of the entity's main/currently playing sequence.
		
		
		**Returns:** The length of the sequence
		
		___
		### Lua Examples
		#### Example 1
		Example usage for the argument. Retrieve length of animation on specific gesture slot.
		
		```lua 
		local ply = Entity( 1 )
		local seq = ply:SelectWeightedSequence( ACT_GMOD_TAUNT_CHEER )
		local len = ply:SequenceDuration( seq )
		print( ply, seq, len )
		```
		**Output:**
		
		Player [1][Rubat] 303 2.7499999180436</haxe_doc>
		</SequenceDuration>
		<GetSequenceActivityName public="1" set="method">
			<f a="sequenceId">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the activity name for the given sequence id. 
		
		
		Name | Description
		--- | ---
		`sequenceId` | The sequence id.
		
		
		**Returns:** The ACT_ Enums as a string, returns "Not Found!" with an invalid sequence and "No model!" when no model is set.</haxe_doc>
		</GetSequenceActivityName>
		<SetDTAngle public="1" set="method">
			<f a="key:ang">
				<x path="Float"/>
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Sets the specified angle on the entity's datatable. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 31.
		`ang` | The angle to write on the entity's datatable.</haxe_doc>
		</SetDTAngle>
		<GetDTVector public="1" set="method">
			<f a="key">
				<x path="Float"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Get a vector stored in the datatable of the entity. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 63. Specifies what key to grab from datatable.
		
		
		**Returns:** Requested vector.</haxe_doc>
		</GetDTVector>
		<GetHitBoxBone public="1" set="method">
			<f a="hitbox:group">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Gets the bone the hit box is attached to. 
		
		
		Name | Description
		--- | ---
		`hitbox` | The number of the hit box.
		`group` | The number of the hit box group. This should be 0 in most cases. Numbering for these groups start from 0. The total group count can be found with Entity: GetHitBoxGroupCount.
		
		
		**Returns:** The number of the bone. Will be nil if the hit box index was out of range.
		
		___
		### Lua Examples
		#### Example 1
		
		
		```lua 
		local ply = LocalPlayer()
		local numHitBoxGroups = ply:GetHitBoxGroupCount()
		
		for group=0, numHitBoxGroups - 1 do
		  local numHitBoxes = ply:GetHitBoxCount( group )
		    
		  for hitbox=0, numHitBoxes - 1 do
		    local bone = ply:GetHitBoxBone(hitbox, group)
		
		    print( "Hit box group " .. group .. ", hitbox " .. hitbox .. " is attached to bone " .. ply:GetBoneName(bone) )
		  end
		end
		```
		**Output:**
		
		Hit box group 0, hit box 0 is attached to bone ValveBiped.Bip01_Head1, etc.</haxe_doc>
		</GetHitBoxBone>
		<GetRenderMode public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the render mode of the entity. 
		
		
		**Returns:** The render Mode. See RENDERMODE_ Enums</haxe_doc>
		</GetRenderMode>
		<SendViewModelMatchingSequence public="1" set="method">
			<f a="seq">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sends sequence animation to the view model. It is recommended to use this for view model animations, instead of Entity:ResetSequence. 
		
		This function is only usable on view models. 
		
		 
		Name | Description
		--- | ---
		`seq` | The sequence ID returned by Entity: LookupSequence or Entity: SelectWeightedSequence.
		
		
		___
		### Lua Examples
		#### Example 1
		Converting an ACT_VM_* enumeration to a sequence usable by the function.
		
		```lua 
		local VModel = self.Owner:GetViewModel( )
		local EnumToSeq = VModel:SelectWeightedSequence( ACT_VM_PRIMARYATTACK )
		
		VModel:SendViewModelMatchingSequence( EnumToSeq )
		```
		**Output:**
		
		Sends the primary attack enumeration sequence to the view model and plays it.</haxe_doc>
		</SendViewModelMatchingSequence>
		<AlignAngles public="1" set="method">
			<f a="from:to">
				<c path="gmod.gclass.Angle"/>
				<c path="gmod.gclass.Angle"/>
				<c path="gmod.gclass.Angle"/>
			</f>
			<haxe_doc>Returns an angle based on the ones inputted that you can use to align an object. 
		
		
		Name | Description
		--- | ---
		`from` | The angle you want to align from
		`to` | The angle you want to align to
		
		
		**Returns:** The resulting aligned angle
		
		___
		### Lua Examples
		#### Example 1
		This example will make ent1 face up from ent2.
		
		```lua 
		ent1:SetAngles(ent1:AlignAngles(ent1:GetForward():Angle(), ent2:GetUp():Angle()))
		```
		**Output:**
		
		Sets ent1's angle to one where ent1 faces up from ent2.</haxe_doc>
		</AlignAngles>
		<GetNetworkedString public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: GetNWString instead.
		
		Retrieves a networked string value at specified index on the entity that is set by Entity:SetNetworkedString. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. ( If it isn't set )
		
		
		**Returns:** The retrieved value</haxe_doc>
		</GetNetworkedString>
		<RemoveFlags public="1" set="method">
			<f a="flag">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes specified flag(s) from the entity 
		
		
		Name | Description
		--- | ---
		`flag` | The flag(s) to remove, see FL_ Enums</haxe_doc>
		</RemoveFlags>
		<SetPos public="1" set="method">
			<f a="position">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Moves the entity to the specified position. 
		
		
		Name | Description
		--- | ---
		`position` | The position to move the entity to.
		
		
		___
		### Lua Examples
		#### Example 1
		Sets the player's position to (0, 0, 0)
		
		```lua 
		Entity( 1 ):SetPos( Vector( 0, 0, 0 ) )
		```
		**Output:**
		
		The player is now located at Vector(0, 0, 0)</haxe_doc>
		</SetPos>
		<Spawn public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Initializes the entity and starts its networking. If called on a player, it will respawn them. 
		
		This calls ENTITY:Initialize on Lua-defined entities.</haxe_doc>
		</Spawn>
		<SetHealth public="1" set="method">
			<f a="newHealth">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the health of the entity. 
		
		
		Name | Description
		--- | ---
		`newHealth` | New health value.
		
		
		___
		### Lua Examples
		#### Example 1
		Sets the entity's health to their maximum health.
		
		```lua 
		Entity( 1 ):SetHealth( Entity( 1 ):GetMaxHealth() )
		```
		**Output:**
		
		The entity's health is now full.
		
		#### Example 2
		Deducts 50 points of health from the entity.
		
		```lua 
		Entity( 1 ):SetHealth( Entity( 1 ):Health() - 50 )
		```
		**Output:**
		
		The entity now has 50 less health.</haxe_doc>
		</SetHealth>
		<GetBodygroupCount public="1" set="method">
			<f a="bodygroup">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the count of possible values for this bodygroup. 
		
		This is not the maximum value, since the bodygroups start with 0, not 1. 
		
		 
		Name | Description
		--- | ---
		`bodygroup` | The ID of bodygroup to retrieve count of.
		
		
		**Returns:** Count of values of passed bodygroup.</haxe_doc>
		</GetBodygroupCount>
		<SetHitboxSet public="1" set="method">
			<f a="id">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the current Hitbox set for the entity. 
		
		
		Name | Description
		--- | ---
		`id` | The new hitbox set to set. Can be a name as a string, or the ID as a number. If the operation failed, the function will silently fail.</haxe_doc>
		</SetHitboxSet>
		<SetNWVarProxy public="1" set="method">
			<f a="key:callback">
				<x path="Any"/>
				<x path="haxe.Function"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a function to be called when the NWVar changes. 
		
		
		Name | Description
		--- | ---
		`key` | The key of the NWVar to add callback for.
		`callback` | The function to be called when the NWVar changes. It has 4 arguments: Entity ent - The entity string name - Name of the NWVar that has changed any oldval - The old value any newval - The new value
		
		
		___
		### Lua Examples
		#### Example 1
		Prints all changes to a NWVar called "Key" of Player 1.
		
		```lua 
		Entity( 1 ):SetNWVarProxy( "Key", print )
		Entity( 1 ):SetNWString( "Key", "Value" )
		Entity( 1 ):SetNWString( "Key", "Table" )
		```</haxe_doc>
		</SetNWVarProxy>
		<GetNWEntity public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<haxe_doc>Retrieves a networked entity value at specified index on the entity that is set by Entity:SetNWEntity. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. (If it isn't set)
		
		
		**Returns:** The value associated with the key</haxe_doc>
		</GetNWEntity>
		<SetNWFloat public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a networked float (number) value on the entity. 
		
		The value can then be accessed with Entity:GetNWFloat both from client and server. 
		
		 Unlike Entity:SetNWInt, floats don't have to be whole numbers. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set
		
		
		___
		### Lua Examples
		#### Example 1
		This will set the networked float 'test' on all clients to 0.5.
		
		```lua 
		for k,v in pairs( player.GetAll() ) do
		    v:SetNWFloat( 'test', 0.5 )
		end
		```</haxe_doc>
		</SetNWFloat>
		<SetSpawnEffect public="1" set="method">
			<f a="spawnEffect">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets whether the entity should use a spawn effect when it is created on the client. 
		
		See Entity:GetSpawnEffect for more information on how the effect is applied. 
		
		 
		Name | Description
		--- | ---
		`spawnEffect` | Sets if we should show a spawn effect.
		
		
		___
		### Lua Examples
		#### Example 1
		Simplified code taken from sandbox's commands.lua
		
		```lua 
		local function MakeRagdoll( Player, Pos, Ang, Model, PhysicsObjects, Data )
		
		    local Ent = ents.Create( "prop_ragdoll" )
		    duplicator.DoGeneric( Ent, Data )
		    Ent:Spawn()
		    
		    duplicator.DoGenericPhysics( Ent, Player, Data )
		    Ent:Activate()
		
		    Ent:SetSpawnEffect( true )
		    return Ent    
		end
		```
		**Output:**
		
		Spawns the ragdoll and then sets the spawnEffect flag to true.</haxe_doc>
		</SetSpawnEffect>
		<GetSequenceGroundSpeed public="1" set="method">
			<f a="sequenceId">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the ground speed of the entity's sequence. 
		
		
		Name | Description
		--- | ---
		`sequenceId` | The sequence ID.
		
		
		**Returns:** The ground speed of this sequence.
		
		___
		### Lua Examples
		#### Example 1
		Move the NextBot based on the ground speed of its walking animation (within its coroutine).NOTE In most cases it's better to use NextBot:BodyMoveXY instead.
		
		```lua 
		local sequence = self:LookupSequence( "walk_all" )
		
		if ( sequence ) then
		    self:StartActivity( ACT_WALK )
		    self:SetSequence( sequence )
		    self.loco:SetDesiredSpeed( self:GetSequenceGroundSpeed( sequence ) )
		end
		```</haxe_doc>
		</GetSequenceGroundSpeed>
		<LookupAttachment public="1" set="method">
			<f a="attachmentName">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the attachment index of the given attachment name. 
		
		
		Name | Description
		--- | ---
		`attachmentName` | The name of the attachment.
		
		
		**Returns:** The attachment index, or 0 if the attachment does not exist and -1 if the model is invalid.</haxe_doc>
		</LookupAttachment>
		<NextThink public="1" set="method">
			<f a="timestamp">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>In the case of a scripted entity, this will cause the next ENTITY:Think event to be run at the given time. 
		
		Does not work clientside! Use Entity:SetNextClientThink instead. 
		
		 
		Name | Description
		--- | ---
		`timestamp` | The relative to CurTime timestamp, at which the next think should occur.
		
		
		___
		### Lua Examples
		#### Example 1
		Prints 'Hello, World!' in console and sleeps for a second.
		
		```lua 
		function ENT:Think()
		    print("Hello, World!")
		
		    self:NextThink( CurTime() + 1 )
		    return true -- Note: You need to return true to override the default next think time
		end
		```
		**Output:**
		
		Hello, World! every second the entity exists in the world.</haxe_doc>
		</NextThink>
		<GetBodygroupName public="1" set="method">
			<f a="id">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>Gets the name of specific bodygroup for given entity. 
		
		
		Name | Description
		--- | ---
		`id` | The id of bodygroup to get the name of.
		
		
		**Returns:** The name of the bodygroup
		
		___
		### Lua Examples
		#### Example 1
		Demonstrates the use of this function.
		
		```lua 
		print( player.GetByID(1):GetEyeTrace().Entity:GetBodygroupName(1) )
		```
		**Output:**
		
		"Weapon" in console, if player 1 is aiming at airboat.</haxe_doc>
		</GetBodygroupName>
		<NetworkVar public="1" set="method">
			<f a="type:slot:name:?extended">
				<c path="String"/>
				<x path="Float"/>
				<c path="String"/>
				<t path="lua.AnyTable"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a network variable on the entity and adds Set/Get functions for it. This function should only be called in ENTITY:SetupDataTables. 
		
		
		Name | Description
		--- | ---
		`type` | Supported choices: "String" "Bool" "Float" "Int" (32-bit signed integer) "Vector" "Angle" "Entity"
		`slot` | Each network var has to have a unique slot. The slot is per type - so you can have an int in slot 0, a bool in slot 0 and a float in slot 0 etc. but you can't have two ints in slot 0 instead you would do a int in slot 0 and another int in slot 1. The max slots right now are 32 - so you should pick a number between 0 and 31. An exception to this is strings which has a max slots of 4.
		`name` | The name will affect how you access it. If you call it "Foo" you would add two new functions on your entity - SetFoo and GetFoo. So be careful that what you call it won't collide with any existing functions (don't call it "Pos" for example).
		`extended` | A table of extended information. KeyName If the table contains a "KeyName" key the value can be set using Entity:SetKeyValue. This is useful if you're making an entity that you want to be loaded in a map. The sky entity uses this. Edit The edit key lets you mark this variable as editable. See Editable Entities for more information.
		
		
		___
		### Lua Examples
		#### Example 1
		Setting up data tables
		
		```lua 
		function ENT:SetupDataTables()
		
		    self:NetworkVar( "Float", 0, "Amount" )
		    self:NetworkVar( "Vector", 0, "StartPos" )
		    self:NetworkVar( "Vector", 1, "EndPos" )
		
		end
		
		-- Code...
		
		-- Setting values on the entity
		self:SetStartPos( Vector( 1, 0, 0 ) )
		self:SetAmount( 100 )
		
		-- Code...
		
		-- Getting values
		local startpos = self:GetStartPos()
		```</haxe_doc>
		</NetworkVar>
		<GetBrushPlane public="1" set="method">
			<f a="id">
				<x path="Float"/>
				<c path="gmod.gclass.EntityGetBrushPlaneReturn"/>
			</f>
			<haxe_doc>Returns info about given plane of non-nodraw brush model surfaces of the entity's model. Works on worldspawn as well. 
		
		
		Name | Description
		--- | ---
		`id` | The index of the plane to get info of. Starts from 0.
		
		
		Name | Description
		--- | ---
		`a` | The origin of the plane. This will be either the first vertex's position (if available) or the plane's normal multiplied by the plane's distance.
		`b` | The normal of the plane.
		`c` | The "distance" of the plane. The distance is the dot product of the plane's normal and the point it was initialized with.</haxe_doc>
		</GetBrushPlane>
		<SetDTBool public="1" set="method">
			<f a="key:bool">
				<x path="Float"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***INTERNAL:**  
		
		This is called internally by the Entity:NetworkVar system, you can use this in cases where using NetworkVar is not possible. 
		
		Sets the specified bool on the entity's datatable. 
		
		 
		Name | Description
		--- | ---
		`key` | Goes from 0 to 31.
		`bool` | The boolean to write on the entity's metatable.</haxe_doc>
		</SetDTBool>
		<GetAbsVelocity public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the entity's velocity. 
		
		
		**Returns:** The velocity of the entity.</haxe_doc>
		</GetAbsVelocity>
		<RemoveEFlags public="1" set="method">
			<f a="flag">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes specified engine flag 
		
		
		Name | Description
		--- | ---
		`flag` | The flag to remove, see EFL_ Enums</haxe_doc>
		</RemoveEFlags>
		<GetEffects public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a bit flag of all engine effect flags of the entity. 
		
		
		**Returns:** Engine effect flags, see EF_ Enums</haxe_doc>
		</GetEffects>
		<WorldSpaceAABB public="1" set="method">
			<f a=""><c path="gmod.gclass.EntityWorldSpaceAABBReturn"/></f>
			<haxe_doc>Returns two vectors representing the minimum and maximum extent of the entity's bounding box. 
		
		
		Name | Description
		--- | ---
		`a` | The minimum vector for the entity's bounding box.
		`b` | The maximum vector for the entity's bounding box.
		
		
		___
		### Lua Examples
		#### Example 1
		Prints Entity(1)'s maximum bounding box vector.
		
		```lua 
		local min,max = Entity(1):WorldSpaceAABB()
		print(max)
		```
		**Output:**
		
		-496.828125 11730.426758 5189.393066</haxe_doc>
		</WorldSpaceAABB>
		<GetNWAngle public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<haxe_doc>Retrieves a networked angle value at specified index on the entity that is set by Entity:SetNWAngle. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. (If it isn't set)
		
		
		**Returns:** The value associated with the key</haxe_doc>
		</GetNWAngle>
		<GetPoseParameterRange public="1" set="method">
			<f a="id">
				<x path="Float"/>
				<c path="gmod.gclass.EntityGetPoseParameterRangeReturn"/>
			</f>
			<haxe_doc>Returns pose parameter range 
		
		
		Name | Description
		--- | ---
		`id` | Pose parameter ID to look up
		
		
		Name | Description
		--- | ---
		`a` | The minimum value
		`b` | The maximum value</haxe_doc>
		</GetPoseParameterRange>
		<SetNetworkedNumber public="1" set="method">
			<f a="index:number">
				<x path="Any"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a networked number at the specified index on the entity. 
		
		
		Name | Description
		--- | ---
		`index` | The index that the value is stored in.
		`number` | The value to network.
		
		
		___
		### Lua Examples
		#### Example 1
		This will set the networked number 'score' on all clients to 3.
		
		```lua 
		for k, v in pairs( player.GetAll() ) do
		    v:SetNetworkedInt( 'score', 3 )
		end
		```</haxe_doc>
		</SetNetworkedNumber>
		<GetGroundEntity public="1" set="method">
			<f a=""><c path="gmod.gclass.Entity"/></f>
			<haxe_doc>Returns the object the entity is standing on. 
		
		
		**Returns:** The ground entity.</haxe_doc>
		</GetGroundEntity>
		<SetWeaponModel public="1" set="method">
			<f a="viewModel:?weapon">
				<c path="String"/>
				<c path="gmod.gclass.Weapon"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the model and associated weapon to this viewmodel entity. 
		
		This is used internally when the player switches weapon. 
		
		 
		Name | Description
		--- | ---
		`viewModel` | The model string to give to this viewmodel. Example: "models/weapons/c_smg1.mdl"
		`weapon` | The weapon entity to associate this viewmodel to.
		
		
		___
		### Lua Examples
		#### Example 1
		Sets the model of the second viewmodel to the smg and associates it with the player's current weapon.
		
		```lua 
		Entity( 1 ):GetViewModel( 1 ):SetWeaponModel( "models/weapons/c_smg1.mdl", Entity( 1 ):GetActiveWeapon() )
		```
		
		#### Example 2
		Initializes the extra viewmodel in Deploy and hides it again on Holster, also plays the attack animation on left and right click.
		
		```lua 
		SWEP.ViewModel = "models/weapons/v_pistol.mdl"
		SWEP.UseHands = false
		SWEP.ViewModelFlip = false    --the default viewmodel won't be flipped
		SWEP.ViewModelFlip1 = true    --the second viewmodel will
		
		
		function SWEP:Deploy()
		    --get the second viewmodel
		    local viewmodel1 = self.Owner:GetViewModel( 1 )
		    if ( IsValid( viewmodel1 ) ) then
		        --associate its weapon to us
		        viewmodel1:SetWeaponModel( self.ViewModel , self )
		    end
		    
		    self:SendViewModelAnim( ACT_VM_DEPLOY , 1 )
		    
		    return true
		end
		
		function SWEP:Holster()
		    local viewmodel1 = self.Owner:GetViewModel( 1 )
		    if ( IsValid( viewmodel1 ) ) then
		        --set its weapon to nil, this way the viewmodel won't show up again
		        viewmodel1:SetWeaponModel( self.ViewModel , nil )
		    end
		    
		    return true
		end
		
		--since self:SendWeaponAnim always sends the animation to the first viewmodel, we need this as a replacement
		function SWEP:SendViewModelAnim( act , index , rate )
		    
		    if ( not game.SinglePlayer() and not IsFirstTimePredicted() ) then
		        return
		    end
		    
		    local vm = self.Owner:GetViewModel( index )
		    
		    if ( not IsValid( vm ) ) then
		        return
		    end
		    
		    local seq = vm:SelectWeightedSequence( act )
		    
		    if ( seq == -1 ) then
		        return
		    end
		    
		    vm:SendViewModelMatchingSequence( seq )
		    vm:SetPlaybackRate( rate or 1 )
		end
		
		function SWEP:PrimaryAttack()
		    
		    self:SendViewModelAnim( ACT_VM_PRIMARYATTACK , 0 )--target the first viewmodel
		    self:SetNextPrimaryFire( CurTime() + 0.25 )
		    
		end
		
		function SWEP:SecondaryAttack()
		    
		    self:SendViewModelAnim( ACT_VM_PRIMARYATTACK , 1 )--target the second
		    self:SetNextSecondaryFire( CurTime() + 0.25 )
		    
		end
		```</haxe_doc>
		</SetWeaponModel>
		<GetColor public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns the color the entity is set to. 
		
		
		**Returns:** The color of the entity as a Color structure.
		
		___
		### Lua Examples
		#### Example 1
		
		
		```lua 
		for key, ply in pairs( player.GetAll( ) ) do -- Loop through all players on the server
		 local col = ply:GetColor( ); -- Gets the players color and assigns it to local variable col
		 
		 print( "Printing " .. ply:Nick() .. "'s color!" ); -- Say we are printing the players name's color
		 PrintTable( col ); -- Pass col into PrintTable to print to contents of col
		end
		```
		**Output:**
		
		Loop through all players, and print their color.</haxe_doc>
		</GetColor>
		<GetHitBoxGroupCount public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the number of hit box groups that an entity has. 
		
		
		**Returns:** number of hit box groups
		
		___
		### Lua Examples
		#### Example 1
		Prints how many hit box groups the client has
		
		```lua 
		local numHitBoxGroups = LocalPlayer():GetHitBoxGroupCount()
		print(numHitBoxGroups)
		```</haxe_doc>
		</GetHitBoxGroupCount>
		<ResetSequenceInfo public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Reset entity sequence info such as playback rate, ground speed, last event check, etc.</haxe_doc>
		</ResetSequenceInfo>
		<SetShouldServerRagdoll public="1" set="method">
			<f a="serverragdoll">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets if entity should create a server ragdoll on death or a client one. 
		
		
		Name | Description
		--- | ---
		`serverragdoll` | Set true if ragdoll should be created on server, false if on client</haxe_doc>
		</SetShouldServerRagdoll>
		<SetRenderFX public="1" set="method">
			<f a="renderFX">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets entity's render FX. 
		
		
		Name | Description
		--- | ---
		`renderFX` | The new render FX to set, see kRenderFx_ Enums</haxe_doc>
		</SetRenderFX>
		<GetNWVarTable public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns all the networked variables in an entity. 
		
		
		**Returns:** Key-Value table of all networked variables.
		
		___
		### Lua Examples
		#### Example 1
		Prints all NWVars that exist for Player 1.
		
		```lua 
		PrintTable( Entity(1):GetNWVarTable() )
		```
		**Output:**
		
		UserGroup	=	owner</haxe_doc>
		</GetNWVarTable>
		<GetCollisionBounds public="1" set="method">
			<f a=""><c path="gmod.gclass.EntityGetCollisionBoundsReturn"/></f>
			<haxe_doc>Returns an entity's collision bounding box. In most cases, this will return the same bounding box as Entity:GetModelBounds unless the entity does not have a physics mesh or it has a PhysObj different from the default. 
		
		
		Name | Description
		--- | ---
		`a` | The minimum vector of the collision bounds
		`b` | The maximum vector of the collision bounds</haxe_doc>
		</GetCollisionBounds>
		<CollisionRulesChanged public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Declares that the collision rules of the entity have changed, and subsequent calls for GM:ShouldCollide with this entity may return a different value than they did previously.</haxe_doc>
		</CollisionRulesChanged>
		<GetFlags public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns all flags of given entity. 
		
		
		**Returns:** Flags of given entity as a bitflag, see FL_ Enums</haxe_doc>
		</GetFlags>
		<BoneLength public="1" set="method">
			<f a="boneID">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>This function takes the boneID and returns the length of it in an unrounded decimal 
		
		
		Name | Description
		--- | ---
		`boneID` | The ID of the bone you want the length of. You may want to get the length of the next bone ( boneID + 1 ) for decent results
		
		
		**Returns:** The length of the bone
		
		___
		### Lua Examples
		#### Example 1
		Returns first bones length of first player on the server
		
		```lua 
		print( player.GetByID( 1 ):BoneLength( 1 ) )
		```
		**Output:**
		
		Returns 0</haxe_doc>
		</BoneLength>
		<SetGroundEntity public="1" set="method">
			<f a="ground">
				<c path="gmod.gclass.Entity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the ground the entity is standing on. 
		
		
		Name | Description
		--- | ---
		`ground` | The ground entity.
		
		
		___
		### Lua Examples
		#### Example 1
		Gives all players the ability to (sort of) walk on water.
		
		```lua 
		-- shared.lua tick
		function GM:Tick()
		    
		    local trace = {}
		    local world = Entity( 0 )
		    
		    for p, ply in pairs( player.GetAll() ) do
		    
		        trace = util.TraceLine( {
		            start = ply:GetPos() + Vector( 0, 0, 72),
		            endpos = ply:GetPos() + Vector( 0, 0, -3 ),
		            mask = MASK_WATER,
		            filter = function( ent ) return true end
		        } )
		        
		        if( trace.Hit ) then
		            ply:SetGravity( 0.0001 )
		            ply:SetGroundEntity( world )
		        else
		            ply:SetGravity( 1.0 )
		        end
		        
		    end
		    
		end
		```</haxe_doc>
		</SetGroundEntity>
		<SetModelScale public="1" set="method">
			<f a="scale:?deltaTime">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Scales the model of the entity, if the entity is a Player or an NPC the hitboxes will be scaled as well. 
		
		For some entities, calling Entity:Activate after this will scale the collision bounds and PhysObj as well; be wary as there's no optimization being done internally and highly complex collision models might crash the server. 
		
		 This is the same system used in TF2 for the Mann Vs Machine robots. 
		
		 To resize the entity along any axis, use Entity:EnableMatrix instead. 
		
		 If your old scales are wrong due to a recent update, use Entity:SetLegacyTransform as a quick fix. 
		
		 
		Name | Description
		--- | ---
		`scale` | A float to scale the model by. 0 will not draw anything. < 0 will draw the model inverted.
		`deltaTime` | Transition time of the scale change, set to 0 to modify the scale right away.
		
		
		___
		### Lua Examples
		#### Example 1
		From the "Biggify" option of right clicking an npc
		
		```lua 
		ent:SetModelScale( ent:GetModelScale() * 1.25, 1 )
		```]]></haxe_doc>
		</SetModelScale>
		<TranslatePhysBoneToBone public="1" set="method">
			<f a="physNum">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the boneID of the bone the given PhysObj is attached to. 
		
		See Entity:TranslateBoneToPhysBone for reverse function. 
		
		 
		Name | Description
		--- | ---
		`physNum` | The PhysObj number on the entity
		
		
		**Returns:** The boneID of the bone the PhysObj is attached to.
		
		___
		### Lua Examples
		#### Example 1
		Does a trace, gets the physics bone from the trace, converts the physics bone number into the bone number and prints the result
		
		```lua 
		local tr = LocalPlayer():GetEyeTrace()
		local bone = tr.Entity:TranslatePhysBoneToBone( tr.PhysicsBone )
		print( bone )
		```
		**Output:**
		
		The bone number of what the client is looking at</haxe_doc>
		</TranslatePhysBoneToBone>
		<SetNetworkedBool public="1" set="method">
			<f a="key:?value">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: SetNWBool instead.
		
		Sets a networked boolean value at specified index on the entity. 
		
		The value then can be accessed with Entity:GetNetworkedBool both from client and server. 
		
		 
		Name | Description
		--- | ---
		`key` | The key to associate the value with
		`value` | The value to set</haxe_doc>
		</SetNetworkedBool>
		<SetLocalPos public="1" set="method">
			<f a="pos">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets local position relative to the parented position. This is for use with Entity:SetParent to offset position. 
		
		
		Name | Description
		--- | ---
		`pos` | The local position</haxe_doc>
		</SetLocalPos>
		<RemoveAllDecals public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Removes all decals from the entities surface. 
		
		
		___
		### Lua Examples
		#### Example 1
		Removes all decals from all props in world.
		
		```lua 
		for k, v in pairs( ents.FindByClass( "prop_physics" )) do
		    v:RemoveAllDecals()
		end
		```</haxe_doc>
		</RemoveAllDecals>
		<GetSpawnFlags public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc><![CDATA[Returns the bitwise spawn flags used by the entity. 
		
		
		**Returns:** The spawn flags of the entity, see SF_Enums.
		
		___
		### Lua Examples
		#### Example 1
		An alternative to Entity:HasSpawnFlags
		
		```lua 
		local sf = ent:GetSpawnFlags()
		
		if( bit.band( sf, SF_PHYSPROP_PREVENT_PICKUP ) > 0 ) then
		    print( "This prop cannot be picked up." )
		end
		```]]></haxe_doc>
		</GetSpawnFlags>
		<GetHitboxSetCount public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the amount of hitbox sets in the entity. 
		
		
		**Returns:** The amount of hitbox sets in the entity.</haxe_doc>
		</GetHitboxSetCount>
		<SetFlexScale public="1" set="method">
			<f a="scale">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the flex scale of the entity. 
		
		
		Name | Description
		--- | ---
		`scale` | The new flex scale to set to</haxe_doc>
		</SetFlexScale>
		<SetBodygroup public="1" set="method">
			<f a="bodygroup:value">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets an entities' bodygroup. 
		
		
		Name | Description
		--- | ---
		`bodygroup` | The id of the bodygroup you're setting. Starts from 0.
		`value` | The value you're setting the bodygroup to. Starts from 0.</haxe_doc>
		</SetBodygroup>
		<SetModelName public="1" set="method">
			<f a="modelname">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Alter the model name returned by Entity:GetModel. Does not affect the entity's actual model. 
		
		
		Name | Description
		--- | ---
		`modelname` | The new model name.</haxe_doc>
		</SetModelName>
		<GetCreationTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the time the entity was created on, relative to CurTime. 
		
		
		**Returns:** The time the entity was created on.</haxe_doc>
		</GetCreationTime>
		<SelectWeightedSequence public="1" set="method">
			<f a="act">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns sequence ID corresponding to given activity ID. 
		
		Opposite of Entity:GetSequenceActivity. 
		
		 Similar to Entity:LookupSequence. 
		
		 See also Entity:SelectWeightedSequenceSeeded. 
		
		 
		Name | Description
		--- | ---
		`act` | The activity ID, see ACT_ Enums.
		
		
		**Returns:** The sequence ID
		
		___
		### Lua Examples
		#### Example 1
		Use this hook to check if the model has a certain ACT_* enumeration, and if it does, play it.
		
		```lua 
		local VModel = self.Owner:GetViewModel()
		
		if ( self:Clip1() == 0 and VModel:SelectWeightedSequence( ACT_VM_RELOAD_EMPTY ) ) then
		
		    local SEQ = self:LookupSequence( ACT_VM_RELOAD_EMPTY )
		
		    if ( SEQ == -1 ) then
		
		        print( "reload" )
		
		        local EnumToSeq = VModel:SelectWeightedSequence( ACT_VM_RELOAD )
		
		        --    Play the normal reload animation
		        VModel:SendViewModelMatchingSequence( EnumToSeq )
		
		    else
		
		        print( "reload empty" )
		
		        local EnumToSeq = VModel:SelectWeightedSequence( ACT_VM_RELOAD_EMPTY )
		
		        -- Play the empty reload animation
		        VModel:SendViewModelMatchingSequence( EnumToSeq )
		        
		    end
		
		end
		```
		**Output:**
		
		Will play the ACT_VM_RELOAD_EMPTY enumeration if the model has it. If not, it will play the normal reload enum.</haxe_doc>
		</SelectWeightedSequence>
		<GetModelRenderBounds public="1" set="method">
			<f a=""><c path="gmod.gclass.EntityGetModelRenderBoundsReturn"/></f>
			<haxe_doc>Returns the entity's model render bounds. By default this will return the same bounds as Entity:GetModelBounds. 
		
		
		Name | Description
		--- | ---
		`a` | The minimum vector of the bounds
		`b` | The maximum vector of the bounds</haxe_doc>
		</GetModelRenderBounds>
		<AddSolidFlags public="1" set="method">
			<f a="flags">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds solid flag(s) to the entity. 
		
		
		Name | Description
		--- | ---
		`flags` | The flag(s) to apply, see FSOLID_ Enums.</haxe_doc>
		</AddSolidFlags>
		<GetNWVector public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<x path="Any"/>
				<x path="Any"/>
			</f>
			<haxe_doc>Retrieves a networked vector value at specified index on the entity that is set by Entity:SetNWVector. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. (If it isn't set)
		
		
		**Returns:** The value associated with the key</haxe_doc>
		</GetNWVector>
		<GibBreakServer public="1" set="method">
			<f a="force">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Causes the entity to break into its current models gibs, if it has any. 
		
		You must call Entity:PrecacheGibs on the entity before using this function, or it will not create any gibs. 
		
		 The gibs will be spawned on the server and be synchronized with all clients. 
		
		 Note, that this function will not remove or hide the entity it is called on. 
		
		 
		Name | Description
		--- | ---
		`force` | The force to apply to the created gibs</haxe_doc>
		</GibBreakServer>
		<AddCallback public="1" set="method">
			<f a="hook:func">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Add a callback function to a specific event. This is used instead of hooks to avoid calling empty functions unnecessarily. 
		
		This also allows you to use certain hooks in engine entities (non-scripted entities). 
		
		 
		Name | Description
		--- | ---
		`hook` | The hook name to hook onto. See Entity Callbacks
		`func` | The function to call
		
		
		**Returns:** The callback ID that was just added, which can later be used in Entity:RemoveCallback. Returns nothing if the passed callback function was invalid or when asking for a non-existent hook.
		
		___
		### Lua Examples
		#### Example 1
		Adds a callback to an entity which is called every time the entity angles change.
		
		```lua 
		myentity:AddCallback( "OnAngleChange", function( entity, newangle )
		    -- Do stuff
		end )
		```
		
		#### Example 2
		Creates watermelon prop which creates sparks on collision point whenever touches something.
		
		```lua 
		local melon = ents.Create( "prop_physics" ) -- Spawn prop
		if (!IsValid( melon ) ) then return end -- Safety first
		melon:SetModel( "models/props_junk/watermelon01.mdl" ) -- Set watermelon model
		melon:SetPos( Entity(1):GetEyeTrace().HitPos ) -- Set pos where is player looking
		melon:Spawn() -- Instantiate prop
		
		local function PhysCallback( ent, data ) -- Function that will be called whenever collision happends
		    local effect = EffectData() -- Create effect data
		    effect:SetOrigin( data.HitPos ) -- Set origin where collision point is
		    util.Effect( "cball_bounce", effect ) -- Spawn small sparky effect
		end
		melon:AddCallback( "PhysicsCollide", PhysCallback ) -- Add Callback
		```</haxe_doc>
		</AddCallback>
		<FrameAdvance public="1" set="method">
			<f a="interval">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Advances the cycle of an animated entity. 
		
		Animations that loop will automatically reset the cycle so you don't have to - ones that do not will stop animating once you reach the end of their sequence. 
		
		 
		Name | Description
		--- | ---
		`interval` | How many seconds to advance the cycle. Set to 0 to let the engine calculate this for you based on CurTime.
		
		
		___
		### Lua Examples
		#### Example 1
		From DModelPanel
		
		```lua 
		function PANEL:RunAnimation()
		    self.Entity:FrameAdvance( (RealTime()-self.LastPaint) * self.m_fAnimSpeed )    
		end
		```
		**Output:**
		
		Animates the entity</haxe_doc>
		</FrameAdvance>
		<GetSubMaterial public="1" set="method">
			<f a="index">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the material override for the given index. 
		
		Returns "" if no material override exists. Use Entity:GetMaterials to list it's default materials. 
		
		 
		Name | Description
		--- | ---
		`index` | The index of the sub material. Acceptable values are from 0 to 31.
		
		
		**Returns:** The material that overrides this index, if any.</haxe_doc>
		</GetSubMaterial>
		<GetClass public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the classname of a entity. This is often the name of the Lua file or folder containing the files for the entity 
		
		
		**Returns:** The entity's classname
		
		___
		### Lua Examples
		#### Example 1
		Prints the classname of the weapon that the player is holding.
		
		```lua 
		print( LocalPlayer( ):GetActiveWeapon( ):GetClass( ) )
		```
		**Output:**
		
		Prints the classname of the weapon that the player is holding. (ie weapon_crowbar)</haxe_doc>
		</GetClass>
		<GetSolid public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns solid type of an entity. 
		
		
		**Returns:** The solid type. See the SOLID_ Enums.</haxe_doc>
		</GetSolid>
		<AddEFlags public="1" set="method">
			<f a="flag">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds engine flags. 
		
		
		Name | Description
		--- | ---
		`flag` | Engine flag to add, see EFL_ Enums</haxe_doc>
		</AddEFlags>
		<IsValid public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc><![CDATA[Returns whether the entity is a valid entity or not. 
		
		An entity is valid if: 
		
		 
		**Returns:** true if the entity is valid, false otherwise
		
		___
		### Lua Examples
		#### Example 1
		Shows how to use the global IsValid function instead of using this method directly.
		
		```lua 
		if ( entity && entity:IsValid() ) then
		    -- Do stuff
		end
		
		-- The above can be replaced with the following for the same effect (and cleaner code)
		
		if ( IsValid( entity ) ) then
		    -- Do stuff
		end
		```
		
		#### Example 2
		
		
		```lua 
		print( LocalPlayer():IsValid() )
		```
		**Output:**
		
		Outputs 'true' to the console if the player is in-game.
		
		#### Example 3
		
		
		```lua 
		local newPlayer = net.ReadEntity() --server found a new player on the server and sent it to us after 
		print( "1/4" )              -- it determined it was valid (newPlayer is NULL in this realm)
		
		if not isnumber(newPlayer.ImportantGameData) then --If it doesn't have a specific field, assign a value to it
		    print( "2/4" )
		    newPlayer.ImportantGameData = 42 
		end
		print( "3/4" )
		
		print( newPlayer.ImportantGameData * 69 ) --Attempting to do arithmetics on the new field
		print( "4/4" )
		```
		**Output:**
		
		1/4 ... 3/4 A lua error telling us 'ImportantGameData' is a nil value and thus can't perform math on it But this shouldn't be possible, because we just created a value there. No red flags are present up until this point; all code up until this will run fine. Make sure to add an IsValid() check when the seemingly impossible happens.]]></haxe_doc>
		</IsValid>
		<GetNetworkedVector public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: GetNWVector instead.
		
		Retrieves a networked vector value at specified index on the entity that is set by Entity:SetNetworkedVector. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. ( If it isn't set )
		
		
		**Returns:** The retrieved value</haxe_doc>
		</GetNetworkedVector>
		<PhysicsInitConvex public="1" set="method">
			<f a="points">
				<t path="lua.AnyTable"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Initializes the physics mesh of the entity with a convex mesh defined by a table of points. The resulting mesh is the convex hull of all the input points. If successful, the previous physics object will be removed. 
		
		This is the standard way of creating moving physics objects with a custom convex shape. For more complex, concave shapes, see Entity:PhysicsInitMultiConvex. 
		
		 
		Name | Description
		--- | ---
		`points` | A table of eight Vectors, in local coordinates, to be used in the computation of the convex mesh. Order does not matter.
		
		
		**Returns:** Returns true on success, nil otherwise.
		
		___
		### Lua Examples
		#### Example 1
		Creates a "box" physics mesh for the entity.
		
		```lua 
		function ENT:Initialize()
		    if ( CLIENT ) then return end -- We only want to run this code serverside
		
		    local x0 = -20 -- Define the min corner of the box
		    local y0 = -10
		    local z0 = -5
		
		    local x1 = 20 -- Define the max corner of the box
		    local y1 = 10
		    local z1 = 5
		
		    self:PhysicsInitConvex( {
		        Vector( x0, y0, z0 ),
		        Vector( x0, y0, z1 ),
		        Vector( x0, y1, z0 ),
		        Vector( x0, y1, z1 ),
		        Vector( x1, y0, z0 ),
		        Vector( x1, y0, z1 ),
		        Vector( x1, y1, z0 ),
		        Vector( x1, y1, z1 )
		    } )
		
		    -- Set up solidity and movetype
		    self:SetMoveType( MOVETYPE_VPHYSICS )
		    self:SetSolid( SOLID_VPHYSICS )
		
		    -- Enable custom collisions on the entity
		    self:EnableCustomCollisions( true )
		end
		```</haxe_doc>
		</PhysicsInitConvex>
		<GetHitBoxCount public="1" set="method">
			<f a="group">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Gets how many hit boxes are in a given hit box group 
		
		
		Name | Description
		--- | ---
		`group` | The number of the hit box group
		
		
		**Returns:** The number of hit boxes.
		
		___
		### Lua Examples
		#### Example 1
		Will print out how many hit boxes the client has in each of their hit box groups
		
		```lua 
		local numHitBoxGroups = LocalPlayer():GetHitBoxGroupCount()
		
		for i=0, numHitBoxGroups - 1 do
		  local numHitBoxes = LocalPlayer():GetHitBoxCount( i )
		  print("Hit box group " .. i .. " has " .. numHitBoxes .. " hit boxes!")
		end
		```
		**Output:**
		
		"Hit box group 0 has 17 hit boxes!"</haxe_doc>
		</GetHitBoxCount>
		<GetPhysicsObject public="1" set="method">
			<f a=""><c path="gmod.gclass.PhysObj"/></f>
			<haxe_doc>Returns the entity's physics object, if the entity has physics. 
		
		
		**Returns:** The entity's physics object.
		
		___
		### Lua Examples
		#### Example 1
		Gets the mass of an entity.
		
		```lua 
		local phys = ent:GetPhysicsObject()
		if ( IsValid( phys ) ) then -- Always check with IsValid! The ent might not have physics!
		    return phys:GetMass()
		else
		    return 0
		end
		```</haxe_doc>
		</GetPhysicsObject>
		<GetUp public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the upward vector of the entity, as a normalized direction vector 
		
		
		**Returns:** upDir</haxe_doc>
		</GetUp>
		<GetNetworkedBool public="1" set="method">
			<f a="key:?fallback">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   You should use Entity: GetNWBool instead.
		
		Retrieves a networked boolean value at specified index on the entity that is set by Entity:SetNetworkedBool. 
		
		
		Name | Description
		--- | ---
		`key` | The key that is associated with the value
		`fallback` | The value to return if we failed to retrieve the value. ( If it isn't set )
		
		
		**Returns:** The retrieved value</haxe_doc>
		</GetNetworkedBool>
		<SetColor public="1" set="method">
			<f a="?color">
				<t path="lua.AnyTable"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the color of an entity. 
		
		
		Name | Description
		--- | ---
		`color` | The color to set. Uses the Color structure.
		
		
		___
		### Lua Examples
		#### Example 1
		Loop through all players, make them black
		
		```lua 
		local colBlack = Color( 0, 0, 0, 255 ) -- Creates a black color
		for key, ply in pairs(player.GetAll()) do -- Loop through all players on the server
		    ply:SetColor(colBlack) -- Sets the players color to colBlack
		end
		```
		
		#### Example 2
		Creates a wooden crate at 0,0,0 and turns it a transparent green
		
		```lua 
		local ent = ents.Create("prop_physics")
		ent:SetPos(Vector(0,0,0))
		ent:SetModel("models/props_junk/wood_crate001a.mdl")
		ent:Spawn()
		
		ent:SetColor( Color( 0, 255, 0, 230 ) ) 
		ent:SetRenderMode( RENDERMODE_TRANSALPHA ) -- You need to set the render mode on some entities in order for the color to change
		```</haxe_doc>
		</SetColor>
		<Health public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc><![CDATA[Returns the health of the entity. 
		
		
		**Returns:** health
		
		___
		### Lua Examples
		#### Example 1
		Prints if the entity's health is at full or more.
		
		```lua 
		print( Entity( 1 ):Health() >= Entity( 1 ):GetMaxHealth() )
		```
		**Output:**
		
		"true" entity's health is greater than or equal to their max health, or "false" otherwise.]]></haxe_doc>
		</Health>
		<Weapon_TranslateActivity public="1" set="method">
			<f a="act">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Calls and returns WEAPON:TranslateActivity on the weapon the entity ( player or NPC ) carries. 
		
		Despite existing on client, it doesn't actually do anything on client. 
		
		 
		Name | Description
		--- | ---
		`act` | The activity to translate
		
		
		**Returns:** The translated activity</haxe_doc>
		</Weapon_TranslateActivity>
		<GetFlexName public="1" set="method">
			<f a="id">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns flex name. 
		
		
		Name | Description
		--- | ---
		`id` | The flex id to look up name of
		
		
		**Returns:** The flex name</haxe_doc>
		</GetFlexName>
		<GetPoseParameter public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the pose parameter value 
		
		
		Name | Description
		--- | ---
		`name` | Pose parameter name to look up
		
		
		**Returns:** Value of given pose parameter. WARNING This value will be from 0 - 1 on the client and from minimum range to maximum range on the server! You'll have to remap this value clientside to Entity:GetPoseParameterRange's returns if you want get the actual pose parameter value. See Entity:SetPoseParameter's example.</haxe_doc>
		</GetPoseParameter>
		<haxe_doc>This is a list of all available methods for entites, which includes Players, Weapons, NPCs and Vehicles.</haxe_doc>
	</class>
	<class path="gmod.gclass.EntityWorldSpaceAABBReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityLookupSequenceReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetSequenceMovementReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><x path="Bool"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<c public="1"><c path="gmod.gclass.Angle"/></c>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetRotatedAABBReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetRenderBoundsReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetPoseParameterRangeReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetModelRenderBoundsReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetModelBoundsReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetHitboxSetReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><c path="String"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetHitBoxBoundsReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetFlexBoundsReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetConstrainedPhysObjectsReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.PhysObj"/></a>
		<b public="1"><c path="gmod.gclass.PhysObj"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetConstrainedEntitiesReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.Entity"/></a>
		<b public="1"><c path="gmod.gclass.Entity"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetCollisionBoundsReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetBrushPlaneReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<c public="1"><x path="Float"/></c>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.EntityGetBonePositionReturn" params="" file="src/gmod/gclass/Entity.hx" module="gmod.gclass.Entity" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Angle"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.PhysObj" params="" file="src/gmod/gclass/PhysObj.hx" extern="1">
		<EnableMotion public="1" set="method">
			<f a="enable">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets whether the physobject should be able to move or not. 
		
		This is the exact method the Physics Gun uses to freeze props. If a motion-disabled physics object is grabbed with the physics gun, the object will be able to move again. To disallow this, use GM:PhysgunPickup. 
		
		 
		Name | Description
		--- | ---
		`enable` | True to enable, false to disable.</haxe_doc>
		</EnableMotion>
		<CalculateForceOffset public="1" set="method">
			<f a="force:pos">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.PhysObjCalculateForceOffsetReturn"/>
			</f>
			<haxe_doc>Calculates the force and torque on the center of mass for an offset force impulse. The outputs can be directly passed to PhysObj:ApplyForceCenter and PhysObj:ApplyTorqueCenter, respectively. 
		
		
		Name | Description
		--- | ---
		`force` | The initial force
		`pos` | The location of the force in world coordinates
		
		
		Name | Description
		--- | ---
		`a` | The calculated force on the physics object's center of mass
		`b` | The calculated torque on the physics object's center of mass</haxe_doc>
		</CalculateForceOffset>
		<GetDamping public="1" set="method">
			<f a=""><c path="gmod.gclass.PhysObjGetDampingReturn"/></f>
			<haxe_doc>Returns the linear and angular damping of the physics object. 
		
		
		Name | Description
		--- | ---
		`a` | The linear damping
		`b` | The angular damping</haxe_doc>
		</GetDamping>
		<GetVelocity public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the absolute directional velocity of the physobject. 
		
		
		**Returns:** velocity</haxe_doc>
		</GetVelocity>
		<GetAABB public="1" set="method">
			<f a=""><c path="gmod.gclass.PhysObjGetAABBReturn"/></f>
			<haxe_doc>Returns the mins and max of the physics object. 
		
		
		Name | Description
		--- | ---
		`a` | Mins
		`b` | Maxs</haxe_doc>
		</GetAABB>
		<GetPositionMatrix public="1" set="method">
			<f a=""><c path="gmod.gclass.VMatrix"/></f>
			<haxe_doc>Returns the position and angle of the physics object as a 3x4 matrix (VMatrix is 4x4 so the fourth row goes unused). The first three columns store the angle as a rotation matrix, and the fourth column stores the position vector. 
		
		
		**Returns:** The position and angle matrix.</haxe_doc>
		</GetPositionMatrix>
		<SetDamping public="1" set="method">
			<f a="linearDamping:angularDamping">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the linear and angular damping of the physics object. 
		
		
		Name | Description
		--- | ---
		`linearDamping` | Linear damping.
		`angularDamping` | Angular damping.</haxe_doc>
		</SetDamping>
		<RecheckCollisionFilter public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Call this when the collision filter conditions change due to this object's state (e.g. changing solid type or collision group)</haxe_doc>
		</RecheckCollisionFilter>
		<IsMotionEnabled public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns if the physics object can move itself (by velocity, acceleration) 
		
		
		**Returns:** motionEnabled</haxe_doc>
		</IsMotionEnabled>
		<SetVelocity public="1" set="method">
			<f a="velocity">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the velocity of the physics object for the next iteration. 
		
		
		Name | Description
		--- | ---
		`velocity` | The new velocity of the physics object.</haxe_doc>
		</SetVelocity>
		<WorldToLocalVector public="1" set="method">
			<f a="WorldVec">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Rotate a vector from the world frame to the local frame of the physics object. 
		
		
		Name | Description
		--- | ---
		`WorldVec` | A vector in the world frame
		
		
		**Returns:** The corresponding vector relative to the PhysObj</haxe_doc>
		</WorldToLocalVector>
		<GetEntity public="1" set="method">
			<f a=""><t path="gmod.types.Entity"/></f>
			<haxe_doc>Returns the parent entity of the physics object. 
		
		
		**Returns:** parent</haxe_doc>
		</GetEntity>
		<GetRotDamping public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the rotation damping of the physics object. 
		
		
		**Returns:** The rotation damping</haxe_doc>
		</GetRotDamping>
		<GetAngles public="1" set="method">
			<f a=""><c path="gmod.gclass.Angle"/></f>
			<haxe_doc>Returns the angles of the physics object. 
		
		
		**Returns:** The angles of the physics object.</haxe_doc>
		</GetAngles>
		<SetDragCoefficient public="1" set="method">
			<f a="drag">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Modifies how much drag (air resistance) affects the object. 
		
		
		Name | Description
		--- | ---
		`drag` | The drag coefficient It can be positive or negative.</haxe_doc>
		</SetDragCoefficient>
		<GetName public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the name of the physics object. 
		
		
		**Returns:** The name of the physics object.</haxe_doc>
		</GetName>
		<GetShadowPos public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the position of the PhysObj shadow. See PhysObj:UpdateShadow. 
		
		
		**Returns:** The position of the PhysObj shadow.</haxe_doc>
		</GetShadowPos>
		<EnableCollisions public="1" set="method">
			<f a="enable">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets whether the physics object should collide with anything or not, including world. 
		
		
		Name | Description
		--- | ---
		`enable` | True to enable, false to disable.</haxe_doc>
		</EnableCollisions>
		<EnableGravity public="1" set="method">
			<f a="enable">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets whether the PhysObject should be affected by gravity 
		
		
		Name | Description
		--- | ---
		`enable` | True to enable, false to disable.</haxe_doc>
		</EnableGravity>
		<SetMaterial public="1" set="method">
			<f a="materialName">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the material of the physobject. 
		
		
		Name | Description
		--- | ---
		`materialName` | The name of the phys material to use. From this list: Valve Developer
		
		
		___
		### Lua Examples
		#### Example 1
		Randomize the physical properties of an entity
		
		```lua 
		local tbl = {
		    "gmod_ice", -- Makes the entity slide around
		    "gmod_bouncy", -- Makes the entity bouncy
		    "gmod_silent", -- Makes the entity not play sounds on impact
		    "flesh" -- Makes the entity play flesh sounds on impact
		}
		
		local phys = SomeEntity:GetPhysicsObject()
		
		if ( IsValid( phys ) ) then
		
		    phys:SetMaterial( table.Random( tbl ) )
		
		end
		```</haxe_doc>
		</SetMaterial>
		<AddAngleVelocity public="1" set="method">
			<f a="angularVelocity">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the specified velocity to the current. 
		
		
		Name | Description
		--- | ---
		`angularVelocity` | Additional velocity.</haxe_doc>
		</AddAngleVelocity>
		<IsPenetrating public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whenever the physics object is penetrating another physics object. 
		
		This is internally implemented as 
		**Returns:** Whether the physics object is penetrating another object.</haxe_doc>
		</IsPenetrating>
		<IsMoveable public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whenever the entity is able to move. 
		
		
		**Returns:** movable</haxe_doc>
		</IsMoveable>
		<GetPos public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the position of the physics object. 
		
		
		**Returns:** The position</haxe_doc>
		</GetPos>
		<GetMaterial public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the physical material of the physics object. 
		
		
		**Returns:** The physical material</haxe_doc>
		</GetMaterial>
		<SetMass public="1" set="method">
			<f a="mass">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the mass of the physics object. 
		
		
		Name | Description
		--- | ---
		`mass` | The mass in kilograms.</haxe_doc>
		</SetMass>
		<ComputeShadowControl public="1" set="method">
			<f a="shadowparams">
				<t path="lua.AnyTable"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Allows you to move a PhysObj to a point and angle in 3D space. 
		
		
		Name | Description
		--- | ---
		`shadowparams` | The parameters for the shadow. See example code to see how its used.
		
		
		___
		### Lua Examples
		#### Example 1
		Move a PhysObj to vector 0 0 0 with angles 0 0 0.
		
		```lua 
		function ENT:Initialize()
		 
		    self:StartMotionController()
		    self.ShadowParams = {}
		 
		end
		function ENT:PhysicsSimulate( phys, deltatime )
		 
		    phys:Wake()
		 
		    self.ShadowParams.secondstoarrive = 1 // How long it takes to move to pos and rotate accordingly - only if it could move as fast as it want - damping and max speed/angular will make this invalid (Cannot be 0! Will give errors if you do)
		    self.ShadowParams.pos = Vector( 0, 0, 0 ) // Where you want to move to
		    self.ShadowParams.angle = Angle( 0, 0, 0 ) // Angle you want to move to
		    self.ShadowParams.maxangular = 5000 //What should be the maximal angular force applied
		    self.ShadowParams.maxangulardamp = 10000 // At which force/speed should it start damping the rotation
		    self.ShadowParams.maxspeed = 1000000 // Maximal linear force applied
		    self.ShadowParams.maxspeeddamp = 10000// Maximal linear force/speed before  damping
		    self.ShadowParams.dampfactor = 0.8 // The percentage it should damp the linear/angular force if it reaches it's max amount
		    self.ShadowParams.teleportdistance = 200 // If it's further away than this it'll teleport (Set to 0 to not teleport)
		    self.ShadowParams.deltatime = deltatime // The deltatime it should use - just use the PhysicsSimulate one
		 
		    phys:ComputeShadowControl(self.ShadowParams)
		 
		end
		```</haxe_doc>
		</ComputeShadowControl>
		<LocalToWorld public="1" set="method">
			<f a="LocalVec">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Mapping a vector in local frame of the physics object to world frame. 
		
		
		Name | Description
		--- | ---
		`LocalVec` | A vector in the physics object's local frame
		
		
		**Returns:** The corresponding vector in world frame</haxe_doc>
		</LocalToWorld>
		<ClearGameFlag public="1" set="method">
			<f a="flags">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Removes one of more specified flags. 
		
		
		Name | Description
		--- | ---
		`flags` | Bitflag, see FVPHYSICS_ Enums.</haxe_doc>
		</ClearGameFlag>
		<IsAsleep public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the physics object is "sleeping". 
		
		See PhysObj:Sleep for more information. 
		
		 
		**Returns:** Whether the physics object is sleeping.</haxe_doc>
		</IsAsleep>
		<ApplyForceOffset public="1" set="method">
			<f a="force:position">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Applies the specified force on the physics object at the specified position 
		
		
		Name | Description
		--- | ---
		`force` | The force to be applied.
		`position` | The position in world coordinates where the force is applied to the physics object.
		
		
		___
		### Lua Examples
		#### Example 1
		Pull what the player is looking at towards him.
		
		```lua 
		local tr = Entity(1):GetEyeTrace()
		if IsValid(tr.Entity) then
		    local phys = tr.Entity:GetPhysicsObjectNum(tr.PhysicsBone)
		    
		    local pushvec = tr.Normal * -100000
		    local pushpos = tr.HitPos
		    
		    phys:ApplyForceOffset(pushvec, pushpos)
		end
		```</haxe_doc>
		</ApplyForceOffset>
		<GetSurfaceArea public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the surface area of the physics object in source-units. 
		
		
		**Returns:** The surface area</haxe_doc>
		</GetSurfaceArea>
		<GetInvMass public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns 1 divided by the physics object's mass. 
		
		
		**Returns:** The inverted mass.</haxe_doc>
		</GetInvMass>
		<WorldToLocal public="1" set="method">
			<f a="vec">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Converts a vector to a relative to the physics object coordinate system. 
		
		
		Name | Description
		--- | ---
		`vec` | The vector in world space coordinates.
		
		
		**Returns:** The vector local to PhysObj: GetPos.</haxe_doc>
		</WorldToLocal>
		<GetInvInertia public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns 1 divided by the inertia. 
		
		
		**Returns:** The inverted inertia</haxe_doc>
		</GetInvInertia>
		<SetAngleDragCoefficient public="1" set="method">
			<f a="coefficient">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the amount of drag to apply to a physics object when attempting to rotate. 
		
		
		Name | Description
		--- | ---
		`coefficient` | Drag coefficient. The bigger this value is, the slower the angles will change.</haxe_doc>
		</SetAngleDragCoefficient>
		<GetMassCenter public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the center of mass of the physics object as a local vector. 
		
		
		**Returns:** The center of mass of the physics object.</haxe_doc>
		</GetMassCenter>
		<ApplyTorqueCenter public="1" set="method">
			<f a="torque">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Applies specified torque to the physics object. 
		
		
		Name | Description
		--- | ---
		`torque` | The torque to be applied in kg * degrees / s.</haxe_doc>
		</ApplyTorqueCenter>
		<ApplyForceCenter public="1" set="method">
			<f a="force">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Applies the specified force to the physics object. (in Newtons) 
		
		
		Name | Description
		--- | ---
		`force` | The force to be applied.
		
		
		___
		### Lua Examples
		#### Example 1
		An entity that Simulates it's own gravity by applying a force downward on the entity based on the force equation.(Force = mass * acceleration)Since, by default, entities already have gravity. The default gravity must be turned off by adding "phys:EnableGravity(false)" in the entities Initialize function so that the default gravity doesn't interfere with our custom gravity.NOTE: We can get the mass of the entity by using the GetMass() function.NOTE -9.80665 (meters / second^2)  Is the approximate acceleration of objects on Earth due to gravity. (It is negative because gravity pushes things downwards.)
		
		```lua 
		function ENT:Initialize()
		    self:SetModel("models/hunter/blocks/cube1x1x1.mdl")
		    self:PhysicsInit(SOLID_VPHYSICS)
		    self:SetSolid(SOLID_VPHYSICS)
		    self:SetMoveType(MOVETYPE_VPHYSICS)
		
		    if phys:IsValid() then
		        phys:EnableGravity(false) -- This is required. Since we are creating our own gravity.
		        phys:Wake()
		    end
		end
		
		function ENT:PhysicsUpdate(phys)
		    local phys = self:GetPhysicsObject()
		    phys:ApplyForceCenter(Vector(0,0,phys:GetMass()*-9.80665))
		end
		```</haxe_doc>
		</ApplyForceCenter>
		<CalculateVelocityOffset public="1" set="method">
			<f a="force:pos">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.PhysObjCalculateVelocityOffsetReturn"/>
			</f>
			<haxe_doc>Calculates the linear and angular velocities on the center of mass for an offset force impulse. The outputs can be directly passed to PhysObj:AddVelocity and PhysObj:AddAngleVelocity, respectively. 
		
		
		Name | Description
		--- | ---
		`force` | The initial force
		`pos` | The location of the force in world coordinates
		
		
		Name | Description
		--- | ---
		`a` | The calculated linear velocity from the force on the physics object's center of mass
		`b` | The calculated angular velocity from the force on the physics object's center of mass</haxe_doc>
		</CalculateVelocityOffset>
		<GetSpeedDamping public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the speed damping of the physics object. 
		
		
		**Returns:** speedDamping</haxe_doc>
		</GetSpeedDamping>
		<OutputDebugInfo public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Prints debug info about the state of the physics object to the console. 
		
		
		___
		### Lua Examples
		#### Example 1
		Outputs physics info about the entity the player is looking at to the console.
		
		```lua 
		Entity(1):GetEyeTrace().Entity:GetPhysicsObject():OutputDebugInfo()
		```
		**Output:**
		
		----------------- Object: models/props_borealis/bluebarrel001.mdl Mass: 60.0 (inv 0.017) Inertia: 8.69, 8.69, 2.46 (inv 0.115, 0.115, 0.406) Velocity: 0.00, 0.00, -0.00 Ang Velocity: 0.00, 0.00, -0.00 Damping 0.00 linear, 0.00 angular Linear Drag: 0.02, 0.01, 0.01 (factor 1.00) Angular Drag: 0.01, 0.02, 0.01 (factor 1.00) attached to 5 controllers 4) sys:friction 3) sys:friction 2) sys:friction 1) vphysics:drag 0) sys:gravity State: Asleep, Collision Enabled, Motion Enabled, Flags 1127 (game 0000, index 0) Material: plastic_barrel : density(500.0), thickness(0.25), friction(0.80), elasticity(0.01) CollisionModel: Compact Surface: 1 convex pieces no outer hull</haxe_doc>
		</OutputDebugInfo>
		<HasGameFlag public="1" set="method">
			<f a="flags">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whenever the specified flag(s) is/are set. 
		
		
		Name | Description
		--- | ---
		`flags` | Bitflag, see FVPHYSICS_ Enums.
		
		
		**Returns:** If flag was set or not</haxe_doc>
		</HasGameFlag>
		<SetAngles public="1" set="method">
			<f a="angles">
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the angles of the physobject. 
		
		
		Name | Description
		--- | ---
		`angles` | The new angles of the physobject.</haxe_doc>
		</SetAngles>
		<LocalToWorldVector public="1" set="method">
			<f a="LocalVec">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Rotate a vector from the local frame of the physics object to world frame. 
		
		
		Name | Description
		--- | ---
		`LocalVec` | A vector in the physics object's local frame
		
		
		**Returns:** The corresponding vector in world frame
		
		___
		### Lua Examples
		#### Example 1
		Given the angle of the physics object is angle ( 0.045, 89.952, 89.99 ) ( This can be derived by PhysObj:GetAngles() ), convert the vector ( 1 ,2, 3 ) in this physics object's local frame into world frame.
		
		```lua 
		print( "Angle of the PhysObj: ", PhysObj:GetAngles() )
		print( "Vector in world frame: ", PhysObj:LocalToWorld( Vector( 1, 2, 3 ) ) )
		```
		**Output:**
		
		Angle of the PhysObj: 0.045 89.952 89.993; Vector in world frame: 3.000585 0.999039 1.999603;</haxe_doc>
		</LocalToWorldVector>
		<IsCollisionEnabled public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whenever the entity is able to collide or not. 
		
		
		**Returns:** isCollisionEnabled</haxe_doc>
		</IsCollisionEnabled>
		<GetAngleVelocity public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Gets the angular velocity of the object in degrees per second. 
		
		
		**Returns:** The angular velocity</haxe_doc>
		</GetAngleVelocity>
		<IsDragEnabled public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whenever the entity is affected by drag. 
		
		
		**Returns:** dragEnabled</haxe_doc>
		</IsDragEnabled>
		<AddVelocity public="1" set="method">
			<f a="velocity">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the specified velocity to the current. 
		
		
		Name | Description
		--- | ---
		`velocity` | Additional velocity.</haxe_doc>
		</AddVelocity>
		<RotateAroundAxis public="1" set="method">
			<f a="dir:ang">
				<c path="gmod.gclass.Vector"/>
				<x path="Float"/>
				<c path="gmod.gclass.Angle"/>
			</f>
			<haxe_doc>A convinience function for Angle:RotateAroundAxis. 
		
		
		Name | Description
		--- | ---
		`dir` | Direction, around which we will rotate
		`ang` | Amount of rotation, in degrees
		
		
		**Returns:** The resulting angle
		
		___
		### Lua Examples
		#### Example 1
		Shows that it is the same as Angle:RotateAroundAxis.
		
		```lua 
		local phys = Entity(1):GetEyeTrace().Entity:GetPhysicsObject() -- Our physics object
		
		print( phys:RotateAroundAxis( Vector( 1, 0, 0 ), 20 ) )
		
		local a = phys:GetAngles()
		a:RotateAroundAxis( Vector( 1, 0, 0 ), 20 )
		print( a )
		```
		**Output:**
		
		Two exactly the same angles -27.179 133.246 -23.236
		-27.179 133.246 -23.236</haxe_doc>
		</RotateAroundAxis>
		<GetMass public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the mass of the physics object. 
		
		
		**Returns:** The mass in kilograms.</haxe_doc>
		</GetMass>
		<Wake public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Wakes the physics object. 
		
		See PhysObj:Sleep for more information.</haxe_doc>
		</Wake>
		<Sleep public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Makes the physics object "sleep". 
		
		The physics object will no longer be moving unless it is "woken up" by either a collision with another moving object, or by PhysObj:Wake. This is an optimization feature of the physics engine.</haxe_doc>
		</Sleep>
		<AddGameFlag public="1" set="method">
			<f a="flags">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds one or more bit flags. 
		
		
		Name | Description
		--- | ---
		`flags` | Bitflag, see FVPHYSICS_ Enums.</haxe_doc>
		</AddGameFlag>
		<SetBuoyancyRatio public="1" set="method">
			<f a="buoyancy">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the buoyancy ratio of the physics object. (How well it floats in water) 
		
		
		Name | Description
		--- | ---
		`buoyancy` | Buoyancy ratio, where 0 is not buoyant at all (like a rock), and 1 is very buoyant (like wood)</haxe_doc>
		</SetBuoyancyRatio>
		<AlignAngles public="1" set="method">
			<f a="from:to">
				<c path="gmod.gclass.Angle"/>
				<c path="gmod.gclass.Angle"/>
				<c path="gmod.gclass.Angle"/>
			</f>
			<haxe_doc>Rotates the object so that it's angles are aligned to the ones inputted.       
		Name | Description
		--- | ---
		`from` | 
		`to` | 
		
		
		**Returns:**</haxe_doc>
		</AlignAngles>
		<UpdateShadow public="1" set="method">
			<f a="targetPosition:targetAngles:frameTime">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Angle"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Unlike PhysObj:SetPos and PhysObj:SetAngles, this allows the movement of a physobj while leaving physics interactions intact. This is used internally by the motion controller of the Gravity Gun , the +use pickup and the Physics Gun, and entities such as the crane. 
		
		
		Name | Description
		--- | ---
		`targetPosition` | The position we should move to.
		`targetAngles` | The angle we should rotate towards.
		`frameTime` | The frame time to use for this movement, can be generally filled with FrameTime or ENTITY:PhysicsSimulate with the deltaTime. Can be set to 0 when you need to update the physics object just once.</haxe_doc>
		</UpdateShadow>
		<SetPos public="1" set="method">
			<f a="position:?teleport">
				<c path="gmod.gclass.Vector"/>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the position of the physobject. 
		
		
		Name | Description
		--- | ---
		`position` | The new position of the physobject.
		`teleport` |</haxe_doc>
		</SetPos>
		<GetVelocityAtPoint public="1" set="method">
			<f a="point">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Returns the world velocity of a point in world coordinates about the object. 
		
		
		Name | Description
		--- | ---
		`point` | 
		
		
		**Returns:**</haxe_doc>
		</GetVelocityAtPoint>
		<GetShadowAngles public="1" set="method">
			<f a=""><c path="gmod.gclass.Angle"/></f>
			<haxe_doc>Returns the angles of the PhysObj shadow. See PhysObj:UpdateShadow. 
		
		
		**Returns:** The angles of the PhysObj shadow.</haxe_doc>
		</GetShadowAngles>
		<GetMeshConvexes public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns all convex physics meshes of the object. See Entity.PhysicsInitMultiConvex for more information. 
		
		
		**Returns:** Table of MeshVertex structures where each MeshVertex structure is an independent convex mesh and each three vertices represent a triangle. Returns nil if the physics object is a sphere.</haxe_doc>
		</GetMeshConvexes>
		<SetVelocityInstantaneous public="1" set="method">
			<f a="velocity">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the velocity of the physics object. 
		
		
		Name | Description
		--- | ---
		`velocity` | The new velocity of the physics object.</haxe_doc>
		</SetVelocityInstantaneous>
		<EnableDrag public="1" set="method">
			<f a="enable">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets whenever the physics object should be affected by drag. 
		
		
		Name | Description
		--- | ---
		`enable` | True to enable, false to disable.</haxe_doc>
		</EnableDrag>
		<GetInertia public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the directional inertia of the physics object. 
		
		
		**Returns:** directionalInertia</haxe_doc>
		</GetInertia>
		<GetVolume public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the volume in source units. 
		
		
		**Returns:** volume</haxe_doc>
		</GetVolume>
		<IsGravityEnabled public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whenever the entity is affected by gravity. 
		
		
		**Returns:** gravitated</haxe_doc>
		</IsGravityEnabled>
		<SetContents public="1" set="method">
			<f a="contents">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the contents flag of the PhysObj. 
		
		
		Name | Description
		--- | ---
		`contents` | The CONTENTS_ Enums.</haxe_doc>
		</SetContents>
		<IsValid public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns if the physics object is valid/not NULL. 
		
		
		**Returns:** isValid</haxe_doc>
		</IsValid>
		<SetInertia public="1" set="method">
			<f a="directionalInertia">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the directional inertia. 
		
		
		Name | Description
		--- | ---
		`directionalInertia` | The directional inertia of the object. A value of Vector(0,0,0) makes the physobject go invalid.</haxe_doc>
		</SetInertia>
		<GetEnergy public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the kinetic energy of the physobject. 
		
		
		**Returns:** The kinetic energy</haxe_doc>
		</GetEnergy>
		<GetMesh public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns the physics mesh of the object which is used for physobj-on-physobj collision. 
		
		
		**Returns:** Table of MeshVertex structures where each three vertices represent a triangle. Returns nil if the physics object is a sphere.</haxe_doc>
		</GetMesh>
		<GetContents public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the contents flag of the PhysObj. 
		
		
		**Returns:** The CONTENTS_ Enums.</haxe_doc>
		</GetContents>
		<haxe_doc>This is the object returned by Entity:GetPhysicsObject and Entity:GetPhysicsObjectNum. 
	
	It represents a physics object.</haxe_doc>
	</class>
	<class path="gmod.gclass.PhysObjGetDampingReturn" params="" file="src/gmod/gclass/PhysObj.hx" module="gmod.gclass.PhysObj" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.PhysObjGetAABBReturn" params="" file="src/gmod/gclass/PhysObj.hx" module="gmod.gclass.PhysObj" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.PhysObjCalculateVelocityOffsetReturn" params="" file="src/gmod/gclass/PhysObj.hx" module="gmod.gclass.PhysObj" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.PhysObjCalculateForceOffsetReturn" params="" file="src/gmod/gclass/PhysObj.hx" module="gmod.gclass.PhysObj" extern="1">
		<a public="1"><c path="gmod.gclass.Vector"/></a>
		<b public="1"><c path="gmod.gclass.Vector"/></b>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.VMatrix" params="" file="src/gmod/gclass/VMatrix.hx" extern="1">
		<InvertTR public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Inverts the matrix. This function will not fail, but only works correctly on matrices that contain only translation and/or rotation. 
		
		Using this function on a matrix with modified scale may return an incorrect inverted matrix. 
		
		 To invert a matrix that contains other modifications, see VMatrix:Invert.</haxe_doc>
		</InvertTR>
		<Translate public="1" set="method">
			<f a="translation">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Translates the matrix by the given vector aka. adds the vector to the translation. 
		
		Postmultiplies the matrix by a translation matrix (A = AT). 
		
		 
		Name | Description
		--- | ---
		`translation` | Vector to translate the matrix by.</haxe_doc>
		</Translate>
		<GetAngles public="1" set="method">
			<f a=""><c path="gmod.gclass.Angle"/></f>
			<haxe_doc>Returns the absolute rotation of the matrix. 
		
		
		**Returns:** Absolute rotation of the matrix</haxe_doc>
		</GetAngles>
		<GetScale public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the absolute scale of the matrix. 
		
		
		**Returns:** Absolute scale of the matrix</haxe_doc>
		</GetScale>
		<GetRight public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Gets the right direction of the matrix. 
		
		ie. The second column of the matrix, negated, excluding the w coordinate. 
		
		 
		**Returns:** The right direction of the matrix.</haxe_doc>
		</GetRight>
		<GetInverse public="1" set="method">
			<f a=""><c path="gmod.gclass.VMatrix"/></f>
			<haxe_doc>Returns an inverted matrix without modifying the original matrix. 
		
		Inverting the matrix will fail if its determinant is 0 or close to 0. (ie. its "scale" in any direction is 0.) 
		
		 See also VMatrix:GetInverseTR. 
		
		 
		**Returns:** The inverted matrix if possible, nil otherwise</haxe_doc>
		</GetInverse>
		<GetField public="1" set="method">
			<f a="row:column">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specific field in the matrix. 
		
		
		Name | Description
		--- | ---
		`row` | Row of the field whose value is to be retrieved, from 1 to 4
		`column` | Column of the field whose value is to be retrieved, from 1 to 4
		
		
		**Returns:** The value of the specified field</haxe_doc>
		</GetField>
		<SetUnpacked public="1" set="method">
			<f a="e11:e12:e13:e14:e21:e22:e23:e24:e31:e32:e33:e34:e41:e42:e43:e44">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets each component of the matrix. 
		
		
		Name | Description
		--- | ---
		`e11` | 
		`e12` | 
		`e13` | 
		`e14` | 
		`e21` | 
		`e22` | 
		`e23` | 
		`e24` | 
		`e31` | 
		`e32` | 
		`e33` | 
		`e34` | 
		`e41` | 
		`e42` | 
		`e43` | 
		`e44` |</haxe_doc>
		</SetUnpacked>
		<Set public="1" set="method">
			<f a="src">
				<c path="gmod.gclass.VMatrix"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies values from the given matrix object. 
		
		
		Name | Description
		--- | ---
		`src` | The matrix to copy values from.</haxe_doc>
		</Set>
		<IsZero public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Checks whenever all fields of the matrix are 0, aka if this is a null matrix. 
		
		
		**Returns:** If the matrix is a null matrix.</haxe_doc>
		</IsZero>
		<SetTranslation public="1" set="method">
			<f a="translation">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the absolute translation of the matrix. 
		
		
		Name | Description
		--- | ---
		`translation` | New translation.</haxe_doc>
		</SetTranslation>
		<ScaleTranslation public="1" set="method">
			<f a="scale">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scales the absolute translation with the given value. 
		
		
		Name | Description
		--- | ---
		`scale` | Value to scale the translation with.</haxe_doc>
		</ScaleTranslation>
		<Identity public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Initializes the matrix as Identity matrix.</haxe_doc>
		</Identity>
		<SetUp public="1" set="method">
			<f a="forward">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the up direction of the matrix. 
		
		ie. The third column of the matrix, excluding the w coordinate. 
		
		 
		Name | Description
		--- | ---
		`forward` | The up direction of the matrix.</haxe_doc>
		</SetUp>
		<GetForward public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Gets the forward direction of the matrix. 
		
		ie. The first column of the matrix, excluding the w coordinate. 
		
		 
		**Returns:** The forward direction of the matrix.</haxe_doc>
		</GetForward>
		<IsRotationMatrix public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the matrix is a rotation matrix or not. 
		
		Technically it checks if the forward, right and up vectors are orthogonal and normalized. 
		
		 
		**Returns:** Is the matrix a rotation matrix or not</haxe_doc>
		</IsRotationMatrix>
		<SetForward public="1" set="method">
			<f a="forward">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the forward direction of the matrix. 
		
		ie. The first column of the matrix, excluding the w coordinate. 
		
		 
		Name | Description
		--- | ---
		`forward` | The forward direction of the matrix.</haxe_doc>
		</SetForward>
		<SetField public="1" set="method">
			<f a="row:column:value">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets a specific field in the matrix. 
		
		
		Name | Description
		--- | ---
		`row` | Row of the field to be set, from 1 to 4
		`column` | Column of the field to be set, from 1 to 4
		`value` | The value to set in that field</haxe_doc>
		</SetField>
		<Rotate public="1" set="method">
			<f a="rotation">
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Rotates the matrix by the given angle. 
		
		Postmultiplies the matrix by a rotation matrix (A = AR). 
		
		 
		Name | Description
		--- | ---
		`rotation` | Rotation.</haxe_doc>
		</Rotate>
		<GetTranslation public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns the absolute translation of the matrix. 
		
		
		**Returns:** Absolute translation of the matrix</haxe_doc>
		</GetTranslation>
		<SetAngles public="1" set="method">
			<f a="angle">
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the absolute rotation of the matrix. 
		
		
		Name | Description
		--- | ---
		`angle` | New angles.</haxe_doc>
		</SetAngles>
		<SetRight public="1" set="method">
			<f a="forward">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the right direction of the matrix. 
		
		ie. The second column of the matrix, negated, excluding the w coordinate. 
		
		 
		Name | Description
		--- | ---
		`forward` | The right direction of the matrix.</haxe_doc>
		</SetRight>
		<Scale public="1" set="method">
			<f a="scale">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scales the matrix by the given vector. 
		
		Postmultiplies the matrix by a scaling matrix (A = AS). 
		
		 
		Name | Description
		--- | ---
		`scale` | Vector to scale with matrix with.</haxe_doc>
		</Scale>
		<Zero public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Sets all components of the matrix to 0, also known as a null matrix. 
		
		This function is more efficient than setting each element manually.</haxe_doc>
		</Zero>
		<ToTable public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Converts the matrix to a 4x4 table. See Matrix function. 
		
		
		**Returns:** The 4x4 table.</haxe_doc>
		</ToTable>
		<SetScale public="1" set="method">
			<f a="scale">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Modifies the scale of the matrix while preserving the rotation and translation. 
		
		
		Name | Description
		--- | ---
		`scale` | The scale to set.</haxe_doc>
		</SetScale>
		<Unpack public="1" set="method">
			<f a=""><c path="gmod.gclass.VMatrixUnpackReturn"/></f>
			<haxe_doc>Returns each component of the matrix, expanding rows before columns. 
		
		
		Name | Description
		--- | ---
		`a` | VMatrix: GetField(1, 1)
		`b` | VMatrix: GetField(1, 2)
		`c` | VMatrix: GetField(1, 3)
		`d` | VMatrix: GetField(1, 4)
		`e` | VMatrix: GetField(2, 1)
		`f` | VMatrix: GetField(2, 2)
		`g` | VMatrix: GetField(2, 3)
		`h` | VMatrix: GetField(2, 4)
		`i` | VMatrix: GetField(3, 1)
		`j` | VMatrix: GetField(3, 2)
		`k` | VMatrix: GetField(3, 3)
		`l` | VMatrix: GetField(3, 4)
		`m` | VMatrix: GetField(4, 1)
		`n` | VMatrix: GetField(4, 2)
		`o` | VMatrix: GetField(4, 3)
		`p` | VMatrix: GetField(4, 4)</haxe_doc>
		</Unpack>
		<IsIdentity public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the matrix is equal to Identity matrix or not. 
		
		
		**Returns:** Is the matrix an Identity matrix or not</haxe_doc>
		</IsIdentity>
		<GetInverseTR public="1" set="method">
			<f a=""><c path="gmod.gclass.VMatrix"/></f>
			<haxe_doc>Returns an inverted matrix without modifying the original matrix. This function will not fail, but only works correctly on matrices that contain only translation and/or rotation. 
		
		Using this function on a matrix with modified scale may return an incorrect inverted matrix. 
		
		 To get the inverse of a matrix that contains other modifications, see VMatrix:GetInverse. 
		
		 
		**Returns:** The inverted matrix.</haxe_doc>
		</GetInverseTR>
		<Invert public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Inverts the matrix. 
		
		Inverting the matrix will fail if its determinant is 0 or close to 0. (ie. its "scale" in any direction is 0.) 
		
		 If the matrix cannot be inverted, it does not get modified. 
		
		 See also VMatrix:InvertTR. 
		
		 
		**Returns:** Whether the matrix was inverted or not</haxe_doc>
		</Invert>
		<GetUp public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Gets the up direction of the matrix. 
		
		ie. The third column of the matrix, excluding the w coordinate. 
		
		 
		**Returns:** The up direction of the matrix.</haxe_doc>
		</GetUp>
		<haxe_doc>List of all possible functions to manipulate matrices. This object can be created by Matrix</haxe_doc>
	</class>
	<class path="gmod.gclass.VMatrixUnpackReturn" params="" file="src/gmod/gclass/VMatrix.hx" module="gmod.gclass.VMatrix" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<d public="1"><x path="Float"/></d>
		<e public="1"><x path="Float"/></e>
		<f public="1"><x path="Float"/></f>
		<g public="1"><x path="Float"/></g>
		<h public="1"><x path="Float"/></h>
		<i public="1"><x path="Float"/></i>
		<j public="1"><x path="Float"/></j>
		<k public="1"><x path="Float"/></k>
		<l public="1"><x path="Float"/></l>
		<m public="1"><x path="Float"/></m>
		<n public="1"><x path="Float"/></n>
		<o public="1"><x path="Float"/></o>
		<p public="1"><x path="Float"/></p>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.Vector" params="" file="src/gmod/gclass/Vector.hx" extern="1">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<z public="1"><x path="Float"/></z>
		<Add public="1" set="method">
			<f a="vector">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the values of the argument vector to the orignal vector. This functions the same as vector1 + vector2 without creating a new vector object, skipping object construction and garbage collection. 
		
		
		Name | Description
		--- | ---
		`vector` | The vector to add.
		
		
		___
		### Lua Examples
		#### Example 1
		Adds the components of the vectors together.
		
		```lua 
		a = Vector(1, 1, 1)
		a:Add(Vector(1, 2, 3))
		print(a)
		```
		**Output:**
		
		2 3 4
		
		#### Example 2
		If you don't want to set your vector to the result, and just return a new vector as the result. You can use a '+' operator to add two vectors together. The original vector will remain unchanged.
		
		```lua 
		a = Vector(1, 1, 1)
		print(a + Vector(1, 2, 3))
		```
		**Output:**
		
		2 3 4</haxe_doc>
		</Add>
		<DistToSqr public="1" set="method">
			<f a="otherVec">
				<c path="gmod.gclass.Vector"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[Returns the squared distance of 2 vectors, this is faster than Vector:Distance as calculating the square root is an expensive process. 
		
		
		Name | Description
		--- | ---
		`otherVec` | The vector to calculate the distance to.
		
		
		**Returns:** Squared distance to the vector
		
		___
		### Lua Examples
		#### Example 1
		Checks if a player is within `dist` units of another player in the most efficient way possible.
		
		```lua 
		function PlayerWithinBounds(ply,otherPly, dist)
		    return ply:GetPos():DistToSqr(otherPly:GetPos()) < (dist*dist)
		    -- This is computationally faster than:
		    -- ply:GetPos():Distance(otherPly:GetPos()) < dist
		end
		print(PlayerWithinBounds(Entity(1),Entity(2),500))
		```
		**Output:**
		
		true]]></haxe_doc>
		</DistToSqr>
		<WithinAABox public="1" set="method">
			<f a="boxStart:boxEnd">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whenever the given vector is in a box created by the 2 other vectors. 
		
		
		Name | Description
		--- | ---
		`boxStart` | The first vector.
		`boxEnd` | The second vector.
		
		
		**Returns:** Is the vector in the box or not
		
		___
		### Lua Examples
		#### Example 1
		Checks if player is within a certain area on the map.
		
		```lua 
		-- Position to test, we get the position of first player on the server
		local testPos = Entity( 1 ):GetPos()
		
		-- Positions to test, in this case we test if the player is in spawn area of gm_construct
		local pos1 = Vector( 1119, 895, 63 )
		local pos2 = Vector( 656, -896, -144 )
		
		-- This will return true if the player is within the tested area
		print( testPos:WithinAABox( pos1, pos2 ) )
		```</haxe_doc>
		</WithinAABox>
		<Normalize public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Normalizes the given vector. This changes the vector you call it on, if you want to return a normalized copy without affecting the original, use Vector:GetNormalized. 
		
		
		___
		### Lua Examples
		#### Example 1
		Normalizes Vector(4, 3, 2).
		
		```lua 
		local test = Vector(4, 3, 2)
		test:Normalize()
		MsgN( test )
		```
		**Output:**
		
		0.7428 0.5571 0.3714.</haxe_doc>
		</Normalize>
		<SetUnpacked public="1" set="method">
			<f a="x:y:z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the x, y, and z of the vector. 
		
		
		Name | Description
		--- | ---
		`x` | The x component
		`y` | The y component
		`z` | The z component</haxe_doc>
		</SetUnpacked>
		<Set public="1" set="method">
			<f a="vector">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Copies the values from the second vector to the first vector. 
		
		
		Name | Description
		--- | ---
		`vector` | The vector to copy from.
		
		
		___
		### Lua Examples
		#### Example 1
		Sets vector B to vector A's value.
		
		```lua 
		a = Vector(1, 2, 3)
		b = Vector()
		b:Set(a)
		print(b)
		```
		**Output:**
		
		1, 2, 3.</haxe_doc>
		</Set>
		<GetNormalized public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<haxe_doc>Returns a normalized version of the vector. Normalized means vector with same direction but with length of 1. 
		
		This does not affect the vector you call it on; to do this, use Vector:Normalize. 
		
		 
		**Returns:** Normalized version of the vector.</haxe_doc>
		</GetNormalized>
		<IsZero public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Checks whenever all fields of the vector are 0. 
		
		
		**Returns:** Do all fields of the vector equal 0 or not
		
		___
		### Lua Examples
		#### Example 1
		Confirm that the Vector is indeed 0.
		
		```lua 
		a = Vector(0, 0, 0)
		print(a:IsZero())
		```
		**Output:**
		
		true</haxe_doc>
		</IsZero>
		<LengthSqr public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the squared length of the vector, x + y + z. 
		
		This is faster than Vector:Length as calculating the square root is an expensive process. 
		
		 
		**Returns:** Squared length of the vector</haxe_doc>
		</LengthSqr>
		<Distance public="1" set="method">
			<f a="otherVector">
				<c path="gmod.gclass.Vector"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the pythagorean distance between the vector and the other vector. 
		
		
		Name | Description
		--- | ---
		`otherVector` | The vector to get the distance to.
		
		
		**Returns:** Distance between the vectors.
		
		___
		### Lua Examples
		#### Example 1
		Gets the distance from A to B.
		
		```lua 
		print(Vector(0, 0, 0):Distance(Vector(2, 3, 4)))
		```
		**Output:**
		
		5.3851647377014</haxe_doc>
		</Distance>
		<GetNormal public="1" set="method">
			<f a=""><c path="gmod.gclass.Vector"/></f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc>***Deprecated:**   Use Vector: GetNormalized instead.
		
		Returns a normalized version of the vector. This is a alias of Vector:GetNormalized. 
		
		
		**Returns:** Normalized version of the vector.</haxe_doc>
		</GetNormal>
		<Dot public="1" set="method">
			<f a="otherVector">
				<c path="gmod.gclass.Vector"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[Returns the dot product of this vector and the passed one. 
		
		The dot product of two vectors is the product of their magnitudes (lengths), and the cosine of the angle between them: 
		
		 
		Name | Description
		--- | ---
		`otherVector` | The vector to calculate the dot product with
		
		
		**Returns:** The dot product between the two vectors
		
		___
		### Lua Examples
		#### Example 1
		Get the angle of two opposite normalized vectors.
		
		```lua 
		local a = Vector(0, 1, 0)
		local b = Vector(0, -1, 0)
		
		local dot = a:Dot(b) -- returns the cos(ang) of the two vectors because they're both of length 1
		print("Radians", math.acos(dot)) -- the inverse of the cosine to get the angle
		print("Degrees", math.deg(math.acos(dot))) -- Convert radians to degrees
		```
		**Output:**
		
		Radians 3.1415926535898 Degrees 180
		
		#### Example 2
		Calculates whether the player is looking in the direction of an entity. This is often faster than traces, but it produces a slightly different result.The player is looking in the direction of the entity if the angle between the aimvector and the vector from the player to the entity is less than 45 degrees (or pi / 8 radians).
		
		```lua 
		local directionAng = math.pi / 8 
		local aimvector = ply:GetAimVector()
		-- The vector that goes from the player's shoot pos to the entity's position
		local entVector = ent:GetPos() - ply:GetShootPos() 
		local dot = aimvector:Dot(entVector) / entVector:Length()
		print(dot < directionAng)
		```
		**Output:**
		
		This script will say if the player is looking in the direction of the entity.
		
		#### Example 3
		A function to make sure the player is looking somewhere.
		
		```lua 
		function IsLookingAt( ply, targetVec )
		 return ply:GetAimVector():Dot( ( targetVec - ply:GetPos() + Vector(70) ):GetNormalized() ) < 0.95 
		end
		```
		**Output:**
		
		Returns true if ply is looking at (or close to) the target.]]></haxe_doc>
		</Dot>
		<ToColor public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc><![CDATA[Translates the Vector (values ranging from 0 to 1) into a Color structure. This will also range the values from 0 - 1 to 0 - 255. 
		
		x * 255 -> r y * 255 -> g z * 255 -> b 
		
		 This is the opposite of Color:ToVector 
		
		 
		**Returns:** The created Color structure.
		
		___
		### Lua Examples
		#### Example 1
		Get the Player1's player model color but in RGB
		
		```lua 
		print( Entity( 1 ):GetPlayerColor( ):ToColor( ) )
		```
		**Output:**
		
		Prints the player color of Player1 in RGB instead of a Vector]]></haxe_doc>
		</ToColor>
		<Sub public="1" set="method">
			<f a="vector">
				<c path="gmod.gclass.Vector"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Substracts the values of the second vector from the orignal vector, this function can be used to avoid garbage collection. 
		
		
		Name | Description
		--- | ---
		`vector` | The other vector.
		
		
		___
		### Lua Examples
		#### Example 1
		Subtracts vector A's components with the other vector.
		
		```lua 
		a = Vector(5, 6, 7)
		a:Sub(Vector(1, 2, 3))
		print(a)
		```
		
		#### Example 2
		If you don't want to set your vector to the result, and just return a new vector as the result. You can use a ' - ' operator to subtract two vectors from each other.
		
		```lua 
		a = Vector(5, 6, 7)
		print(a-Vector(1, 2, 3))
		```</haxe_doc>
		</Sub>
		<Cross public="1" set="method">
			<f a="otherVector">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
			</f>
			<haxe_doc>Calculates the cross product of this vector and the passed one. 
		
		The cross product of two vectors is a 3-dimensional vector with a direction perpendicular (at right angles) to both of them (according to the right-hand rule), and magnitude equal to the area of parallelogram they span. This is defined as the product of the magnitudes, the sine of the angle between them, and unit (normal) vector n defined by the right-hand rule: 
		
		 
		Name | Description
		--- | ---
		`otherVector` | Vector to calculate the cross product with.
		
		
		**Returns:** The cross product of the two vectors.</haxe_doc>
		</Cross>
		<Div public="1" set="method">
			<f a="divisor">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Divide the vector by the given number, that means x, y and z are divided by that value. This will change the value of the original vector, see example 2 for division without changing the value. 
		
		
		Name | Description
		--- | ---
		`divisor` | The value to divide the vector with.
		
		
		___
		### Lua Examples
		#### Example 1
		Divides a vector by 255.
		
		```lua 
		a = Vector(255, 130, 0)
		a:Div(255)
		print(a)
		```
		
		#### Example 2
		If you don't want to set your vector to the result, and just return a new vector as the result. You can use a ' / ' operator to divide a vector with a divisor.
		
		```lua 
		a = Vector(255, 255, 255)
		print(a/255)
		```</haxe_doc>
		</Div>
		<Rotate public="1" set="method">
			<f a="rotation">
				<c path="gmod.gclass.Angle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Rotates a vector by the given angle. Doesn't return anything, but rather changes the original vector. 
		
		
		Name | Description
		--- | ---
		`rotation` | The angle to rotate the vector by.</haxe_doc>
		</Rotate>
		<Zero public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Sets x, y and z to 0.</haxe_doc>
		</Zero>
		<AngleEx public="1" set="method">
			<f a="up">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Angle"/>
			</f>
			<haxe_doc>Returns the angle of the vector, but instead of assuming that up is Vector( 0, 0, 1 ) (Like Vector:Angle does) you can specify which direction is 'up' for the angle. 
		
		
		Name | Description
		--- | ---
		`up` | The up direction vector
		
		
		**Returns:** The angle
		
		___
		### Lua Examples
		#### Example 1
		Shows usage of the function
		
		```lua 
		print( Vector( 0, 0, 100 ):AngleEx( Vector( 0, 0, 0 ) ) )
		```
		**Output:**
		
		Angle( -90.000, -0.000, 0.000 )</haxe_doc>
		</AngleEx>
		<ToTable public="1" set="method">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns the vector as a table with three elements. 
		
		
		**Returns:** The table with elements 1 = x, 2 = y, 3 = z.</haxe_doc>
		</ToTable>
		<Length2D public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the length of the vector in two dimensions, without the Z axis. 
		
		
		**Returns:** Length of the vector in two dimensions,  x + y</haxe_doc>
		</Length2D>
		<DotProduct public="1" set="method">
			<f a="Vector">
				<c path="gmod.gclass.Vector"/>
				<x path="Float"/>
			</f>
			<meta><m n=":deprecated"/></meta>
			<haxe_doc><![CDATA[***Deprecated:**   This is an alias of Vector: Dot. Use that instead.
		
		Returns the dot product of the two vectors.       A function to make sure the player is looking somewhere. 
		
		
		Name | Description
		--- | ---
		`Vector` | The other vector.
		
		
		**Returns:** Dot Product
		
		___
		### Lua Examples
		#### Example 1
		A function to make sure the player is looking somewhere.
		
		```lua 
		function IsLookingAt( ply, targetVec )
		 return ply:GetAimVector():DotProduct( ( targetVec - ply:GetPos() + Vector(70) ):GetNormalized() ) < 0.95 
		end
		```
		**Output:**
		
		Returns true if ply is looking at (or close to) the target.]]></haxe_doc>
		</DotProduct>
		<Unpack public="1" set="method">
			<f a=""><c path="gmod.gclass.VectorUnpackReturn"/></f>
			<haxe_doc>Returns the x, y, and z of the vector. 
		
		
		Name | Description
		--- | ---
		`a` | x or Vector[1].
		`b` | y or Vector[2].
		`c` | z or Vector[3].</haxe_doc>
		</Unpack>
		<Angle public="1" set="method">
			<f a=""><c path="gmod.gclass.Angle"/></f>
			<haxe_doc>Returns an angle representing the normal of the vector. 
		
		
		**Returns:** The angle/direction of the vector.</haxe_doc>
		</Angle>
		<Length2DSqr public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the squared length of the vectors x and y value, x + y. 
		
		This is faster than Vector:Length2D as calculating the square root is an expensive process. 
		
		 
		**Returns:** Squared length of the vector in two dimensions</haxe_doc>
		</Length2DSqr>
		<Length public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the Euclidean length of the vector:  x + y + z 
		
		
		**Returns:** Length of the vector.
		
		___
		### Lua Examples
		#### Example 1
		Gets the length of the vector.
		
		```lua 
		print(Vector(15, 16, 17):Length())
		```
		**Output:**
		
		27.748874664307.</haxe_doc>
		</Length>
		<IsEqualTol public="1" set="method">
			<f a="compare:tolerance">
				<c path="gmod.gclass.Vector"/>
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns if the vector is equal to another vector with the given tolerance. 
		
		
		Name | Description
		--- | ---
		`compare` | The vector to compare to.
		`tolerance` | The tolerance range.
		
		
		**Returns:** Are the vectors equal or not.</haxe_doc>
		</IsEqualTol>
		<Mul public="1" set="method">
			<f a="multiplier">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Scales the vector by the given number, that means x, y and z are multiplied by that value. 
		
		
		Name | Description
		--- | ---
		`multiplier` | The value to scale the vector with.
		
		
		___
		### Lua Examples
		#### Example 1
		Scales a vector by 250.
		
		```lua 
		a = Vector(1, 1, 1)
		a:Mul(250)
		print(a)
		```
		
		#### Example 2
		If you don't want to set your vector to the result, and just return a new vector as the result. You can use a ' * ' operator to multiply a vector with a scalar.
		
		```lua 
		a = Vector(1, 1, 1)
		print(a*250)
		```</haxe_doc>
		</Mul>
		<haxe_doc><![CDATA[List of all possible functions to manipulate vectors. 
	
	Created by Vector & many more functions.]]></haxe_doc>
	</class>
	<class path="gmod.gclass.VectorUnpackReturn" params="" file="src/gmod/gclass/Vector.hx" module="gmod.gclass.Vector" extern="1">
		<a public="1"><x path="Float"/></a>
		<b public="1"><x path="Float"/></b>
		<c public="1"><x path="Float"/></c>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="gmod.gclass.Weapon" params="" file="src/gmod/gclass/Weapon.hx" extern="1">
		<extends path="gmod.gclass.Entity"/>
		<SetClip1 public="1" set="method">
			<f a="ammo">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Lets you change the number of bullets in the given weapons primary clip. 
		
		
		Name | Description
		--- | ---
		`ammo` | The amount of bullets the clip should contain</haxe_doc>
		</SetClip1>
		<SetNextSecondaryFire public="1" set="method">
			<f a="time">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets when the weapon can alt-fire again. Time should be based on CurTime. 
		
		
		Name | Description
		--- | ---
		`time` | Time when player should be able to use secondary fire again</haxe_doc>
		</SetNextSecondaryFire>
		<CallOnClient public="1" set="method">
			<f a="functionName:?arguments">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Calls a SWEP function on client. 
		
		
		Name | Description
		--- | ---
		`functionName` | Name of function to call. If you want to call SWEP:MyFunc() on client, you type in "MyFunc"
		`arguments` | Arguments for the function, separated by spaces. NOTE Only the second argument is passed as argument and must be a string</haxe_doc>
		</CallOnClient>
		<GetMaxClip1 public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns maximum primary clip size 
		
		
		**Returns:** Maximum primary clip size</haxe_doc>
		</GetMaxClip1>
		<GetHoldType public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the hold type of the weapon. 
		
		
		**Returns:** The hold type of the weapon. You can find a list of default hold types here.</haxe_doc>
		</GetHoldType>
		<SetNextPrimaryFire public="1" set="method">
			<f a="time">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets when the weapon can fire again. Time should be based on CurTime. 
		
		
		Name | Description
		--- | ---
		`time` | Time when player should be able to use primary fire again</haxe_doc>
		</SetNextPrimaryFire>
		<AllowsAutoSwitchTo public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the weapon allows to being switched to when a better ( Weapon:GetWeight ) weapon is being picked up. 
		
		
		**Returns:** Whether the weapon allows to being switched to.</haxe_doc>
		</AllowsAutoSwitchTo>
		<SendWeaponAnim public="1" set="method">
			<f a="act">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Forces weapon to play activity/animation. 
		
		
		Name | Description
		--- | ---
		`act` | Activity to play. See the ACT_ Enums (specifically ACT_VM_).</haxe_doc>
		</SendWeaponAnim>
		<Clip2 public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns how much secondary ammo is in magazine. 
		
		
		**Returns:** The amount of secondary ammo in the magazine.
		
		___
		### Lua Examples
		#### Example 1
		Prints the amount of seconday ammo in the magazine of the weapon the 1st player has equipped.
		
		```lua 
		print( player.GetByID( 1 ):GetActiveWeapon():Clip2() )
		```
		**Output:**
		
		Will print -1 for all HL2 weapons.</haxe_doc>
		</Clip2>
		<Clip1 public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns how much primary ammo is in the magazine. 
		
		
		**Returns:** The amount of primary ammo in the magazine.
		
		___
		### Lua Examples
		#### Example 1
		Prints the amount of primary ammo in the magazine of the weapon the 1st player has equipped.
		
		```lua 
		print( player.GetByID( 1 ):GetActiveWeapon():Clip1() )
		```
		**Output:**
		
		Will print 45 for fully loaded SMG1.</haxe_doc>
		</Clip1>
		<GetWeaponViewModel public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the view model of the weapon. 
		
		
		**Returns:** The view model of the weapon.</haxe_doc>
		</GetWeaponViewModel>
		<IsWeaponVisible public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the weapon is visible. The term visibility is not exactly what gets checked here, first it checks if the owner is a player, then checks if the active view model has EF_NODRAW flag NOT set. 
		
		
		**Returns:** Is visible or not</haxe_doc>
		</IsWeaponVisible>
		<SetClip2 public="1" set="method">
			<f a="ammo">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Lets you change the number of bullets in the given weapons secondary clip. 
		
		
		Name | Description
		--- | ---
		`ammo` | The amount of bullets the clip should contain</haxe_doc>
		</SetClip2>
		<GetWeight public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the "weight" of the weapon, which is used when deciding which Weapon is better by the engine. 
		
		
		**Returns:** The weapon "weight".</haxe_doc>
		</GetWeight>
		<GetMaxClip2 public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns maximum secondary clip size 
		
		
		**Returns:** Maximum secondary clip size</haxe_doc>
		</GetMaxClip2>
		<SetLastShootTime public="1" set="method">
			<f a="?time">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the time since this weapon last fired in seconds. Used in conjunction with Weapon:LastShootTime 
		
		
		Name | Description
		--- | ---
		`time` | The time in seconds when the last time the weapon was fired.</haxe_doc>
		</SetLastShootTime>
		<IsScripted public="1" set="method" override="1">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Checks if the weapon is a SWEP or a built-in weapon. 
		
		
		**Returns:** Returns true if weapon is scripted ( SWEP ), false if not ( A built-in HL2 weapon )</haxe_doc>
		</IsScripted>
		<HasAmmo public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the weapon has ammo left or not. It will return false when there's no ammo left in the magazine and when there's no reserve ammo left. 
		
		
		**Returns:** Whether the weapon has ammo or not.</haxe_doc>
		</HasAmmo>
		<GetSlot public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the slot of the weapon (slot numbers start from 0) 
		
		
		**Returns:** The slot of the weapon
		
		___
		### Lua Examples
		#### Example 1
		How you could use this function to check if a weapon slot was empty or not
		
		```lua 
		local function IsSlotEmpty( ply, slot )
		
		    slot = slot - 1 -- take away 1 from the slot number you want since it starts from 0
		
		    local weptbl = ply:GetWeapons() -- get all the weapons the player has
		
		    for k,v in pairs( weptbl ) do -- loop through them
		        if v:GetSlot() == slot then return false end -- check if the slot is the slot you wanted to check, if it is, return false
		    end
		
		    return true -- otherwise return true
		
		end
		```</haxe_doc>
		</GetSlot>
		<GetSecondaryAmmoType public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gets the ammo type of the given weapons secondary fire. 
		
		
		**Returns:** The secondary ammo type ID, or -1 if not found.</haxe_doc>
		</GetSecondaryAmmoType>
		<LastShootTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the time since this weapon last fired a bullet with Entity:FireBullets in seconds. It is not networked. 
		
		
		**Returns:** The time in seconds when the last bullet was fired.</haxe_doc>
		</LastShootTime>
		<GetPrintName public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the non-internal name of the weapon, that should be for displaying. 
		
		
		**Returns:** The "nice" name of the weapon.</haxe_doc>
		</GetPrintName>
		<GetSlotPos public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns slot position of the weapon 
		
		
		**Returns:** The slot position of the weapon</haxe_doc>
		</GetSlotPos>
		<GetNextPrimaryFire public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gets the next time the weapon can primary fire. ( Can call WEAPON:PrimaryAttack ) 
		
		
		**Returns:** The time, relative to CurTime</haxe_doc>
		</GetNextPrimaryFire>
		<GetActivity public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the sequence enumeration number that the weapon is playing. 
		
		
		**Returns:** Current activity, see ACT_ Enums. Returns 0 if the weapon doesn't have active sequence.
		
		___
		### Lua Examples
		#### Example 1
		This will return the ACT_ENUM that is currently active for the weapon.
		
		```lua 
		local wep = Entity(1):GetActiveWeapon()
		 
		if ( IsValid( wep ) ) then // Makes sure that wep exists
		 
		    print( wep:GetActivity() ) // Prints the sequence number
		 
		end
		```</haxe_doc>
		</GetActivity>
		<GetNextSecondaryFire public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gets the next time the weapon can secondary fire. ( Can call WEAPON:SecondaryAttack ) 
		
		
		**Returns:** The time, relative to CurTime</haxe_doc>
		</GetNextSecondaryFire>
		<GetPrimaryAmmoType public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Gets the primary ammo type of the given weapon. 
		
		
		**Returns:** The ammo type ID, or -1 if not found.</haxe_doc>
		</GetPrimaryAmmoType>
		<AllowsAutoSwitchFrom public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Returns whether the weapon allows to being switched from when a better ( Weapon:GetWeight ) weapon is being picked up. 
		
		
		**Returns:** Whether the weapon allows to being switched from.</haxe_doc>
		</AllowsAutoSwitchFrom>
		<SetHoldType public="1" set="method">
			<f a="name">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the hold type of the weapon. This function also calls WEAPON:SetWeaponHoldType and properly networks it to all clients. 
		
		
		Name | Description
		--- | ---
		`name` | Name of the hold type. You can find all default hold types here
		
		
		___
		### Lua Examples
		#### Example 1
		Puts a players hands down by its sides on reload.
		
		```lua 
		function SWEP:Reload()
		    self:SetHoldType( "normal" )
		end
		```</haxe_doc>
		</SetHoldType>
		<DefaultReload public="1" set="method">
			<f a="act">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Forces the weapon to reload while playing given animation. 
		
		
		Name | Description
		--- | ---
		`act` | Sequence to use as reload animation. Uses the ACT_ Enums.
		
		
		**Returns:** Did reloading actually take place</haxe_doc>
		</DefaultReload>
		<GetWeaponWorldModel public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the world model of the weapon. 
		
		
		**Returns:** The world model of the weapon.</haxe_doc>
		</GetWeaponWorldModel>
		<haxe_doc>This is a list of all methods only available for weapons. It is also possible to call Entity functions on weapons.</haxe_doc>
	</class>
	<class path="gmod.libs.EntsLib" params="" file="src/gmod/libs/EntsLib.hx" extern="1">
		<GetAll public="1" set="method" static="1">
			<f a=""><c path="lua.Table">
	<x path="Int"/>
	<t path="gmod.types.Entity"/>
</c></f>
			<haxe_doc>Returns a table of all existing entities. 
		
		
		**Returns:** Table of all existing Entitys.</haxe_doc>
		</GetAll>
		<FindInSphere public="1" set="method" static="1">
			<f a="origin:radius">
				<c path="gmod.gclass.Vector"/>
				<x path="Float"/>
				<c path="lua.Table">
					<x path="Int"/>
					<t path="gmod.types.Entity"/>
				</c>
			</f>
			<haxe_doc>Gets all entities within the specified sphere. 
		
		
		Name | Description
		--- | ---
		`origin` | Center of the sphere.
		`radius` | Radius of the sphere.
		
		
		**Returns:** A table of all found Entitys. Has a limit of 1024 entities.</haxe_doc>
		</FindInSphere>
		<FindByName public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<c path="lua.Table">
					<x path="Int"/>
					<t path="gmod.types.Entity"/>
				</c>
			</f>
			<haxe_doc>Gets all entities with the given hammer targetname. This works internally by iterating over ents.GetAll. 
		
		
		Name | Description
		--- | ---
		`name` | The targetname to look for
		
		
		**Returns:** A table of all found entities</haxe_doc>
		</FindByName>
		<FindInBox public="1" set="method" static="1">
			<f a="boxMins:boxMaxs">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<c path="lua.Table">
					<x path="Int"/>
					<t path="gmod.types.Entity"/>
				</c>
			</f>
			<haxe_doc>Returns all entities within the specified box. 
		
		
		Name | Description
		--- | ---
		`boxMins` | The box minimum coordinates.
		`boxMaxs` | The box maximum coordinates.
		
		
		**Returns:** A table of all found entities.
		
		___
		### Lua Examples
		#### Example 1
		Returns a table of players in a box using ents.FindInBox
		
		```lua 
		function ents.FindPlayersInBox( vCorner1, vCorner2 )
		    local tEntities = ents.FindInBox( vCorner1, vCorner2 )
		    local tPlayers = {}
		    local iPlayers = 0
		    
		    for i = 1, #tEntities do
		        if ( tEntities[ i ]:IsPlayer() ) then
		            iPlayers = iPlayers + 1
		            tPlayers[ iPlayers ] = tEntities[ i ]
		        end
		    end
		    
		    return tPlayers, iPlayers
		end
		```</haxe_doc>
		</FindInBox>
		<FindInCone public="1" set="method" static="1">
			<f a="origin:normal:range:angle_cos">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="lua.Table">
					<x path="Int"/>
					<t path="gmod.types.Entity"/>
				</c>
			</f>
			<haxe_doc>Finds and returns all entities within the specified cone. Only entities whose Entity:WorldSpaceCenter is within the cone are considered to be in it. 
		
		The "cone" is actually a conical "slice" of an axis-aligned box (see: ents.FindInBox). The image to the right shows approximately how this function would look in 2D. Due to this, the entity may be farther than the specified range! 
		
		 
		Name | Description
		--- | ---
		`origin` | The tip of the cone.
		`normal` | Direction of the cone.
		`range` | The range of the cone/box around the origin.
		`angle_cos` | The cosine of the angle between the center of the cone to its edges, which is half the overall angle of the cone. 1 makes a 0 cone, 0.707 makes approximately 90, 0 makes 180, and so on.
		
		
		**Returns:** A table of all found Entitys.
		
		___
		### Lua Examples
		#### Example 1
		An example usage of this function. This example shows which entities are being returned by the function with red lines and the range with white transparent box.
		
		```lua 
		local mat = Material( "models/shiny" )
		mat:SetFloat( "$alpha", 0.5 )
		
		hook.Add( "PostDrawOpaqueRenderables", "conetest", function()
		    local size = 200
		    local dir = LocalPlayer():GetAimVector()
		    local angle = math.cos( math.rad( 15 ) ) -- 15 degrees
		    local startPos = LocalPlayer():EyePos()
		
		    local entities = ents.FindInCone( startPos, dir, size, angle )
		
		    -- draw the outer box
		    local mins = Vector( -size, -size, -size )
		    local maxs = Vector( size, size, size )
		
		    render.SetMaterial( mat )
		    render.DrawWireframeBox( startPos, Angle( 0, 0, 0 ), mins, maxs, color_white, true )
		    render.DrawBox( startPos, Angle( 0, 0, 0 ), -mins, -maxs, color_white )
		
		    -- draw the lines
		    for id, ent in pairs( entities ) do
		        render.DrawLine( ent:WorldSpaceCenter() - dir * ( ent:WorldSpaceCenter()-startPos ):Length(), ent:WorldSpaceCenter(), Color( 255, 0, 0 ) )
		    end
		end )
		```</haxe_doc>
		</FindInCone>
		<GetByIndex public="1" set="method" static="1">
			<f a="entIdx">
				<x path="Float"/>
				<t path="gmod.types.Entity"/>
			</f>
			<haxe_doc>Returns an entity by its index. Same as Entity. 
		
		
		Name | Description
		--- | ---
		`entIdx` | The index of the entity.
		
		
		**Returns:** The entity if it exists.</haxe_doc>
		</GetByIndex>
		<GetCount public="1" set="method" static="1">
			<f a="?IncludeKillMe">
				<x path="Bool"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Gives you the amount of currently existing entities. Similar to #ents.GetAll but with much better performance. 
		
		
		Name | Description
		--- | ---
		`IncludeKillMe` | Include entities with the FL_KILLME flag. This will skip an internal loop, and the function will be more efficient as a byproduct.
		
		
		**Returns:** Number of entities</haxe_doc>
		</GetCount>
		<FindByModel public="1" set="method" static="1">
			<f a="model">
				<c path="String"/>
				<c path="lua.Table">
					<x path="Int"/>
					<t path="gmod.types.Entity"/>
				</c>
			</f>
			<haxe_doc>Gets all entities with the given model, supports wildcards. This works internally by iterating over ents.GetAll. 
		
		
		Name | Description
		--- | ---
		`model` | The model of the entities to find.
		
		
		**Returns:** A table of all found entities.</haxe_doc>
		</FindByModel>
		<FindByClass public="1" set="method" static="1">
			<f a="_class">
				<c path="String"/>
				<t path="lua.AnyTable"/>
			</f>
			<haxe_doc>Gets all entities with the given class, supports wildcards. This works internally by iterating over ents.GetAll. Even if internally ents.GetAll is used, It is faster to use ents.FindByClass than ents.GetAll with a single class comparison. 
		
		
		Name | Description
		--- | ---
		`class` | The class of the entities to find.
		
		
		**Returns:** A table containing all found entities
		
		___
		### Lua Examples
		#### Example 1
		Prints the location of every prop on the map.
		
		```lua 
		for k, v in pairs( ents.FindByClass( "prop_*" ) ) do
		    print( v:GetPos() )
		end
		```
		**Output:**
		
		The location of each prop on the map. In gm_construct, the output might be as follows: -2936.288818 -1376.545532 -73.852913 -2943.928467 -1375.800171 -84.964996 -2932.637695 -1288.051636 -76.791924 -2064.000000 -183.000000 -179.216003 -2384.000000 -183.000000 -179.216003 -2704.000000 -183.000000 -179.216003 -1744.000000 -183.000000 -179.216003 -1424.000000 -183.000000 -179.216003 -3019.895020 -1095.824829 -78.900757</haxe_doc>
		</FindByClass>
		<FindAlongRay public="1" set="method" static="1">
			<f a="start:end:?mins:?maxs">
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<c path="gmod.gclass.Vector"/>
				<c path="lua.Table">
					<x path="Int"/>
					<t path="gmod.types.Entity"/>
				</c>
			</f>
			<haxe_doc>Returns a table of all entities along the ray. The ray does not stop on collisions, meaning it will go through walls/entities. 
		
		
		Name | Description
		--- | ---
		`start` | The start position of the ray
		`end` | The end position of the ray
		`mins` | The mins corner of the ray
		`maxs` | The maxs corner of the ray
		
		
		**Returns:** Table of the found entities.</haxe_doc>
		</FindAlongRay>
		<FindByClassAndParent public="1" set="method" static="1">
			<f a="_class:parent">
				<c path="String"/>
				<t path="gmod.types.Entity"/>
				<c path="lua.Table">
					<x path="Int"/>
					<t path="gmod.types.Entity"/>
				</c>
			</f>
			<haxe_doc>Finds all entities that are of given class and are children of given entity. This works internally by iterating over ents.GetAll. 
		
		
		Name | Description
		--- | ---
		`class` | The class of entities to search for
		`parent` | Parent of entities that are being searched for
		
		
		**Returns:** A table of found entities or nil if none are found</haxe_doc>
		</FindByClassAndParent>
		<haxe_doc>The ents library provides functions for creating and finding entities in the game.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"ents"</e></m>
		</meta>
	</class>
	<typedef path="gmod.types.Entity" params="" file="src/gmod/types/Entity.hx"><c path="gmod.gclass.Entity"/></typedef>
	<abstract path="haxe.Function" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="/usr/share/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/share/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<abstract path="haxe.Int32" params="" file="/usr/share/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/usr/share/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/usr/share/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/usr/share/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
	<high public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</high>
	<low public="1" get="accessor" set="null" static="1">
		<x path="haxe.Int32"/>
		<meta><m n=":impl"/></meta>
	</low>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/usr/share/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<abstract path="haxe.ds.HashMap" params="K:V" file="/usr/share/haxe/std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="/usr/share/haxe/std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="lua.Table" params="A:B" file="/usr/share/haxe/std/lua/Table.hx" extern="1">
		<create public="1" params="A:B" set="method" static="1"><f a="?arr:?hsh">
	<c path="Array"><c path="create.B"/></c>
	<d/>
	<c path="lua.Table">
		<c path="create.A"/>
		<c path="create.B"/>
	</c>
</f></create>
		<fromArray public="1" params="T" get="inline" set="null" line="34" static="1"><f a="arr">
	<c path="Array"><c path="fromArray.T"/></c>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="fromArray.T"/>
	</c>
</f></fromArray>
		<fromMap public="1" params="A:B" get="inline" set="null" line="42" static="1">
			<f a="map">
				<t path="Map">
					<c path="fromMap.A"/>
					<c path="fromMap.B"/>
				</t>
				<c path="lua.Table">
					<c path="fromMap.A"/>
					<c path="fromMap.B"/>
				</c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromMap>
		<fromDynamic public="1" params="A:B" get="inline" set="null" line="50" static="1">
			<f a="dyn">
				<d/>
				<c path="lua.Table">
					<c path="fromDynamic.A"/>
					<c path="fromDynamic.B"/>
				</c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromDynamic>
		<concat public="1" params="A:B" set="method" static="1">
			<f a="table:?sep:?i:?j">
				<c path="lua.Table">
					<c path="concat.A"/>
					<c path="concat.B"/>
				</c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<overloads><concat public="1" params="A:B" set="method"><f a="table">
	<c path="lua.Table">
		<c path="concat.A"/>
		<c path="concat.B"/>
	</c>
	<x path="Void"/>
</f></concat></overloads>
		</concat>
		<foreach public="1" params="A:B" set="method" static="1"><f a="table:f">
	<c path="lua.Table">
		<c path="foreach.A"/>
		<c path="foreach.B"/>
	</c>
	<f a=":">
		<c path="foreach.A"/>
		<c path="foreach.B"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></foreach>
		<foreachi public="1" params="A:B" set="method" static="1"><f a="table:f">
	<c path="lua.Table">
		<c path="foreachi.A"/>
		<c path="foreachi.B"/>
	</c>
	<f a="::">
		<c path="foreachi.A"/>
		<c path="foreachi.B"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></foreachi>
		<sort public="1" params="A:B" set="method" static="1"><f a="table:?order">
	<c path="lua.Table">
		<c path="sort.A"/>
		<c path="sort.B"/>
	</c>
	<f a=":">
		<c path="sort.A"/>
		<c path="sort.A"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></sort>
		<insert public="1" params="B" set="method" static="1">
			<f a="table:pos:value">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="insert.B"/>
				</c>
				<x path="Int"/>
				<c path="insert.B"/>
				<x path="Void"/>
			</f>
			<overloads><insert public="1" params="B" set="method"><f a="table:value">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="insert.B"/>
	</c>
	<c path="insert.B"/>
	<x path="Void"/>
</f></insert></overloads>
		</insert>
		<remove public="1" params="B" set="method" static="1">
			<f a="table:?pos">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="remove.B"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><remove public="1" params="B" set="method"><f a="table">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="remove.B"/>
	</c>
	<x path="Void"/>
</f></remove></overloads>
		</remove>
		<haxe_doc>This library provides generic functions for table manipulation.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.table"</e></m>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/usr/share/haxe/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta><m n=":multiType"><e>@:followWithAbstracts K</e></m></meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/usr/share/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/usr/share/haxe/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>concat</e>
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/usr/share/haxe/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray">
	<length public="1" get="accessor" set="null" static="1">
		<x path="Int"/>
		<meta><m n=":impl"/></meta>
		<haxe_doc>The length of `this` Array.</haxe_doc>
	</length>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/usr/share/haxe/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/usr/share/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.Rest" params="T" file="/usr/share/haxe/std/haxe/extern/Rest.hx">
		<this><c path="Array"><c path="haxe.extern.Rest.T"/></c></this>
		<haxe_doc><![CDATA[A special abstract type that represents "rest" function argument.

	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<impl><class path="haxe.extern._Rest.Rest_Impl_" params="" file="/usr/share/haxe/std/haxe/extern/Rest.hx" private="1" module="haxe.extern.Rest"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.io.BytesData" params="" file="/usr/share/haxe/std/haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="lua.NativeStringTools" params="" file="/usr/share/haxe/std/lua/NativeStringTools.hx" extern="1">
		<len public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Receives a string and returns its length. The empty string `""` has
		length `0`. Embedded zeros are counted, so `"a\000bc\000"` has length `5`.</haxe_doc>
		</len>
		<char public="1" set="method" static="1">
			<f a="codes">
				<x path="haxe.extern.Rest"><x path="Int"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Receives zero or more integers. Returns a string with length equal to the
		number of arguments, in which each character has the internal numerical
		code equal to its corresponding argument.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</char>
		<sub public="1" set="method" static="1">
			<f a="str:start:?end">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.StringSub"/>
			</f>
			<haxe_doc>Returns the substring of `str` that starts at `start` and continues until `end`;
		`start` and `end` can be negative. If `end` is absent, then it is assumed to be
		equal to `-1` (which is the same as the string length).
		In particular, the call `sub(str,1,end)` returns a prefix of `str`
		with length `end`, and `sub(str, -end)` returns a suffix of `str` with
		length `start`.</haxe_doc>
		</sub>
		<find public="1" set="method" static="1">
			<f a="str:target:?start:?plain">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="lua.StringFind"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string `str`.
		If it finds a match, then `find` returns the indices of `str` where this
		occurrence starts and ends.

		@param target If the target has captures, then in a successful match the
			   captured values are also returned, after the two indices.
		@param start specifies where to start the search; its default value is `1`
			   and can be negative.
		@param plain turns off the pattern matching facilities, so the function does
			   a plain "find substring" operation, with no characters in pattern
			   being considered "magic". Note that if plain is given, then `start` must be given as well.</haxe_doc>
		</find>
		<byte public="1" set="method" static="1">
			<f a="str:?index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the internal numerical codes of the characters `str[index]`.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</byte>
		<format public="1" set="method" static="1">
			<f a="str:?e1:?e2:?e3:?e4">
				<c path="String"/>
				<d/>
				<d/>
				<d/>
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a formatted version of its variable number of arguments following
		the description given in its first argument (which must be a string).
		The format string follows the same rules as the printf family of standard C
		functions. The only differences are that the options/modifiers
		`*`, `l`, `L`, `n`, `p`, and `h` are not supported and that there is an
		extra option, `q`. The `q` option formats a string in a form suitable to be
		safely read back by the Lua interpreter: the string is written between
		double quotes, and all double quotes, newlines, embedded zeros,
		and backslashes in the string are correctly escaped when written.
		For instance, the call
		   `string.format('%q', 'a string with "quotes" and \n new line')`
		will produce the string:
		`"a string with \"quotes\" and \
			  new line"`

		The options `c`, `d` `E`, `e`, `f`, `g`, `G`, `i`, `o`, `u, `X-, and `x` all
		expect a number as argument, whereas `q` and `s` expect a string.

		This function does not accept string values containing embedded zeros,
		except as arguments to the `q` option.</haxe_doc>
		</format>
		<gsub public="1" set="method" static="1">
			<f a="str:pattern:replace:?n">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
			<overloads>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<c path="String"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
			</overloads>
		</gsub>
		<gmatch public="1" set="method" static="1">
			<f a="str:pattern">
				<c path="String"/>
				<c path="String"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
			<overloads><gmatch public="1" set="method">
	<f a="str:pattern:match:?n">
		<c path="String"/>
		<c path="String"/>
		<f a=""><c path="String"/></f>
		<x path="Int"/>
		<f a="">
			<c path="String"/>
			<x path="Void"/>
		</f>
	</f>
	<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
</gmatch></overloads>
		</gmatch>
		<match public="1" set="method" static="1">
			<f a="str:pattern:?n">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string s. If it finds one,
		then match returns the captures from the pattern; otherwise it returns `null`.
		If pattern specifies no captures, then the whole match is returned.
		The optional argument `n` specifies where to start the search;
		its default value is `1` and can be negative.</haxe_doc>
		</match>
		<upper public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all lowercase
		letters changed to uppercase. All other characters are left unchanged.
		The definition of what a lowercase letter is depends on the current locale.</haxe_doc>
		</upper>
		<lower public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all uppercase
		letters changed to lowercase. All other characters are left unchanged.
		The definition of what an uppercase letter is depends on the current locale.</haxe_doc>
		</lower>
		<dump public="1" set="method" static="1">
			<f a="d">
				<d/>
				<d/>
			</f>
			<haxe_doc>Returns a string containing a binary representation of the given function,
		so that a later loadstring on this string returns a copy of the function.
		function must be a Lua function without upvalues.</haxe_doc>
		</dump>
		<haxe_doc>These are all externs for the base Lua "string" class, which functions
	as an additional set of string tools.

	Note that all relevant indexes are "1" based.</haxe_doc>
		<meta><m n=":native"><e>"_G.string"</e></m></meta>
	</class>
	<class path="lua.Boot" params="" file="/usr/share/haxe/std/lua/Boot.hx">
		<hiddenFields expr="untyped __lua__(&quot;{__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}&quot;)" line="44" static="1">
			<c path="lua.Table">
				<c path="String"/>
				<x path="Bool"/>
			</c>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>untyped __lua__("{__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}")</e></m>
			</meta>
		</hiddenFields>
		<isArray set="method" line="132" static="1">
			<f a="o">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isArray>
		<printEnum set="method" line="160" static="1">
			<f a="o:s">
				<c path="Array"><d/></c>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Helper method to generate a string representation of an enum</haxe_doc>
		</printEnum>
		<printClassRec set="method" line="187" static="1">
			<f a="c:?result:s" v=":&quot;&quot;:">
				<c path="lua.Table">
					<c path="String"/>
					<d/>
				</c>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ result : "" }</e></m>
			</meta>
			<haxe_doc>Helper method to generate a string representation of a class</haxe_doc>
		</printClassRec>
		<__string_rec set="method" line="197" static="1">
			<f a="o:?s" v=":&quot;&quot;">
				<d/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":value"><e>{ s : "" }</e></m>
				<m n=":ifFeature"><e>"has_enum"</e></m>
			</meta>
			<haxe_doc>Generate a string representation for arbitrary object.</haxe_doc>
		</__string_rec>
		<fieldIterator public="1" set="method" line="389" static="1">
			<f a="o">
				<c path="lua.Table">
					<c path="String"/>
					<d/>
				</c>
				<t path="Iterator"><c path="String"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fieldIterator>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="lua.FileHandle" params="" file="/usr/share/haxe/std/lua/FileHandle.hx" extern="1">
		<extends path="lua.UserData"/>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
		<read public="1" set="method"><f a="arg">
	<x path="haxe.extern.Rest"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="Int"/>
</x></x>
	<c path="String"/>
</f></read>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<write public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<seek public="1" set="method">
			<f a="arg:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<seek public="1" set="method"><f a=""><x path="Int"/></f></seek>
				<seek public="1" set="method"><f a="arg">
	<c path="String"/>
	<x path="Int"/>
</f></seek>
			</overloads>
		</seek>
	</class>
	<class path="lua.Io" params="" file="/usr/share/haxe/std/lua/Io.hx" extern="1">
		<stdin public="1" static="1"><c path="lua.FileHandle"/></stdin>
		<stderr public="1" static="1"><c path="lua.FileHandle"/></stderr>
		<stdout public="1" static="1"><c path="lua.FileHandle"/></stdout>
		<close public="1" set="method" static="1">
			<f a="?file">
				<c path="lua.FileHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Function to close regular files.</haxe_doc>
		</close>
		<flush public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Saves any written data to file.</haxe_doc>
		</flush>
		<input public="1" set="method" static="1">
			<f a="file">
				<c path="lua.FileHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>When called with a file name, it opens the named file (in text mode),
		and sets its handle as the default input file. When called with a file handle,
		it simply sets this file handle as the default input file.
		When called without parameters, it returns the current default input file.

		In case of errors this function raises the error, instead of returning an
		error code.</haxe_doc>
			<overloads><input public="1" set="method">
	<f a="file">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>When called with a file name, it opens the named file (in text mode),
		and sets its handle as the default input file. When called with a file handle,
		it simply sets this file handle as the default input file.
		When called without parameters, it returns the current default input file.

		In case of errors this function raises the error, instead of returning an
		error code.</haxe_doc>
</input></overloads>
		</input>
		<lines public="1" set="method" static="1">
			<f a="?file">
				<c path="String"/>
				<x path="lua.NativeIterator"><c path="String"/></x>
			</f>
			<haxe_doc>Opens the given file name in read mode and returns an iterator function that,
		each time it is called, returns a new line from the file.</haxe_doc>
		</lines>
		<open public="1" set="method" static="1">
			<f a="filename:?mode">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.FileHandle"/>
			</f>
			<haxe_doc>This function opens a file, in the mode specified in the string mode.
		It returns a new file handle, or, in case of errors, `null` plus an error message.

		The mode string can be any of the following:

		* `"r"`: read mode (the default)
		* `"w"`: write mode
		* `"a"`: append mode
		* `"r+"`: update mode, all previous data is preserved
		* `"w+"`: update mode, all previous data is erased
		* `"a+"`: append update mode, previous data is preserved, writing is only
			allowed at the end of file

		The mode string can also have a `b` at the end, which is needed in some systems
		to open the file in binary mode. This string is exactly what is used in the
		standard C function fopen.</haxe_doc>
		</open>
		<popen public="1" set="method" static="1">
			<f a="command:?mode">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.FileHandle"/>
			</f>
			<haxe_doc>Starts program `command` in a separated process and returns a file handle that
		you can use to read data from this program (if mode is `"r"`, the default)
		or to write data to this program (if mode is `"w"`).

		This function is system dependent and is not available on all platforms.</haxe_doc>
		</popen>
		<read public="1" set="method" static="1">
			<f a="?filename">
				<c path="String"/>
				<c path="String"/>
			</f>
			<overloads><read public="1" set="method"><f a="?count">
	<x path="Int"/>
	<c path="String"/>
</f></read></overloads>
		</read>
		<write public="1" set="method" static="1">
			<f a="v">
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes the value of each of its arguments to the file. The arguments must
		be strings or numbers.
		To write other values, use `Lua.tostring` or `NativeStringTools.format`
		before write.</haxe_doc>
		</write>
		<output public="1" set="method" static="1"><f a="?file">
	<c path="String"/>
	<c path="lua.FileHandle"/>
</f></output>
		<tmpfile public="1" set="method" static="1">
			<f a=""><c path="lua.FileHandle"/></f>
			<haxe_doc>Returns a handle for a temporary file. This file is opened in update mode
		and it is automatically removed when the program ends.</haxe_doc>
		</tmpfile>
		<type public="1" set="method" static="1">
			<f a="obj">
				<c path="lua.FileHandle"/>
				<x path="lua.IoType"/>
			</f>
			<haxe_doc>Checks whether `obj` is a valid file handle.</haxe_doc>
		</type>
		<haxe_doc>Input and Output Facilities</haxe_doc>
		<meta><m n=":native"><e>"_G.io"</e></m></meta>
	</class>
	<abstract path="lua.IoType" params="" file="/usr/share/haxe/std/lua/Io.hx" module="lua.Io">
		<this><c path="String"/></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<haxe_doc>A enumerator that describes the output of `Io.type()`.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._Io.IoType_Impl_" params="" file="/usr/share/haxe/std/lua/Io.hx" private="1" module="lua.Io"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="lua.LocaleCategory" params="" file="/usr/share/haxe/std/lua/LocaleCategory.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._LocaleCategory.LocaleCategory_Impl_" params="" file="/usr/share/haxe/std/lua/LocaleCategory.hx" private="1" module="lua.LocaleCategory"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.Lua" params="" file="/usr/share/haxe/std/lua/Lua.hx" extern="1">
		<_VERSION public="1" static="1">
			<c path="String"/>
			<haxe_doc>A global variable that holds a string containing the current interpreter
		version.</haxe_doc>
		</_VERSION>
		<arg public="1" static="1"><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></arg>
		<getmetatable public="1" set="method" static="1">
			<f a="tbl">
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
			</f>
			<haxe_doc>Pushes onto the stack the metatable in the registry.</haxe_doc>
		</getmetatable>
		<setmetatable public="1" set="method" static="1">
			<f a="tbl:mtbl">
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
			</f>
			<haxe_doc>Pops a table from the stack and sets it as the new metatable for the value
		at the given acceptable index.</haxe_doc>
		</setmetatable>
		<setfenv public="1" set="method" static="1">
			<f a="i:tbl">
				<x path="Int"/>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<x path="Void"/>
			</f>
			<haxe_doc>Pops a table from the stack and sets it as the new environment for the value
		at the given index. If the value at the given index is neither a function nor
		a thread nor a userdata, lua_setfenv returns `0`.
		Otherwise it returns `1`.</haxe_doc>
		</setfenv>
		<next public="1" params="K:V" set="method" static="1">
			<f a="k:?i">
				<c path="lua.Table">
					<c path="next.K"/>
					<c path="next.V"/>
				</c>
				<c path="next.K"/>
				<c path="lua.NextResult">
					<c path="next.K"/>
					<c path="next.V"/>
				</c>
			</f>
			<haxe_doc>Allows a program to traverse all fields of a table.
		Its first argument is a table and its second argument is an index in this
		table. `next` returns the next index of the table and its associated value.
		When `i` is `null`, `next` returns an initial index and its associated value.
		When called with the last index, or with `null` in an empty table, `next`
		returns `null`.  In particular, you can use `next(t)` to check whether a
		table is empty.

		The order in which the indices are enumerated is not specified, even for
		numeric indices. (To traverse a table in numeric order, use a numerical for
		or the `ipairs` function).

		The behavior of next is undefined if, during the traversal, any value
		to a non-existent field in the table is assigned. Existing fields may
		however be modified. In particular, existing fields may be cleared.</haxe_doc>
		</next>
		<tostring public="1" set="method" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives an argument of any type and converts it to a string in a reasonable
		format.

		For complete control of how numbers are converted, use`NativeStringTools.format`.</haxe_doc>
		</tostring>
		<ipairs public="1" params="K:V" set="method" static="1"><f a="t">
	<c path="lua.Table">
		<c path="ipairs.K"/>
		<c path="ipairs.V"/>
	</c>
	<c path="lua.IPairsResult">
		<c path="ipairs.K"/>
		<c path="ipairs.V"/>
	</c>
</f></ipairs>
		<pairs public="1" params="K:V" set="method" static="1"><f a="t">
	<c path="lua.Table">
		<c path="pairs.K"/>
		<c path="pairs.V"/>
	</c>
	<c path="lua.PairsResult">
		<c path="pairs.K"/>
		<c path="pairs.V"/>
	</c>
</f></pairs>
		<require public="1" set="method" static="1"><f a="module">
	<c path="String"/>
	<d/>
</f></require>
		<tonumber public="1" set="method" static="1">
			<f a="str:?base">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts the Lua value at the given acceptable base to `Int`.
		The Lua value must be a number or a string convertible to a number,
		otherwise `tonumber` returns `0`.</haxe_doc>
		</tonumber>
		<type public="1" set="method" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the Lua type of its only argument as a string.
		The possible results of this function are:

		* `"nil"` (a string, not the Lua value nil),
		* `"number"`
		* `"string"`
		* `"boolean"`
		* `"table"`
		* `"function"`
		* `"thread"`
		* `"userdata"`</haxe_doc>
		</type>
		<print public="1" set="method" static="1">
			<f a="v">
				<x path="haxe.extern.Rest"><d/></x>
				<x path="Void"/>
			</f>
			<haxe_doc>Receives any number of arguments, and prints their values to stdout,
		using the tostring function to convert them to strings.
		`print` is not intended for formatted output, but only as a quick way to show
		a value, typically for debugging.

		For complete control of how numbers are converted, use `NativeStringTools.format`.</haxe_doc>
		</print>
		<select public="1" set="method" static="1">
			<f a="n:rest">
				<d/>
				<x path="haxe.extern.Rest"><d/></x>
				<d/>
			</f>
			<haxe_doc>If `n` is a number, returns all arguments after argument number `n`.
		Otherwise, `n` must be the string `"#"`, and select returns the total
		number of extra arguments it received.</haxe_doc>
		</select>
		<rawget public="1" params="K:V" set="method" static="1">
			<f a="t:k">
				<c path="lua.Table">
					<c path="rawget.K"/>
					<c path="rawget.V"/>
				</c>
				<c path="rawget.K"/>
				<c path="rawget.V"/>
			</f>
			<haxe_doc>Gets the real value of `table[index]`, without invoking any metamethod.</haxe_doc>
		</rawget>
		<rawset public="1" params="K:V" set="method" static="1">
			<f a="t:k:v">
				<c path="lua.Table">
					<c path="rawset.K"/>
					<c path="rawset.V"/>
				</c>
				<c path="rawset.K"/>
				<c path="rawset.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the real value of `table[index]` to value, without invoking any metamethod.</haxe_doc>
		</rawset>
		<collectgarbage public="1" set="method" static="1">
			<f a="opt:?arg">
				<x path="lua.CollectGarbageOption"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>This function is a generic interface to the garbage collector.
		It performs different functions according to its first argument.</haxe_doc>
		</collectgarbage>
		<assert public="1" params="T" set="method" static="1">
			<f a="v:?message">
				<c path="assert.T"/>
				<c path="String"/>
				<c path="assert.T"/>
			</f>
			<haxe_doc>Issues an error when the value of its argument `v` is `false` (i.e., `null`
		or `false`) otherwise, returns all its arguments. message is an error message.
		when absent, it defaults to "assertion failed!"</haxe_doc>
		</assert>
		<dofile public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Loads and runs the given file.</haxe_doc>
		</dofile>
		<error public="1" set="method" static="1">
			<f a="message:?level">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Generates a Lua error. The error message (which can actually be a Lua value
		of any type) must be on the stack top. This function does a long jump,
		and therefore never returns.</haxe_doc>
		</error>
		<pcall public="1" set="method" static="1">
			<f a="f:rest">
				<x path="haxe.Function"/>
				<x path="haxe.extern.Rest"><d/></x>
				<c path="lua.PCallResult"/>
			</f>
			<haxe_doc>Calls a function in protected mode.</haxe_doc>
		</pcall>
		<rawequal public="1" set="method" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the two values in acceptable indices `v1` and `v2` are
		primitively equal (that is, without calling metamethods).
		Otherwise returns `false`.
		Also returns `false` if any of the indices are non valid.</haxe_doc>
		</rawequal>
		<xpcall public="1" set="method" static="1">
			<f a="f:msgh:rest">
				<x path="haxe.Function"/>
				<x path="haxe.Function"/>
				<x path="haxe.extern.Rest"><d/></x>
				<c path="lua.PCallResult"/>
			</f>
			<haxe_doc>This function is similar to pcall, except that you can set a new error
		handler.</haxe_doc>
		</xpcall>
		<loadfile public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<c path="lua.LoadResult"/>
			</f>
			<haxe_doc>Loads the chunk from file filename or from the standard input if no filename
		is given.</haxe_doc>
		</loadfile>
		<load public="1" set="method" static="1">
			<f a="code">
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<f a=""><c path="String"/></f>
				</x>
				<c path="lua.LoadResult"/>
			</f>
			<haxe_doc>Loads the chunk from given string.</haxe_doc>
		</load>
		<haxe_doc>These are all global static methods within Lua.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="lua.CollectGarbageOption" params="" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua">
		<this><c path="String"/></this>
		<haxe_doc>Enum for describing garbage collection options</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._Lua.CollectGarbageOption_Impl_" params="" file="/usr/share/haxe/std/lua/Lua.hx" private="1" module="lua.Lua"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.PCallResult" params="" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<status public="1"><x path="Bool"/></status>
		<value public="1"><d/></value>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.NextResult" params="K:V" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<index public="1"><c path="lua.NextResult.K"/></index>
		<value public="1"><c path="lua.NextResult.V"/></value>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.IPairsResult" params="K:V" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<next public="1"><f a=":">
	<c path="lua.Table">
		<c path="lua.IPairsResult.K"/>
		<c path="lua.IPairsResult.V"/>
	</c>
	<x path="Int"/>
	<c path="lua.NextResult">
		<x path="Int"/>
		<c path="lua.IPairsResult.V"/>
	</c>
</f></next>
		<table public="1"><c path="lua.Table">
	<c path="lua.IPairsResult.K"/>
	<c path="lua.IPairsResult.V"/>
</c></table>
		<index public="1"><x path="Int"/></index>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.PairsResult" params="K:V" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<next public="1"><f a=":">
	<c path="lua.Table">
		<c path="lua.PairsResult.K"/>
		<c path="lua.PairsResult.V"/>
	</c>
	<c path="lua.PairsResult.K"/>
	<c path="lua.NextResult">
		<c path="lua.PairsResult.K"/>
		<c path="lua.PairsResult.V"/>
	</c>
</f></next>
		<table public="1"><c path="lua.Table">
	<c path="lua.PairsResult.K"/>
	<c path="lua.PairsResult.V"/>
</c></table>
		<index public="1"><c path="lua.PairsResult.K"/></index>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.LoadResult" params="" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<func public="1"><x path="haxe.Function"/></func>
		<message public="1"><c path="String"/></message>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Math" params="" file="/usr/share/haxe/std/lua/Math.hx" extern="1">
		<pi public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>The value of pi.</haxe_doc>
		</pi>
		<huge public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>The value HUGE_VAL, a value larger than or equal to any other numerical value.</haxe_doc>
		</huge>
		<abs public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of x.</haxe_doc>
		</abs>
		<ceil public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer larger than or equal to x.</haxe_doc>
		</ceil>
		<floor public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer smaller than or equal to x.</haxe_doc>
		</floor>
		<acos public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc cosine of x (in radians).</haxe_doc>
		</acos>
		<asin public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc sine of x (in radians).</haxe_doc>
		</asin>
		<atan public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc tangent of x (in radians).</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result.
		(It also handles correctly the case of x being zero.)</haxe_doc>
		</atan2>
		<cos public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the cosine of x (assumed to be in radians).</haxe_doc>
		</cos>
		<cosh public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the hyperbolic cosine of x.</haxe_doc>
		</cosh>
		<sin public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the sine of x (assumed to be in radians).</haxe_doc>
		</sin>
		<sinh public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the hyperbolic sine of x.</haxe_doc>
		</sinh>
		<tan public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the tangent of x (assumed to be in radians)</haxe_doc>
		</tan>
		<tanh public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the hyperbolic tangent of x.</haxe_doc>
		</tanh>
		<rad public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the angle x (given in degrees) in radians.</haxe_doc>
		</rad>
		<modf public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns two numbers, the integral part of x and the fractional part of x.</haxe_doc>
		</modf>
		<fmod public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the remainder of the division of x by y that rounds the quotient towards zero.</haxe_doc>
		</fmod>
		<pow public="1" set="method" static="1">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns y-th power of x.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of x.</haxe_doc>
		</sqrt>
		<exp public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the value e^x.</haxe_doc>
		</exp>
		<frexp public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<c path="lua.MathFrexpResult"/>
			</f>
			<haxe_doc>Returns m and e such that x = m2^e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).</haxe_doc>
		</frexp>
		<ldexp public="1" set="method" static="1">
			<f a="m:e">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns m2^e (e should be an integer).</haxe_doc>
		</ldexp>
		<log public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of x.</haxe_doc>
		</log>
		<log10 public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the base-10 logarithm of x.</haxe_doc>
		</log10>
		<max public="1" set="method" static="1">
			<f a="x:numbers">
				<x path="Float"/>
				<x path="haxe.extern.Rest"><x path="Float"/></x>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the maximum value among its arguments.</haxe_doc>
		</max>
		<min public="1" set="method" static="1">
			<f a="x:numbers">
				<x path="Float"/>
				<x path="haxe.extern.Rest"><x path="Float"/></x>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the minimum value among its arguments.</haxe_doc>
		</min>
		<deg public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the angle x (given in radians) in degrees.</haxe_doc>
		</deg>
		<random public="1" set="method" static="1">
			<f a="?m:?n">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>This function is an interface to the simple pseudo-random generator function rand provided by ANSI C.
		(No guarantees can be given for its statistical properties.)

		When called without arguments, returns a uniform pseudo-random real number in the range [0,1).
		When called with an integer number `m`, returns a uniform pseudo-random integer in the range [1, m].
		When called with two integer numbers `m` and `n`, returns a uniform pseudo-random integer in the range [m, n].</haxe_doc>
		</random>
		<randomseed public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Sets `x` as the "seed" for the pseudo-random generator: equal seeds produce equal sequences of numbers.</haxe_doc>
		</randomseed>
		<haxe_doc>Mathematical Functions</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.math"</e></m>
		</meta>
	</class>
	<class path="lua.MathFrexpResult" params="" file="/usr/share/haxe/std/lua/Math.hx" module="lua.Math" extern="1">
		<m public="1"><x path="Float"/></m>
		<e public="1"><x path="Int"/></e>
		<haxe_doc>The return value of `Math.frexp`.</haxe_doc>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<abstract path="lua.NativeIterator" params="T" file="/usr/share/haxe/std/lua/NativeIterator.hx">
		<from><icast field="fromF"><f a=""><c path="fromF.T"/></f></icast></from>
		<this><f a=""><c path="lua.NativeIterator.T"/></f></this>
		<to><icast field="toIterator"><a>
	<next set="method">
		<f a=""><c path="lua.NativeIterator.T"/></f>
		<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
	</next>
	<hasNext set="method">
		<f a=""><x path="Bool"/></f>
		<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
	</hasNext>
</a></icast></to>
		<haxe_doc>This abstract enables easy conversion from basic lua iterators
	(i.e., a function that is called until it returns null), and
	Haxe iterators, which provide a next/hasNext interface.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="lua._NativeIterator.NativeIterator_Impl_" params="" file="/usr/share/haxe/std/lua/NativeIterator.hx" private="1" module="lua.NativeIterator"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="lua.StringFind" params="" file="/usr/share/haxe/std/lua/NativeStringTools.hx" module="lua.NativeStringTools" extern="1">
		<begin public="1"><x path="Int"/></begin>
		<end public="1"><x path="Int"/></end>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.StringSub" params="" file="/usr/share/haxe/std/lua/NativeStringTools.hx" module="lua.NativeStringTools" extern="1">
		<match public="1"><c path="String"/></match>
		<count public="1"><x path="Int"/></count>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Os" params="" file="/usr/share/haxe/std/lua/Os.hx" extern="1">
		<clock public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns an approximation of the amount in seconds of CPU time used by the
		program.</haxe_doc>
		</clock>
		<date public="1" set="method" static="1">
			<f a=""><t path="lua.DateType"/></f>
			<overloads>
				<date public="1" set="method"><f a="format:time">
	<c path="String"/>
	<t path="lua.Time"/>
	<t path="lua.DateType"/>
</f></date>
				<date public="1" set="method"><f a="format">
	<c path="String"/>
	<t path="lua.DateType"/>
</f></date>
			</overloads>
		</date>
		<difftime public="1" set="method" static="1">
			<f a="t2:t1">
				<t path="lua.Time"/>
				<t path="lua.Time"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the number of seconds from time `t1` to time `t2`.
		In POSIX, Windows, and some other systems, this value is exactly `t2-t1`.</haxe_doc>
		</difftime>
		<execute public="1" set="method" static="1">
			<f a="?command">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>This function is equivalent to the C function system. It passes command to
		be executed by an operating system shell. It returns a status code,
		which is system-dependent. If command is absent, then it returns
		nonzero if a shell is available and zero otherwise.</haxe_doc>
		</execute>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Calls the C function exit, with an optional code, to terminate the host program.
		The default value for code is the success code.</haxe_doc>
		</exit>
		<getenv public="1" set="method" static="1">
			<f a="varname">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the process environment variable `varname`, or `null`
		if the variable is not defined.</haxe_doc>
		</getenv>
		<remove public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<c path="lua.OsSuccess"/>
			</f>
			<haxe_doc>Deletes the file or directory with the given name.
		Directories must be empty to be removed.</haxe_doc>
		</remove>
		<rename public="1" set="method" static="1">
			<f a="oldname:newname">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.OsSuccess"/>
			</f>
			<haxe_doc>Renames file or directory named `oldname` to `newname`.</haxe_doc>
		</rename>
		<setlocale public="1" set="method" static="1">
			<f a="locale:?category">
				<c path="String"/>
				<x path="lua.LocaleCategory"/>
				<c path="String"/>
			</f>
			<haxe_doc>Sets the current locale of the program.</haxe_doc>
		</setlocale>
		<time public="1" set="method" static="1">
			<f a="?arg">
				<t path="lua.TimeParam"/>
				<t path="lua.Time"/>
			</f>
			<haxe_doc>Returns the current time when called without arguments, or a time
		representing the date and time specified by the given table.

		The returned value is a number, whose meaning depends on your system.
		In POSIX, Windows, and some other systems, this number counts the number
		of seconds since some given start time (the "epoch").
		In other systems, the meaning is not specified, and the number returned
		by time can be used only as an argument to date and difftime.</haxe_doc>
		</time>
		<tmpname public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string with a file name that can be used for a temporary file.
		The file must be explicitly opened before its use and explicitly removed
		when no longer needed.

		When possible, you may prefer to use `Io.tmpfile`, which automatically
		removes the file when the program ends.</haxe_doc>
		</tmpname>
		<haxe_doc>Operating System Facilities.</haxe_doc>
		<meta><m n=":native"><e>"_G.os"</e></m></meta>
	</class>
	<typedef path="lua.TimeParam" params="" file="/usr/share/haxe/std/lua/Os.hx" module="lua.Os">
		<a>
			<year><x path="Int"/></year>
			<sec>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</sec>
			<month><x path="Int"/></month>
			<min>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</min>
			<isdst>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</isdst>
			<hour>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</hour>
			<day><x path="Int"/></day>
		</a>
		<haxe_doc>A typedef that matches the date parameter `Os.time()` will accept.</haxe_doc>
	</typedef>
	<typedef path="lua.DateType" params="" file="/usr/share/haxe/std/lua/Os.hx" module="lua.Os">
		<a>
			<year><x path="Int"/></year>
			<yday><x path="Int"/></yday>
			<wday><x path="Int"/></wday>
			<sec><x path="Int"/></sec>
			<month><x path="Int"/></month>
			<min><x path="Int"/></min>
			<isdst><x path="Bool"/></isdst>
			<hour><x path="Int"/></hour>
			<day><x path="Int"/></day>
		</a>
		<haxe_doc>A typedef that describes the output of `Os.date()`.</haxe_doc>
	</typedef>
	<class path="lua.OsExecute" params="" file="/usr/share/haxe/std/lua/Os.hx" module="lua.Os" extern="1">
		<success public="1"><x path="Bool"/></success>
		<output public="1"><c path="String"/></output>
		<status public="1"><x path="Int"/></status>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.OsSuccess" params="" file="/usr/share/haxe/std/lua/Os.hx" module="lua.Os" extern="1">
		<success public="1"><x path="Bool"/></success>
		<message public="1"><c path="String"/></message>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Result" params="T" file="/usr/share/haxe/std/lua/Result.hx" extern="1">
		<result public="1"><c path="lua.Result.T"/></result>
		<message public="1"><c path="String"/></message>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<typedef path="lua.AnyTable" params="" file="/usr/share/haxe/std/lua/Table.hx" module="lua.Table"><c path="lua.Table">
	<d/>
	<d/>
</c></typedef>
	<class path="lua.TableTools" params="" file="/usr/share/haxe/std/lua/TableTools.hx" extern="1">
		<pack public="1" params="T" set="method" static="1"><f a="args">
	<x path="haxe.extern.Rest"><c path="pack.T"/></x>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="pack.T"/>
	</c>
</f></pack>
		<unpack public="1" params="Int:V" set="method" static="1"><f a="args:?min:?max">
	<c path="lua.Table">
		<c path="unpack.Int"/>
		<c path="unpack.V"/>
	</c>
	<c path="unpack.Int"/>
	<c path="unpack.Int"/>
	<d/>
</f></unpack>
		<maxn public="1" set="method" static="1"><f a="t">
	<t path="lua.AnyTable"/>
	<x path="Int"/>
</f></maxn>
		<haxe_doc>This library provides generic functions for table manipulation.</haxe_doc>
		<meta><m n=":native"><e>"_hx_table"</e></m></meta>
	</class>
	<typedef path="lua.Time" params="" file="/usr/share/haxe/std/lua/Time.hx"><x path="Float"/></typedef>
	<class path="lua.lib.luasocket.Socket" params="" file="/usr/share/haxe/std/lua/lib/luasocket/Socket.hx" extern="1">
		<_DEBUG public="1" static="1"><x path="Bool"/></_DEBUG>
		<_VERSION public="1" static="1"><c path="String"/></_VERSION>
		<tcp public="1" set="method" static="1"><f a=""><c path="lua.Result"><c path="lua.lib.luasocket.socket.TcpMaster"/></c></f></tcp>
		<bind public="1" set="method" static="1"><f a="address:port:?backlog">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lua.Result"><c path="lua.lib.luasocket.socket.TcpServer"/></c>
</f></bind>
		<connect public="1" set="method" static="1"><f a="address:port:?locaddr:?locport">
	<c path="String"/>
	<x path="Int"/>
	<c path="String"/>
	<x path="Int"/>
	<c path="lua.Result"><c path="lua.lib.luasocket.socket.TcpClient"/></c>
</f></connect>
		<gettime public="1" set="method" static="1"><f a=""><x path="Float"/></f></gettime>
		<select public="1" set="method" static="1"><f a="recvt:sendt:?timeout">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="lua.lib.luasocket.Socket"/>
	</c>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="lua.lib.luasocket.Socket"/>
	</c>
	<x path="Float"/>
	<c path="lua.lib.luasocket.socket.SelectResult"/>
</f></select>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<getsockname public="1" set="method"><f a=""><c path="lua.lib.luasocket.socket.AddrInfo"/></f></getsockname>
		<settimeout public="1" set="method"><f a="value:?mode">
	<x path="Float"/>
	<x path="lua.lib.luasocket.socket.TimeoutMode"/>
	<x path="Void"/>
</f></settimeout>
		<meta><m n=":luaRequire"><e>"socket"</e></m></meta>
	</class>
	<class path="lua.lib.luasocket.socket.AddrInfo" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/AddrInfo.hx" extern="1">
		<address public="1"><c path="String"/></address>
		<port public="1"><c path="String"/></port>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<abstract path="lua.lib.luasocket.socket.ReceivePattern" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/ReceivePattern.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua.lib.luasocket.socket._ReceivePattern.ReceivePattern_Impl_" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/ReceivePattern.hx" private="1" module="lua.lib.luasocket.socket.ReceivePattern"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.lib.luasocket.socket.SelectResult" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/SelectResult.hx" extern="1">
		<read public="1"><c path="lua.Table">
	<x path="Int"/>
	<c path="lua.lib.luasocket.Socket"/>
</c></read>
		<write public="1"><c path="lua.Table">
	<x path="Int"/>
	<c path="lua.lib.luasocket.Socket"/>
</c></write>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<abstract path="lua.lib.luasocket.socket.ShutdownMode" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/ShutdownMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua.lib.luasocket.socket._ShutdownMode.ShutdownMode_Impl_" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/ShutdownMode.hx" private="1" module="lua.lib.luasocket.socket.ShutdownMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.lib.luasocket.socket.TcpClient" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/TcpClient.hx" extern="1">
		<extends path="lua.lib.luasocket.Socket"/>
		<getpeername public="1" set="method"><f a=""><c path="lua.lib.luasocket.socket.AddrInfo"/></f></getpeername>
		<receive public="1" set="method"><f a="pattern:?prefix">
	<x path="haxe.extern.EitherType">
		<x path="lua.lib.luasocket.socket.ReceivePattern"/>
		<x path="Int"/>
	</x>
	<c path="String"/>
	<c path="lua.Result"><c path="String"/></c>
</f></receive>
		<send public="1" set="method"><f a="data:?i:?j">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
	<c path="lua.Result"><x path="Int"/></c>
</f></send>
		<shutdown public="1" set="method"><f a="mode">
	<x path="lua.lib.luasocket.socket.ShutdownMode"/>
	<c path="lua.Result"><x path="Int"/></c>
</f></shutdown>
		<settimeout public="1" set="method" override="1"><f a="value:?mode">
	<x path="Float"/>
	<x path="lua.lib.luasocket.socket.TimeoutMode"/>
	<x path="Void"/>
</f></settimeout>
		<setoption public="1" set="method"><f a="option:value">
	<x path="lua.lib.luasocket.socket.TcpOption"/>
	<x path="haxe.extern.EitherType">
		<x path="Bool"/>
		<a>
			<timeout><x path="Float"/></timeout>
			<on><x path="Bool"/></on>
		</a>
	</x>
	<x path="Void"/>
</f></setoption>
	</class>
	<class path="lua.lib.luasocket.socket.TcpMaster" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/TcpMaster.hx" extern="1">
		<extends path="lua.lib.luasocket.Socket"/>
		<listen public="1" set="method"><f a="backlog">
	<x path="Int"/>
	<x path="Void"/>
</f></listen>
		<connect public="1" set="method"><f a="address:port">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></connect>
		<bind public="1" set="method"><f a="address:port">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></bind>
	</class>
	<abstract path="lua.lib.luasocket.socket.TcpOption" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/TcpOption.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua.lib.luasocket.socket._TcpOption.TcpOption_Impl_" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/TcpOption.hx" private="1" module="lua.lib.luasocket.socket.TcpOption"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.lib.luasocket.socket.TcpServer" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/TcpServer.hx" extern="1">
		<extends path="lua.lib.luasocket.Socket"/>
		<accept public="1" set="method"><f a=""><c path="lua.Result"><c path="lua.lib.luasocket.socket.TcpClient"/></c></f></accept>
		<settimeout public="1" set="method" override="1"><f a="value:?mode">
	<x path="Int"/>
	<x path="lua.lib.luasocket.socket.TimeoutMode"/>
	<x path="Void"/>
</f></settimeout>
		<setoption public="1" set="method"><f a="option:value">
	<c path="String"/>
	<x path="lua.lib.luasocket.socket.TcpOption"/>
	<x path="Void"/>
</f></setoption>
	</class>
	<abstract path="lua.lib.luasocket.socket.TimeoutMode" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/TimeoutMode.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua.lib.luasocket.socket._TimeoutMode.TimeoutMode_Impl_" params="" file="/usr/share/haxe/std/lua/lib/luasocket/socket/TimeoutMode.hx" private="1" module="lua.lib.luasocket.socket.TimeoutMode"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.lib.luautf8.StringFind" params="" file="/usr/share/haxe/std/lua/lib/luautf8/Utf8.hx" module="lua.lib.luautf8.Utf8" extern="1">
		<begin public="1"><x path="Int"/></begin>
		<end public="1"><x path="Int"/></end>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luautf8.StringSub" params="" file="/usr/share/haxe/std/lua/lib/luautf8/Utf8.hx" module="lua.lib.luautf8.Utf8" extern="1">
		<match public="1"><c path="String"/></match>
		<count public="1"><x path="Int"/></count>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luautf8.StringCodePoint" params="" file="/usr/share/haxe/std/lua/lib/luautf8/Utf8.hx" module="lua.lib.luautf8.Utf8" extern="1">
		<position public="1"><x path="Int"/></position>
		<codepoint public="1"><x path="Int"/></codepoint>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luv.Handle" params="" file="/usr/share/haxe/std/lua/lib/luv/Handle.hx" extern="1">
		<is_active public="1" set="method"><f a=""><x path="Bool"/></f></is_active>
		<is_closing public="1" set="method"><f a=""><x path="Bool"/></f></is_closing>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<ref public="1" set="method"><f a=""><x path="Void"/></f></ref>
		<unref public="1" set="method"><f a=""><x path="Void"/></f></unref>
		<has_ref public="1" set="method"><f a=""><x path="Bool"/></f></has_ref>
		<send_buffer_size public="1" set="method"><f a="size">
	<x path="Int"/>
	<x path="Int"/>
</f></send_buffer_size>
		<recv_buffer_size public="1" set="method"><f a="size">
	<x path="Int"/>
	<x path="Int"/>
</f></recv_buffer_size>
		<fileno public="1" set="method"><f a=""><x path="Int"/></f></fileno>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Loop" params="" file="/usr/share/haxe/std/lua/lib/luv/Loop.hx" extern="1">
		<loop_close public="1" set="method" static="1"><f a=""><x path="Bool"/></f></loop_close>
		<run public="1" set="method" static="1"><f a="?mode">
	<c path="String"/>
	<x path="Bool"/>
</f></run>
		<loop_alive public="1" set="method" static="1"><f a=""><x path="Bool"/></f></loop_alive>
		<stop public="1" set="method" static="1"><f a=""><x path="Void"/></f></stop>
		<backend_fd public="1" set="method" static="1"><f a=""><x path="Int"/></f></backend_fd>
		<backend_timeout public="1" set="method" static="1"><f a=""><x path="Int"/></f></backend_timeout>
		<now public="1" set="method" static="1"><f a=""><x path="Int"/></f></now>
		<update_time public="1" set="method" static="1"><f a=""><x path="Void"/></f></update_time>
		<walk public="1" set="method" static="1"><f a="cb">
	<f a="">
		<c path="lua.lib.luv.Handle"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></walk>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Misc" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" extern="1">
		<chdir public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></chdir>
		<os_homedir public="1" set="method" static="1"><f a=""><c path="String"/></f></os_homedir>
		<os_tmpdir public="1" set="method" static="1"><f a=""><c path="String"/></f></os_tmpdir>
		<os_get_passwd public="1" set="method" static="1"><f a=""><c path="String"/></f></os_get_passwd>
		<cpu_info public="1" set="method" static="1"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<t path="lua.lib.luv.CpuInfo"/>
</c></f></cpu_info>
		<cwd public="1" set="method" static="1"><f a=""><c path="String"/></f></cwd>
		<exepath public="1" set="method" static="1"><f a=""><c path="String"/></f></exepath>
		<get_process_title public="1" set="method" static="1"><f a=""><c path="String"/></f></get_process_title>
		<get_total_memory public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_total_memory>
		<get_free_memory public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_free_memory>
		<getpid public="1" set="method" static="1"><f a=""><x path="Int"/></f></getpid>
		<os_getenv public="1" set="method" static="1"><f a="env">
	<c path="String"/>
	<c path="String"/>
</f></os_getenv>
		<os_setenv public="1" set="method" static="1"><f a="env:value">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></os_setenv>
		<getuid public="1" set="method" static="1"><f a=""><x path="Int"/></f></getuid>
		<setuid public="1" set="method" static="1"><f a="from:to">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></setuid>
		<getgid public="1" set="method" static="1"><f a=""><x path="Int"/></f></getgid>
		<setgid public="1" set="method" static="1"><f a="from:to">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setgid>
		<getrusage public="1" set="method" static="1"><f a=""><t path="lua.lib.luv.ResourceUsage"/></f></getrusage>
		<guess_handle public="1" set="method" static="1"><f a="handle">
	<x path="Int"/>
	<c path="String"/>
</f></guess_handle>
		<hrtime public="1" set="method" static="1"><f a=""><x path="Float"/></f></hrtime>
		<loadavg public="1" set="method" static="1"><f a=""><x path="Float"/></f></loadavg>
		<resident_set_memory public="1" set="method" static="1"><f a=""><x path="Int"/></f></resident_set_memory>
		<set_process_title public="1" set="method" static="1"><f a="title">
	<c path="String"/>
	<x path="Bool"/>
</f></set_process_title>
		<uptime public="1" set="method" static="1"><f a=""><x path="Int"/></f></uptime>
		<version public="1" set="method" static="1"><f a=""><x path="Int"/></f></version>
		<version_string public="1" set="method" static="1"><f a=""><c path="String"/></f></version_string>
		<print_all_handles public="1" set="method" static="1"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></f></print_all_handles>
		<print_active_handles public="1" set="method" static="1"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></f></print_active_handles>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.CpuInfo" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<times><t path="lua.lib.luv.CpuTimes"/></times>
	<speed><x path="Int"/></speed>
	<model><c path="String"/></model>
</a></typedef>
	<typedef path="lua.lib.luv.CpuTimes" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<user><x path="Int"/></user>
	<sys><x path="Int"/></sys>
	<irq><x path="Int"/></irq>
	<idle><x path="Int"/></idle>
</a></typedef>
	<typedef path="lua.lib.luv.ResourceUsage" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<utime><t path="lua.lib.luv.MicroTimeStamp"/></utime>
	<stime><t path="lua.lib.luv.MicroTimeStamp"/></stime>
	<oublock><x path="Int"/></oublock>
	<nvcsw><x path="Int"/></nvcsw>
	<nswap><x path="Int"/></nswap>
	<nsignals><x path="Int"/></nsignals>
	<nivcsw><x path="Int"/></nivcsw>
	<msgsnd><x path="Int"/></msgsnd>
	<msgrcv><x path="Int"/></msgrcv>
	<minflt><x path="Int"/></minflt>
	<maxrss><x path="Int"/></maxrss>
	<majflt><x path="Int"/></majflt>
	<ixrss><x path="Int"/></ixrss>
	<isrss><x path="Int"/></isrss>
	<inblock><x path="Int"/></inblock>
	<idrss><x path="Int"/></idrss>
</a></typedef>
	<typedef path="lua.lib.luv.MicroTimeStamp" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<usec><x path="Int"/></usec>
	<sec><x path="Int"/></sec>
</a></typedef>
	<class path="lua.lib.luv.Stream" params="" file="/usr/share/haxe/std/lua/lib/luv/Stream.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<shutdown public="1" set="method"><f a="?cb">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
</f></shutdown>
		<listen public="1" set="method"><f a="backlog:cb">
	<x path="Int"/>
	<f a=":">
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></listen>
		<accept public="1" set="method"><f a="client_stream">
	<c path="lua.lib.luv.Stream"/>
	<x path="Int"/>
</f></accept>
		<read_start public="1" set="method"><f a="cb">
	<f a=":">
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></read_start>
		<read_stop public="1" set="method"><f a=""><x path="Int"/></f></read_stop>
		<write public="1" set="method"><f a="data:?cb">
	<t path="lua.lib.luv.StreamData"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></write>
		<write2 public="1" set="method"><f a="data:send_handle:cb">
	<t path="lua.lib.luv.StreamData"/>
	<c path="lua.lib.luv.net.Tcp"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></write2>
		<try_write public="1" set="method"><f a="data">
	<t path="lua.lib.luv.StreamData"/>
	<x path="Int"/>
</f></try_write>
		<is_readable public="1" set="method"><f a=""><x path="Bool"/></f></is_readable>
		<is_writable public="1" set="method"><f a=""><x path="Bool"/></f></is_writable>
		<set_blocking public="1" set="method"><f a="blocking">
	<x path="Bool"/>
	<x path="Int"/>
</f></set_blocking>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Pipe" params="" file="/usr/share/haxe/std/lua/lib/luv/Pipe.hx" extern="1">
		<extends path="lua.lib.luv.Stream"/>
		<new_pipe public="1" set="method" static="1"><f a="ipc">
	<x path="Bool"/>
	<c path="lua.lib.luv.Pipe"/>
</f></new_pipe>
		<open public="1" set="method"><f a="file">
	<x path="haxe.extern.EitherType">
		<c path="lua.FileHandle"/>
		<c path="lua.lib.luv.Handle"/>
	</x>
	<c path="lua.lib.luv.Pipe"/>
</f></open>
		<bind public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="lua.lib.luv.Pipe"/>
</f></bind>
		<connect public="1" set="method"><f a="name:cb">
	<c path="String"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></connect>
		<getsockname public="1" set="method"><f a=""><c path="String"/></f></getsockname>
		<pending_instances public="1" set="method"><f a="count">
	<x path="Int"/>
	<x path="Int"/>
</f></pending_instances>
		<pending_count public="1" set="method"><f a=""><x path="Int"/></f></pending_count>
		<pending_type public="1" set="method"><f a=""><x path="Int"/></f></pending_type>
		<new public="1" set="method">
			<f a="ipc">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"new_pipe"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Process" params="" file="/usr/share/haxe/std/lua/lib/luv/Process.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<disable_stdio_inheritance public="1" set="method" static="1"><f a=""><x path="Void"/></f></disable_stdio_inheritance>
		<spawn public="1" set="method" static="1"><f a="path:options:cb">
	<c path="String"/>
	<d/>
	<f a=":">
		<x path="Int"/>
		<c path="lua.lib.luv.Signal"/>
		<x path="Void"/>
	</f>
	<c path="lua.lib.luv.LuvSpawn"/>
</f></spawn>
		<kill public="1" set="method"><f a="sig">
	<c path="String"/>
	<x path="Int"/>
</f></kill>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.ProcessOptions" params="" file="/usr/share/haxe/std/lua/lib/luv/Process.hx" module="lua.lib.luv.Process"><a>
	<stdio><c path="lua.Table">
	<x path="Int"/>
	<c path="lua.lib.luv.Pipe"/>
</c></stdio>
	<args><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></args>
</a></typedef>
	<class path="lua.lib.luv.LuvSpawn" params="" file="/usr/share/haxe/std/lua/lib/luv/Process.hx" module="lua.lib.luv.Process" extern="1">
		<handle public="1"><c path="lua.lib.luv.Process"/></handle>
		<pid public="1"><x path="Int"/></pid>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luv.Request" params="" file="/usr/share/haxe/std/lua/lib/luv/Request.hx" extern="1">
		<cancel public="1" set="method"><f a=""><x path="Bool"/></f></cancel>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Signal" params="" file="/usr/share/haxe/std/lua/lib/luv/Signal.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<new_signal public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Signal"/></f></new_signal>
		<start public="1" set="method"><f a="sigtype:?cb">
	<x path="haxe.extern.EitherType">
		<x path="Int"/>
		<c path="String"/>
	</x>
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
</f></start>
		<stop public="1" set="method"><f a=""><x path="Int"/></f></stop>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_signal"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.StreamData" params="" file="/usr/share/haxe/std/lua/lib/luv/Stream.hx" module="lua.lib.luv.Stream"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</x></typedef>
	<class path="lua.lib.luv.Thread" params="" file="/usr/share/haxe/std/lua/lib/luv/Thread.hx" extern="1">
		<new_thread public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Timer"/></f></new_thread>
		<self public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Thread"/></f></self>
		<sleep public="1" set="method" static="1"><f a="msec">
	<x path="Int"/>
	<x path="Void"/>
</f></sleep>
		<equal public="1" set="method"><f a="t">
	<c path="lua.lib.luv.Thread"/>
	<x path="Bool"/>
</f></equal>
		<join public="1" set="method"><f a="t">
	<c path="lua.lib.luv.Thread"/>
	<x path="Bool"/>
</f></join>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_thread"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Timer" params="" file="/usr/share/haxe/std/lua/lib/luv/Timer.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<new_timer public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Timer"/></f></new_timer>
		<start public="1" set="method"><f a="timeout:repeat:cb">
	<x path="Int"/>
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
</f></start>
		<stop public="1" set="method"><f a=""><x path="Int"/></f></stop>
		<again public="1" set="method"><f a=""><x path="Int"/></f></again>
		<set_repeat public="1" set="method"><f a="repeat">
	<x path="Int"/>
	<x path="Void"/>
</f></set_repeat>
		<get_repeat public="1" set="method"><f a=""><x path="Int"/></f></get_repeat>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_timer"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.fs.FileDescriptor" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileDescriptor.hx"><x path="Int"/></typedef>
	<class path="lua.lib.luv.fs.FileSystem" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" extern="1">
		<close public="1" set="method" static="1">
			<f a="file">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_close"</e></m></meta>
			<overloads><fs_close public="1" set="method">
	<f a="file:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_close"</e></m></meta>
</fs_close></overloads>
		</close>
		<open public="1" set="method" static="1">
			<f a="path:flags:mode">
				<c path="String"/>
				<x path="lua.lib.luv.fs.Open"/>
				<x path="Int"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.FileDescriptor"/></c>
			</f>
			<meta><m n=":native"><e>"fs_open"</e></m></meta>
			<overloads><fs_open public="1" set="method">
	<f a="path:flags:mode:?cb">
		<c path="String"/>
		<x path="lua.lib.luv.fs.Open"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<t path="lua.lib.luv.fs.FileDescriptor"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_open"</e></m></meta>
</fs_open></overloads>
		</open>
		<read public="1" set="method" static="1">
			<f a="file:len:offset">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.Result"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"fs_read"</e></m></meta>
			<overloads><fs_read public="1" set="method">
	<f a="file:len:offset:?cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_read"</e></m></meta>
</fs_read></overloads>
		</read>
		<unlink public="1" set="method" static="1">
			<f a="file:content">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="String"/>
				<c path="lua.Result"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"fs_unlink"</e></m></meta>
			<overloads><fs_unlink public="1" set="method">
	<f a="file:?cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_unlink"</e></m></meta>
</fs_unlink></overloads>
		</unlink>
		<write public="1" set="method" static="1">
			<f a="file:content:offset">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_write"</e></m></meta>
			<overloads><fs_write public="1" set="method">
	<f a="file:content:offset:?cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<x path="Int"/>
	</f>
	<meta><m n=":native"><e>"fs_write"</e></m></meta>
</fs_write></overloads>
		</write>
		<mkdir public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_mkdir"</e></m></meta>
			<overloads><fs_mkdir public="1" set="method">
	<f a="path:mode:cb">
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_mkdir"</e></m></meta>
</fs_mkdir></overloads>
		</mkdir>
		<mkdtemp public="1" set="method" static="1">
			<f a="data">
				<c path="String"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_mkdtemp"</e></m></meta>
			<overloads><fs_mkdtemp public="1" set="method">
	<f a="data:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_mkdtemp"</e></m></meta>
</fs_mkdtemp></overloads>
		</mkdtemp>
		<rmdir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.Result"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"fs_rmdir"</e></m></meta>
			<overloads><fs_rmdir public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_rmdir"</e></m></meta>
</fs_rmdir></overloads>
		</rmdir>
		<scandir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.lib.luv.fs.ScanDirMarker"/>
			</f>
			<meta><m n=":native"><e>"fs_scandir"</e></m></meta>
			<overloads><fs_scandir public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_scandir"</e></m></meta>
</fs_scandir></overloads>
		</scandir>
		<scandir_next public="1" set="method" static="1">
			<f a="scandir">
				<c path="lua.lib.luv.fs.ScanDirMarker"/>
				<c path="lua.lib.luv.fs.ScandirNext"/>
			</f>
			<meta><m n=":native"><e>"fs_scandir_next"</e></m></meta>
		</scandir_next>
		<stat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.Stat"/></c>
			</f>
			<meta><m n=":native"><e>"fs_stat"</e></m></meta>
			<overloads><fs_stat public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<t path="lua.lib.luv.fs.Stat"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_stat"</e></m></meta>
</fs_stat></overloads>
		</stat>
		<fstat public="1" set="method" static="1">
			<f a="descriptor">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.Stat"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fstat"</e></m></meta>
			<overloads><fs_fstat public="1" set="method">
	<f a="descriptor:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<t path="lua.lib.luv.fs.Stat"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fstat"</e></m></meta>
</fs_fstat></overloads>
		</fstat>
		<lstat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.Stat"/></c>
			</f>
			<meta><m n=":native"><e>"fs_lstat"</e></m></meta>
			<overloads><fs_lstat public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<t path="lua.lib.luv.fs.Stat"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_lstat"</e></m></meta>
</fs_lstat></overloads>
		</lstat>
		<rename public="1" set="method" static="1">
			<f a="path:newpath">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_rename"</e></m></meta>
			<overloads><fs_rename public="1" set="method">
	<f a="path:newpath:cb">
		<c path="String"/>
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_rename"</e></m></meta>
</fs_rename></overloads>
		</rename>
		<fsync public="1" set="method" static="1">
			<f a="descriptor">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fsync"</e></m></meta>
			<overloads><fs_fsync public="1" set="method">
	<f a="descriptor:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fsync"</e></m></meta>
</fs_fsync></overloads>
		</fsync>
		<fdatasync public="1" set="method" static="1">
			<f a="descriptor">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fdatasync"</e></m></meta>
			<overloads><fs_fdatasync public="1" set="method">
	<f a="descriptor:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fdatasync"</e></m></meta>
</fs_fdatasync></overloads>
		</fdatasync>
		<ftruncate public="1" set="method" static="1">
			<f a="descriptor:offset">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_ftruncate"</e></m></meta>
			<overloads><fs_ftruncate public="1" set="method">
	<f a="descriptor:offset:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_ftruncate"</e></m></meta>
</fs_ftruncate></overloads>
		</ftruncate>
		<sendfile public="1" set="method" static="1">
			<f a="fin:fout">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"fs_sendfile"</e></m></meta>
			<overloads><fs_sendfile public="1" set="method">
	<f a="fin:fout:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_sendfile"</e></m></meta>
</fs_sendfile></overloads>
		</sendfile>
		<access public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_access"</e></m></meta>
			<overloads><fs_access public="1" set="method">
	<f a="path:mode:cb">
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_access"</e></m></meta>
</fs_access></overloads>
		</access>
		<chmod public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_chmod"</e></m></meta>
			<overloads><fs_chmod public="1" set="method">
	<f a="path:mode:cb">
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_chmod"</e></m></meta>
</fs_chmod></overloads>
		</chmod>
		<fchmod public="1" set="method" static="1">
			<f a="descriptor:mode">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fchmod"</e></m></meta>
			<overloads><fs_fchmod public="1" set="method">
	<f a="descriptor:mode:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fchmod"</e></m></meta>
</fs_fchmod></overloads>
		</fchmod>
		<futime public="1" set="method" static="1">
			<f a="descriptor:actime:modtime">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_futime"</e></m></meta>
			<overloads><fs_futime public="1" set="method">
	<f a="descriptor:actime:modtime:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_futime"</e></m></meta>
</fs_futime></overloads>
		</futime>
		<utime public="1" set="method" static="1">
			<f a="path:actime:modtime">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_utime"</e></m></meta>
			<overloads><fs_utime public="1" set="method">
	<f a="path:actime:modtime:cb">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_utime"</e></m></meta>
</fs_utime></overloads>
		</utime>
		<link public="1" set="method" static="1">
			<f a="oldpath:newpath">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_link"</e></m></meta>
			<overloads><fs_link public="1" set="method">
	<f a="oldpath:newpath:cb">
		<c path="String"/>
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_link"</e></m></meta>
</fs_link></overloads>
		</link>
		<symlink public="1" set="method" static="1">
			<f a="oldpath:newpath:flags">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_symlink"</e></m></meta>
			<overloads><fs_symlink public="1" set="method">
	<f a="oldpath:newpath:flags:cb">
		<c path="String"/>
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_symlink"</e></m></meta>
</fs_symlink></overloads>
		</symlink>
		<realpath public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"fs_realpath"</e></m></meta>
			<overloads><fs_realpath public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_realpath"</e></m></meta>
</fs_realpath></overloads>
		</realpath>
		<chown public="1" set="method" static="1">
			<f a="path:uid:gid">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_chown"</e></m></meta>
			<overloads><fs_chown public="1" set="method">
	<f a="path:uid:gid:cb">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_chown"</e></m></meta>
</fs_chown></overloads>
		</chown>
		<fchown public="1" set="method" static="1">
			<f a="descriptor:uid:gid">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_fchown"</e></m></meta>
			<overloads><fs_fchown public="1" set="method">
	<f a="descriptor:uid:gid:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fchown"</e></m></meta>
</fs_fchown></overloads>
		</fchown>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.fs.ScanDirMarker" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem" extern="1"/>
	<class path="lua.lib.luv.fs.ScandirNext" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem" extern="1">
		<name public="1"><c path="String"/></name>
		<type public="1"><c path="String"/></type>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<typedef path="lua.lib.luv.fs.Stat" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<uid><x path="Int"/></uid>
	<type><c path="String"/></type>
	<size><x path="Int"/></size>
	<rdev><x path="Int"/></rdev>
	<nlink><x path="Int"/></nlink>
	<mtime><t path="lua.lib.luv.fs.TimeStamp"/></mtime>
	<mode><x path="Int"/></mode>
	<ino><x path="Int"/></ino>
	<gid><x path="Int"/></gid>
	<gen><x path="Int"/></gen>
	<flags><x path="Int"/></flags>
	<dev><x path="Int"/></dev>
	<ctime><t path="lua.lib.luv.fs.TimeStamp"/></ctime>
	<blocks><x path="Int"/></blocks>
	<blksize><x path="Int"/></blksize>
	<birthtime><t path="lua.lib.luv.fs.TimeStamp"/></birthtime>
	<atime><t path="lua.lib.luv.fs.TimeStamp"/></atime>
</a></typedef>
	<typedef path="lua.lib.luv.fs.TimeStamp" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<sec><x path="Int"/></sec>
	<nsec><x path="Int"/></nsec>
</a></typedef>
	<abstract path="lua.lib.luv.fs.Open" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/Open.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua.lib.luv.fs._Open.Open_Impl_" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/Open.hx" private="1" module="lua.lib.luv.fs.Open"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.lib.luv.net.Tcp" params="" file="/usr/share/haxe/std/lua/lib/luv/net/Tcp.hx" extern="1">
		<extends path="lua.lib.luv.Stream"/>
		<new_tcp public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.net.Tcp"/></f></new_tcp>
		<open public="1" set="method"><f a="sock">
	<x path="Int"/>
	<x path="Int"/>
</f></open>
		<nodelay public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Int"/>
</f></nodelay>
		<keepalive public="1" set="method"><f a="enable:?delay">
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
</f></keepalive>
		<simultaneous_accepts public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Int"/>
</f></simultaneous_accepts>
		<bind public="1" set="method"><f a="address:port">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bind>
		<getsockname public="1" set="method"><f a=""><x path="Int"/></f></getsockname>
		<getpeername public="1" set="method"><f a=""><c path="String"/></f></getpeername>
		<connect public="1" set="method"><f a="host:port:cb">
	<c path="String"/>
	<x path="Int"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></connect>
		<write_queue_size public="1" set="method"><f a=""><x path="Int"/></f></write_queue_size>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_tcp"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="sys.FileStat" params="" file="/usr/share/haxe/std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
</haxe>