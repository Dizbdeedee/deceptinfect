-- Generated by Haxe 4.0.5
local _hx_array_mt = {
  __newindex = function(t,k,v)
    local len = t.length
    t.length =  k >= len and (k + 1) or len
    rawset(t,k,v)
  end
}

local function _hx_tab_array(tab,length)
  tab.length = length
  return setmetatable(tab, _hx_array_mt)
end

local function _hx_anon_newindex(t,k,v) t.__fields__[k] = true; rawset(t,k,v); end
local _hx_anon_mt = {__newindex=_hx_anon_newindex}
local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_anon_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_anon_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_anon_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_anon_newindex, __index=prototype})
end

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();

_G.require = function() end
local Sys = {time = function() end}
local _hx_exports = _hx_exports or {}
local Array = _hx_e()
local IntIterator = _hx_e()
local Main = _hx_e()
local Math = _hx_e()
local Reflect = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local Type = _hx_e()
__gmod_hooks_Gm = _hx_e()
__deceptinfect_DeceptInfect = _hx_e()
__gmod_sent_ENT = _hx_e()
__gmod_sent_ENT_ANIM = _hx_e()
__gmod_sent_SentBuild = _hx_e()
__deceptinfect_Di_battery = _hx_e()
__deceptinfect_Di_charger = _hx_e()
__deceptinfect_Di_nest = _hx_e()
__deceptinfect__GEntCompat_GEntCompat_Impl_ = _hx_e()
__deceptinfect__GEntCompat_GPlayerCompat_Impl_ = _hx_e()
__deceptinfect_GameInstance = _hx_e()
__deceptinfect_PLAYING_STATE = _hx_e()
__deceptinfect_GAME_STATE = _hx_e()
__deceptinfect_GameManager = _hx_e()
__deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_ = _hx_e()
__deceptinfect_GameValues = _hx_e()
__deceptinfect_Misc = _hx_e()
__deceptinfect_Networking = _hx_e()
__haxe_IMap = _hx_e()
__haxe_ds_IntMap = _hx_e()
__deceptinfect_PlayerManager = _hx_e()
__gmod_swep_SWEP = _hx_e()
__gmod_swep_SwepBuild = _hx_e()
__deceptinfect_Weapon_di_scan = _hx_e()
__deceptinfect_ecswip_Component = _hx_e()
__deceptinfect_abilities_FormComponent = _hx_e()
__deceptinfect_abilities_CurrentForm = _hx_e()
__deceptinfect_abilities_Cooldown = _hx_e()
__deceptinfect_ecswip_System = _hx_e()
__deceptinfect_abilities_FormSystem = _hx_e()
__deceptinfect_client_GeigerSystem = _hx_e()
__deceptinfect_client_PVS = _hx_e()
__haxe_ds_ObjectMap = _hx_e()
__deceptinfect_ecswip_ComponentManager = _hx_e()
__deceptinfect_ecswip__ComponentManager_DI_ID_Impl_ = _hx_e()
__deceptinfect_ecswip_ComponentTools = _hx_e()
__deceptinfect_ecswip_ComponentState = _hx_e()
__deceptinfect_ecswip_HasGEnt = _hx_e()
__deceptinfect_ecswip_Family = _hx_e()
__deceptinfect_ecswip_GEntityComponent = _hx_e()
__deceptinfect_ecswip_GrabAccepter = _hx_e()
__deceptinfect_ecswip_GrabAcceptState = _hx_e()
__deceptinfect_ecswip_GrabProducer = _hx_e()
__deceptinfect_ecswip_SearchingState = _hx_e()
__deceptinfect_ecswip_GrabProduceState = _hx_e()
__deceptinfect_ecswip_GrabSystem = _hx_e()
__deceptinfect_ecswip_HiddenHealthComponent = _hx_e()
__deceptinfect_ecswip_HiddenHealthSystem = _hx_e()
__deceptinfect_ecswip_PlayerComponent = _hx_e()
__deceptinfect_ecswip_DeathTime = _hx_e()
__tink_core_SignalObject = _hx_e()
__tink_core_SignalTrigger = _hx_e()
__deceptinfect_ecswip_SignalStorage = _hx_e()
__deceptinfect_ecswip_Spectate = _hx_e()
__deceptinfect_ecswip_Spec_Direction = _hx_e()
__deceptinfect_ecswip_SpectateComponent = _hx_e()
__deceptinfect_infection_InfectionSystem = _hx_e()
__deceptinfect_radiation_RadiationAccepter = _hx_e()
__deceptinfect_infection_RateComponent = _hx_e()
__deceptinfect_radiation_RadiationProducer = _hx_e()
__deceptinfect_ecswip_VirtualPosition = _hx_e()
__deceptinfect_infection_RateSystem = _hx_e()
__deceptinfect_radiation_RadiationSystem = _hx_e()
__deceptinfect_game_WinSystem = _hx_e()
__deceptinfect_game_BatterySystem = _hx_e()
__deceptinfect_ecswip_SystemManager = _hx_e()
__deceptinfect_game_BatteryAccepter = _hx_e()
__deceptinfect_game_AccepterStatus = _hx_e()
__deceptinfect_game_BatterySource = _hx_e()
__deceptinfect_game_NestComponent = _hx_e()
__deceptinfect_game_NestState = _hx_e()
__deceptinfect_game_Win = _hx_e()
__deceptinfect_infection_InfectedComponent = _hx_e()
__deceptinfect_infection_InfectionComponent = _hx_e()
__deceptinfect_infection_AcceptingInfection = _hx_e()
__deceptinfect_infection_BaseInfection = _hx_e()
__deceptinfect_infection_INF_STATE = _hx_e()
__deceptinfect_radiation_ContaminationAccepter = _hx_e()
__deceptinfect_radiation_ContaminationProducer = _hx_e()
__deceptinfect_radiation_ContaminationType = _hx_e()
__deceptinfect_radiation_RadiationState = _hx_e()
__deceptinfect_radiation_RadLifetime = _hx_e()
__haxe_ds_BalancedTree = _hx_e()
__haxe_ds_EnumValueMap = _hx_e()
__deceptinfect_radiation_RadTypes = _hx_e()
__deceptinfect_radiation_RadiationTypes = _hx_e()
__deceptinfect_util_Cooldown = _hx_e()
__deceptinfect_util_CooldownTools = _hx_e()
__deceptinfect_util_EntityExt = _hx_e()
__deceptinfect_util_PlayerExt = _hx_e()
__deceptinfect_util_TimeKeep = _hx_e()
__gmod__EntityClass_EntityClass_Impl_ = _hx_e()
__gmod__HaxeMultiReturn_HaxeMultiReturn_Impl_ = _hx_e()
__gmod__Hooks_Hook_Impl_ = _hx_e()
__gmod_Hooks = _hx_e()
__gmod_PairTools = _hx_e()
__gmod_TableTools = _hx_e()
__gmod_hooks_Swep = _hx_e()
__haxe_StackItem = _hx_e()
__haxe_EntryPoint = _hx_e()
__haxe_Log = _hx_e()
__haxe_MainEvent = _hx_e()
__haxe_MainLoop = _hx_e()
__haxe_Timer = _hx_e()
__haxe_ds_TreeNode = _hx_e()
__haxe_ds_Either = _hx_e()
__haxe_ds_Option = _hx_e()
__lua_Boot = _hx_e()
__haxe_iterators_MapKeyValueIterator = _hx_e()
__lua_UserData = _hx_e()
__lua_Thread = _hx_e()
__lua_lib_luasocket_Socket = _G.require("socket")
__tink_core_Annex = _hx_e()
__tink_core__Callback_Callback_Impl_ = _hx_e()
__tink_core_LinkObject = _hx_e()
__tink_core__Callback_CallbackLink_Impl_ = _hx_e()
__tink_core_SimpleLink = _hx_e()
__tink_core__Callback_LinkPair = _hx_e()
__tink_core__Callback_ListCell = _hx_e()
__tink_core_CallbackList = _hx_e()
__tink_core_TypedError = _hx_e()
__tink_core__Error_Stack_Impl_ = _hx_e()
__tink_core__Future_FutureObject = _hx_e()
__tink_core__Future_NeverFuture = _hx_e()
__tink_core_Noise = _hx_e()
__tink_core__Lazy_LazyObject = _hx_e()
__tink_core__Lazy_LazyConst = _hx_e()
__tink_core__Future_SyncFuture = _hx_e()
__tink_core__Future_Future_Impl_ = _hx_e()
__tink_core_FutureTrigger = _hx_e()
__tink_core__Future_SuspendableFuture = _hx_e()
__tink_core__Lazy_Lazy_Impl_ = _hx_e()
__tink_core__Lazy_LazyFunc = _hx_e()
__tink_core_NamedWith = _hx_e()
__tink_core_OptionTools = _hx_e()
__tink_core_OptionIter = _hx_e()
__tink_core_Outcome = _hx_e()
__tink_core_OutcomeTools = _hx_e()
__tink_core__Outcome_OutcomeMapper_Impl_ = _hx_e()
__tink_core__Pair_Pair_Impl_ = _hx_e()
__tink_core_MPair = _hx_e()
__tink_core__Promise_Promise_Impl_ = _hx_e()
__tink_core__Promise_Next_Impl_ = _hx_e()
__tink_core__Promise_Recover_Impl_ = _hx_e()
__tink_core__Promise_Combiner_Impl_ = _hx_e()
__tink_core__Promise_PromiseTrigger_Impl_ = _hx_e()
__tink_core__Ref_Ref_Impl_ = _hx_e()
__tink_core__Signal_Signal_Impl_ = _hx_e()
__tink_core__Signal_SimpleSignal = _hx_e()
__tink_core__Signal_Suspendable = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
Array.__name__ = "Array"
Array.prototype = _hx_a();
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local ret = _g;
  local _g3 = 0;
  while (_g3 < a.length) do 
    local i1 = a[_g3];
    _g3 = _g3 + 1;
    ret:push(i1);
  end;
  do return ret end
end
Array.prototype.join = function(self,sep) 
  local tbl = ({});
  local _gthis = self;
  local cur_length = 0;
  local i = _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return cur_length < _gthis.length end;
  end,next=function(self) 
    cur_length = cur_length + 1;
    do return _gthis[cur_length - 1] end;
  end});
  while (i:hasNext()) do 
    local i1 = i:next();
    _G.table.insert(tbl, Std.string(i1));
  end;
  do return _G.table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do 
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      _G.table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do 
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do 
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (_G.math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g2 = pos + len;
  local _g3 = self.length;
  while (_g2 < _g3) do 
    _g2 = _g2 + 1;
    local i1 = _g2 - 1;
    self[i1] = self[i1 + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = ({});
  _G.table.insert(tbl, "[");
  _G.table.insert(tbl, self:join(","));
  _G.table.insert(tbl, "]");
  do return _G.table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do 
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g2 = i;
      local _g11 = self.length - 1;
      while (_g2 < _g11) do 
        _g2 = _g2 + 1;
        local j = _g2 - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do 
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  local _gthis = self;
  local cur_length = 0;
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return cur_length < _gthis.length end;
  end,next=function(self) 
    cur_length = cur_length + 1;
    do return _gthis[cur_length - 1] end;
  end}) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        self[i] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

IntIterator.new = function(min,max) 
  local self = _hx_new(IntIterator.prototype)
  IntIterator.super(self,min,max)
  return self
end
IntIterator.super = function(self,min,max) 
  self.min = min;
  self.max = max;
end
IntIterator.__name__ = "IntIterator"
IntIterator.prototype = _hx_a();
IntIterator.prototype.hasNext = function(self) 
  do return self.min < self.max end
end
IntIterator.prototype.next = function(self) 
  do return (function() 
  local _hx_obj = self;
  local _hx_fld = 'min';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)() end
end

IntIterator.prototype.__class__ =  IntIterator

Main.new = {}
Main.__name__ = "Main"
Main.main = function() 
  __deceptinfect_Networking.initMessages();
  __deceptinfect_DeceptInfect.initaliseGamemode();
  local ply = __gmod_PairTools.iterator(_G.player.GetAll());
  while (ply:hasNext()) do 
    local ply1 = ply:next();
    local x = __deceptinfect_ecswip_PlayerComponent.new(ply1);
    local this1 = x.player;
    x.player.id = __deceptinfect_ecswip_ComponentManager.addPlayer(this1);
  end;
  __deceptinfect_ecswip_SignalStorage.initEvents();
  __deceptinfect_ecswip_SystemManager.initAllSystems();
end

Math.new = {}
Math.__name__ = "Math"
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -_G.math.huge) then 
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.min(a, b) end;
  end;
end

Reflect.new = {}
Reflect.__name__ = "Reflect"
Reflect.field = function(o,field) 
  if (_G.type(o) == "string") then 
    if (field == "length") then 
      do return _hx_wrap_if_string_field(o,'length') end;
    else
      do return String.prototype[field] end;
    end;
  else
    local _hx_status, _hx_result = pcall(function() 
    
        do return o[field] end;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
    
      local _hx_1 = _hx_result
      local e = _hx_1
      do return nil end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end;
end
Reflect.fields = function(o) 
  if (_G.type(o) == "string") then 
    do return Reflect.fields(String.prototype) end;
  else
    local _g = _hx_tab_array({}, 0);
    local f = __lua_Boot.fieldIterator(o);
    while (f:hasNext()) do 
      local f1 = f:next();
      _g:push(f1);
    end;
    do return _g end;
  end;
end
Reflect.compare = function(a,b) 
  if (a == b) then 
    do return 0 end;
  else
    if (a == nil) then 
      do return -1 end;
    else
      if (b == nil) then 
        do return 1 end;
      else
        if (a > b) then 
          do return 1 end;
        else
          do return -1 end;
        end;
      end;
    end;
  end;
end
Reflect.isEnumValue = function(v) 
  if ((v ~= nil) and __lua_Boot.__instanceof(v, _G.table)) then 
    do return v.__enum__ ~= nil end;
  else
    do return false end;
  end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
String.__name__ = "String"
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (_G.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (_G.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_a();
String.prototype.toUpperCase = function(self) 
  do return _G.string.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return _G.string.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  local r = _G.string.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local i = 0;
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = #self;
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local r = _G.string.find(self, str, startIndex1, true);
    local p = (function() 
      local _hx_1
      if ((r ~= nil) and (r > 0)) then 
      _hx_1 = r - 1; else 
      _hx_1 = -1; end
      return _hx_1
    end )();
    if ((p == -1) or (p > startIndex)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  local delim_offset = (function() 
    local _hx_1
    if (#delimiter > 0) then 
    _hx_1 = #delimiter; else 
    _hx_1 = 1; end
    return _hx_1
  end )();
  while (idx ~= nil) do 
    local newidx = 0;
    if (#delimiter > 0) then 
      newidx = _G.string.find(self, delimiter, idx, true);
    else
      if (idx >= #self) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = _G.string.sub(self, idx, newidx - 1);
      ret:push(match);
      idx = newidx + #delimiter;
    else
      ret:push(_G.string.sub(self, idx, #self));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = #self;
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return _G.string.sub(self, endIndex + 1, startIndex) end;
  else
    do return _G.string.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return _G.string.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return _G.string.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + #self))) then 
    len = #self;
  else
    if (len < 0) then 
      len = #self + len;
    end;
  end;
  if (pos < 0) then 
    pos = #self + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return _G.string.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

Std.new = {}
Std.__name__ = "Std"
Std.string = function(s) 
  do return __lua_Boot.__string_rec(s) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    if (x < __lua_Boot.Min_Int32) then 
      do return __lua_Boot.Min_Int32 end;
    else
      if (x > __lua_Boot.Max_Int32) then 
        do return __lua_Boot.Max_Int32 end;
      else
        do return _G.math.floor(x) end;
      end;
    end;
  end;
end

Type.new = {}
Type.__name__ = "Type"
Type.getClass = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o1 = o;
  if (__lua_Boot.__instanceof(o1, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o1, String)) then 
      do return String end;
    else
      local cl = o1.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end
Type.enumEq = function(a,b) 
  if (a == b) then 
    do return true end;
  end;
  local _hx_status, _hx_result = pcall(function() 
  
      if (a[0] ~= b[0]) then 
        do return false end;
      end;
      local _g = 2;
      local _g1 = a.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        if (not Type.enumEq(a[i], b[i])) then 
          do return false end;
        end;
      end;
      local e = a.__enum__;
      if ((e ~= b.__enum__) or (e == nil)) then 
        do return false end;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
  
    local _hx_1 = _hx_result
    local e1 = _hx_1
    do return false end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return true end;
end

__gmod_hooks_Gm.new = {}
__gmod_hooks_Gm.__name__ = "gmod.hooks.Gm"
__gmod_hooks_Gm.prototype = _hx_a();
__gmod_hooks_Gm.prototype.PlayerConnect = function(self,name,ip) 
end
__gmod_hooks_Gm.prototype.IsSpawnpointSuitable = function(self,ply,spawnpoint,makeSuitable) 
  do return nil end
end
__gmod_hooks_Gm.prototype.LoadGModSave = function(self,data,map,timestamp) 
end
__gmod_hooks_Gm.prototype.ShowTeam = function(self,ply) 
end
__gmod_hooks_Gm.prototype.ShouldCollide = function(self,ent1,ent2) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerCanPickupItem = function(self,ply,item) 
  do return nil end
end
__gmod_hooks_Gm.prototype.CreateEntityRagdoll = function(self,owner,ragdoll) 
end
__gmod_hooks_Gm.prototype.Saved = function(self) 
end
__gmod_hooks_Gm.prototype.AllowPlayerPickup = function(self,ply,ent) 
  do return nil end
end
__gmod_hooks_Gm.prototype.ScalePlayerDamage = function(self,ply,hitgroup,dmginfo) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerInitialSpawn = function(self,player,transition) 
end
__gmod_hooks_Gm.prototype.PlayerJoinTeam = function(self,ply,team) 
end
__gmod_hooks_Gm.prototype.OnPhysgunFreeze = function(self,weapon,physobj,ent,ply) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerLoadout = function(self,ply) 
end
__gmod_hooks_Gm.prototype.PreCleanupMap = function(self) 
end
__gmod_hooks_Gm.prototype.CreateTeams = function(self) 
end
__gmod_hooks_Gm.prototype.OnLuaError = function(self,error,realm,name,id) 
end
__gmod_hooks_Gm.prototype.GravGunOnDropped = function(self,ply,ent) 
end
__gmod_hooks_Gm.prototype.KeyPress = function(self,ply,key) 
end
__gmod_hooks_Gm.prototype.HandlePlayerVaulting = function(self,ply,velocity) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerCanSeePlayersChat = function(self,text,teamOnly,listener,speaker) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerDeathThink = function(self,ply) 
  do return nil end
end
__gmod_hooks_Gm.prototype.EntityKeyValue = function(self,ent,key,value) 
  do return nil end
end
__gmod_hooks_Gm.prototype.HandlePlayerLanding = function(self,ply,velocity,onGround) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerCanPickupWeapon = function(self,ply,wep) 
  do return nil end
end
__gmod_hooks_Gm.prototype.WorkshopEnd = function(self) 
end
__gmod_hooks_Gm.prototype.PostPlayerDeath = function(self,ply) 
end
__gmod_hooks_Gm.prototype.SetPlayerSpeed = function(self,ply,walkSpeed,runSpeed) 
end
__gmod_hooks_Gm.prototype.FinishMove = function(self,ply,mv) 
  do return nil end
end
__gmod_hooks_Gm.prototype.CanPlayerSuicide = function(self,player) 
  do return nil end
end
__gmod_hooks_Gm.prototype.StartEntityDriving = function(self,ent,ply) 
end
__gmod_hooks_Gm.prototype.PlayerDeath = function(self,victim,inflictor,attacker) 
end
__gmod_hooks_Gm.prototype.PlayerCanHearPlayersVoice = function(self,listener,talker) 
  do return nil end
end
__gmod_hooks_Gm.prototype.OnPlayerChangedTeam = function(self,ply,oldTeam,newTeam) 
end
__gmod_hooks_Gm.prototype.HandlePlayerDriving = function(self,ply) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerEnteredVehicle = function(self,ply,veh,role) 
end
__gmod_hooks_Gm.prototype.PlayerSilentDeath = function(self,ply) 
end
__gmod_hooks_Gm.prototype.OnDamagedByExplosion = function(self,ply,dmginfo) 
end
__gmod_hooks_Gm.prototype.PlayerSay = function(self,sender,text,teamChat) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PostCleanupMap = function(self) 
end
__gmod_hooks_Gm.prototype.MouthMoveAnimation = function(self,ply) 
end
__gmod_hooks_Gm.prototype.PlayerPostThink = function(self,ply) 
end
__gmod_hooks_Gm.prototype.PlayerNoClip = function(self,ply,desiredState) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerDriveAnimate = function(self,ply) 
end
__gmod_hooks_Gm.prototype.PlayerLeaveVehicle = function(self,ply,veh) 
end
__gmod_hooks_Gm.prototype.Restored = function(self) 
end
__gmod_hooks_Gm.prototype.EndEntityDriving = function(self,ent,ply) 
end
__gmod_hooks_Gm.prototype.ShowSpare2 = function(self,ply) 
end
__gmod_hooks_Gm.prototype.PlayerSelectTeamSpawn = function(self,team,ply) 
  do return nil end
end
__gmod_hooks_Gm.prototype.NetworkIDValidated = function(self,name,steamID) 
end
__gmod_hooks_Gm.prototype.SetupMove = function(self,ply,mv,cmd) 
end
__gmod_hooks_Gm.prototype.PlayerButtonDown = function(self,ply,button) 
end
__gmod_hooks_Gm.prototype.DoAnimationEvent = function(self,ply,event,data) 
  do return nil end
end
__gmod_hooks_Gm.prototype.MenuStart = function(self) 
end
__gmod_hooks_Gm.prototype.StartGame = function(self) 
end
__gmod_hooks_Gm.prototype.PlayerButtonUp = function(self,ply,button) 
end
__gmod_hooks_Gm.prototype.WorkshopDownloadFile = function(self,id,imageID,title,size) 
end
__gmod_hooks_Gm.prototype.VariableEdited = function(self,ent,ply,key,val,editor) 
end
__gmod_hooks_Gm.prototype.PlayerSwitchFlashlight = function(self,ply,enabled) 
  do return nil end
end
__gmod_hooks_Gm.prototype.OnNPCKilled = function(self,npc,attacker,inflictor) 
end
__gmod_hooks_Gm.prototype.PlayerSpray = function(self,sprayer) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerFootstep = function(self,ply,pos,foot,sound,volume,filter) 
  do return nil end
end
__gmod_hooks_Gm.prototype.OnViewModelChanged = function(self,viewmodel,oldModel,newModel) 
end
__gmod_hooks_Gm.prototype.PropBreak = function(self,attacker,prop) 
end
__gmod_hooks_Gm.prototype.GetPreferredCarryAngles = function(self,ent) 
  do return nil end
end
__gmod_hooks_Gm.prototype.CanPlayerUnfreeze = function(self,player,entity,phys) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PostGamemodeLoaded = function(self) 
end
__gmod_hooks_Gm.prototype.PhysgunDrop = function(self,ply,ent) 
end
__gmod_hooks_Gm.prototype.PlayerDeathSound = function(self) 
  do return nil end
end
__gmod_hooks_Gm.prototype.HandlePlayerSwimming = function(self,ply,velocity) 
  do return nil end
end
__gmod_hooks_Gm.prototype.CalcMainActivity = function(self,ply,vel) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerSetHandsModel = function(self,ply,ent) 
end
__gmod_hooks_Gm.prototype.OnGamemodeLoaded = function(self) 
end
__gmod_hooks_Gm.prototype.PlayerSpawn = function(self,player,transition) 
end
__gmod_hooks_Gm.prototype.GravGunPunt = function(self,ply,ent) 
  do return nil end
end
__gmod_hooks_Gm.prototype.GetFallDamage = function(self,ply,speed) 
  do return nil end
end
__gmod_hooks_Gm.prototype.CanExitVehicle = function(self,veh,ply) 
  do return nil end
end
__gmod_hooks_Gm.prototype.AcceptInput = function(self,ent,input,activator,caller,value) 
  do return nil end
end
__gmod_hooks_Gm.prototype.OnPhysgunPickup = function(self,ply,ent) 
end
__gmod_hooks_Gm.prototype.PhysgunPickup = function(self,player,entity) 
  do return nil end
end
__gmod_hooks_Gm.prototype.ShowHelp = function(self,ply) 
end
__gmod_hooks_Gm.prototype.OnPlayerHitGround = function(self,player,inWater,onFloater,speed) 
  do return nil end
end
__gmod_hooks_Gm.prototype.GravGunOnPickedUp = function(self,ply,ent) 
end
__gmod_hooks_Gm.prototype.Move = function(self,ply,mv) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerTick = function(self,player,mv) 
end
__gmod_hooks_Gm.prototype.Initialize = function(self) 
end
__gmod_hooks_Gm.prototype.StartCommand = function(self,ply,ucmd) 
end
__gmod_hooks_Gm.prototype.PlayerCanJoinTeam = function(self,ply,team) 
  do return nil end
end
__gmod_hooks_Gm.prototype.CaptureVideo = function(self) 
end
__gmod_hooks_Gm.prototype.KeyRelease = function(self,ply,key) 
end
__gmod_hooks_Gm.prototype.PlayerFrozeObject = function(self,ply,ent,physobj) 
end
__gmod_hooks_Gm.prototype.CheckPassword = function(self,steamID64,ipAddress,svPassword,clPassword,name) 
  do return nil end
end
__gmod_hooks_Gm.prototype.ShowSpare1 = function(self,ply) 
end
__gmod_hooks_Gm.prototype.WorkshopDownloadProgress = function(self,id,imageID,title,downloaded,expected) 
end
__gmod_hooks_Gm.prototype.PlayerUnfrozeObject = function(self,ply,ent,physobj) 
end
__gmod_hooks_Gm.prototype.TranslateActivity = function(self,ply,act) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerShouldTaunt = function(self,ply,act) 
  do return nil end
end
__gmod_hooks_Gm.prototype.VehicleMove = function(self,ply,veh,mv) 
end
__gmod_hooks_Gm.prototype.GravGunPickupAllowed = function(self,ply,ent) 
  do return nil end
end
__gmod_hooks_Gm.prototype.ShutDown = function(self) 
end
__gmod_hooks_Gm.prototype.CanEditVariable = function(self,ent,ply,key,val,editor) 
  do return nil end
end
__gmod_hooks_Gm.prototype.EntityNetworkedVarChanged = function(self,ent,name,oldval,newval) 
end
__gmod_hooks_Gm.prototype.EntityFireBullets = function(self,ent,data) 
  do return nil end
end
__gmod_hooks_Gm.prototype.HandlePlayerJumping = function(self,ply,velocity) 
  do return nil end
end
__gmod_hooks_Gm.prototype.Think = function(self) 
end
__gmod_hooks_Gm.prototype.DoPlayerDeath = function(self,ply,attacker,dmg) 
end
__gmod_hooks_Gm.prototype.EntityTakeDamage = function(self,target,dmg) 
  do return nil end
end
__gmod_hooks_Gm.prototype.ScaleNPCDamage = function(self,npc,hitgroup,dmginfo) 
end
__gmod_hooks_Gm.prototype.WeaponEquip = function(self,weapon,owner) 
end
__gmod_hooks_Gm.prototype.PreGamemodeLoaded = function(self) 
end
__gmod_hooks_Gm.prototype.WorkshopStart = function(self) 
end
__gmod_hooks_Gm.prototype.PlayerHurt = function(self,victim,attacker,healthRemaining,damageTaken) 
end
__gmod_hooks_Gm.prototype.WorkshopDownloadTotals = function(self,remain,total) 
end
__gmod_hooks_Gm.prototype.PlayerShouldTakeDamage = function(self,ply,attacker) 
  do return nil end
end
__gmod_hooks_Gm.prototype.Tick = function(self) 
end
__gmod_hooks_Gm.prototype.UpdateAnimation = function(self,ply,velocity,maxSeqGroundSpeed) 
end
__gmod_hooks_Gm.prototype.EntityEmitSound = function(self,data) 
  do return nil end
end
__gmod_hooks_Gm.prototype.GameContentChanged = function(self) 
end
__gmod_hooks_Gm.prototype.CanPlayerEnterVehicle = function(self,player,vehicle,role) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerSpawnAsSpectator = function(self,ply) 
end
__gmod_hooks_Gm.prototype.SetupPlayerVisibility = function(self,ply,viewEntity) 
end
__gmod_hooks_Gm.prototype.PlayerStartTaunt = function(self,ply,act,length) 
end
__gmod_hooks_Gm.prototype.PlayerTraceAttack = function(self,ply,dmginfo,dir,trace) 
  do return nil end
end
__gmod_hooks_Gm.prototype.GetGameDescription = function(self) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerSelectSpawn = function(self,ply,transition) 
  do return nil end
end
__gmod_hooks_Gm.prototype.InitPostEntity = function(self) 
end
__gmod_hooks_Gm.prototype.GrabEarAnimation = function(self,ply) 
end
__gmod_hooks_Gm.prototype.PlayerSetModel = function(self,ply) 
end
__gmod_hooks_Gm.prototype.PlayerDroppedWeapon = function(self,owner,wep) 
end
__gmod_hooks_Gm.prototype.WorkshopDownloadedFile = function(self,id,title) 
end
__gmod_hooks_Gm.prototype.PlayerRequestTeam = function(self,ply,team) 
end
__gmod_hooks_Gm.prototype.PlayerUse = function(self,ply,ent) 
  do return nil end
end
__gmod_hooks_Gm.prototype.HandlePlayerNoClipping = function(self,ply,velocity) 
  do return nil end
end
__gmod_hooks_Gm.prototype.HandlePlayerDucking = function(self,ply,velocity) 
  do return nil end
end
__gmod_hooks_Gm.prototype.EntityRemoved = function(self,ent) 
end
__gmod_hooks_Gm.prototype.OnReloaded = function(self) 
end
__gmod_hooks_Gm.prototype.WorkshopSubscriptionsProgress = function(self,num,max) 
end
__gmod_hooks_Gm.prototype.OnEntityCreated = function(self,entity) 
end
__gmod_hooks_Gm.prototype.PlayerStepSoundTime = function(self,ply,type,walking) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerSwitchWeapon = function(self,player,oldWeapon,newWeapon) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerDisconnected = function(self,ply) 
end
__gmod_hooks_Gm.prototype.OnPhysgunReload = function(self,physgun,ply) 
  do return nil end
end
__gmod_hooks_Gm.prototype.PlayerAuthed = function(self,ply,steamid,uniqueid) 
end
__gmod_hooks_Gm.prototype.FindUseEntity = function(self,ply,defaultEnt) 
  do return nil end
end
__gmod_hooks_Gm.prototype.postIntialize = function(self) 
end

__gmod_hooks_Gm.prototype.__class__ =  __gmod_hooks_Gm

__deceptinfect_DeceptInfect.new = function(_self) 
  local self = _hx_new(__deceptinfect_DeceptInfect.prototype)
  __deceptinfect_DeceptInfect.super(self,_self)
  return self
end
__deceptinfect_DeceptInfect.super = function(self,_self) 
  _self.Think = function(GM,...) return self:Think(...) end;
  _self.OnEntityCreated = function(GM,...) return self:OnEntityCreated(...) end;
  _self.EntityRemoved = function(GM,...) return self:EntityRemoved(...) end;
  _self.PlayerDeath = function(GM,...) return self:PlayerDeath(...) end;
  _self.EntityKeyValue = function(GM,...) return self:EntityKeyValue(...) end;
  _self.PlayerSpawn = function(GM,...) return self:PlayerSpawn(...) end;
  _self.PlayerButtonUp = function(GM,...) return self:PlayerButtonUp(...) end;
  _self.KeyPress = function(GM,...) return self:KeyPress(...) end;
  _self.KeyRelease = function(GM,...) return self:KeyRelease(...) end;
  _self.PlayerSwitchWeapon = function(GM,...) return self:PlayerSwitchWeapon(...) end;
  _self.PlayerButtonDown = function(GM,...) return self:PlayerButtonDown(...) end;
  _self.PlayerDeathSound = function(GM,...) return self:PlayerDeathSound(...) end;
  _self.PlayerDeathThink = function(GM,...) return self:PlayerDeathThink(...) end;
  _self.IsSpawnpointSuitable = function(GM,...) return self:IsSpawnpointSuitable(...) end;
  _self.PlayerSelectSpawn = function(GM,...) return self:PlayerSelectSpawn(...) end;
  _self.EntityTakeDamage = function(GM,...) return self:EntityTakeDamage(...) end;
  _self.PlayerSay = function(GM,...) return self:PlayerSay(...) end;
  _self.PlayerCanHearPlayersVoice = function(GM,...) return self:PlayerCanHearPlayersVoice(...) end;
  self:postIntialize();
end
__deceptinfect_DeceptInfect.__name__ = "deceptinfect.DeceptInfect"
__deceptinfect_DeceptInfect.initaliseGamemode = function() 
  local GM = GM;
  local inst = __deceptinfect_DeceptInfect.new(GM);
  __deceptinfect_DeceptInfect.GAMEMODE = inst;
  do return inst end;
end
__deceptinfect_DeceptInfect.prototype = _hx_a();
__deceptinfect_DeceptInfect.prototype.Think = function(self) 
  __deceptinfect_ecswip_SystemManager.runAllSystems();
  local _g = __deceptinfect_GameManager.state;
  if (_g[1] == 2) then 
    local x = _g[2];
    x:think();
    x.lastTick = _G.CurTime();
  end;
end
__deceptinfect_DeceptInfect.prototype.OnEntityCreated = function(self,entity) 
  if (entity:IsPlayer()) then 
    local x = __deceptinfect_ecswip_PlayerComponent.new(entity);
    local this1 = x.player;
    x.player.id = __deceptinfect_ecswip_ComponentManager.addPlayer(this1);
    local ent = this1;
  end;
end
__deceptinfect_DeceptInfect.prototype.EntityRemoved = function(self,ent) 
  if (ent:IsPlayer()) then 
    __deceptinfect_ecswip_ComponentManager.removeEntity(ent.id);
    do return end;
  end;
  local _g;
  local _g1 = ent.id;
  if (_g1 == nil) then 
    _g = __haxe_ds_Option.None;
  else
    local x = _g1;
    _g = __haxe_ds_Option.Some(x);
  end;
  if (_g[1] == 0) then 
    local id = _g[2];
    __deceptinfect_ecswip_ComponentManager.removeEntity(id);
  end;
end
__deceptinfect_DeceptInfect.prototype.PlayerDeath = function(self,victim,inflictor,attacker) 
  __haxe_Log.trace("Player ded!", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/DeceptInfect.hx",lineNumber=71,className="deceptinfect.DeceptInfect",methodName="PlayerDeath"}));
end
__deceptinfect_DeceptInfect.prototype.EntityKeyValue = function(self,ent,key,value) 
  do return nil end
end
__deceptinfect_DeceptInfect.prototype.PlayerSpawn = function(self,player,transition) 
  player:UnSpectate();
  player:SetModel(__deceptinfect_Misc.roundModels[0]);
  player:ShouldDropWeapon(true);
  if (Type.enumEq(__deceptinfect_GameManager.state, __deceptinfect_GAME_STATE.WAIT)) then 
    player:Give(__deceptinfect_Misc.roundWeapons[0]);
    player:ShouldDropWeapon(false);
  end;
end
__deceptinfect_DeceptInfect.prototype.PlayerButtonUp = function(self,ply,button) 
  local button1 = button;
  if (button1) == _G.KEY_E then 
  elseif (button1) == _G.KEY_F then 
    __deceptinfect_abilities_FormSystem.attemptChangeForm(ply.id);
  elseif (button1) == _G.KEY_M then 
    PrintTable(__deceptinfect_ecswip_ComponentManager.components.h[__deceptinfect_ecswip_PlayerComponent]);
  elseif (button1) == _G.KEY_SEMICOLON then 
    local plyr = _G.player.GetByID(1);
    __deceptinfect_infection_InfectionSystem.makeInfected(plyr.id);else end;
end
__deceptinfect_DeceptInfect.prototype.KeyPress = function(self,ply,key) 
  if (key == _G.IN_USE) then 
    __deceptinfect_ecswip_GrabSystem.requestStartSearch(ply.id);
  end;
end
__deceptinfect_DeceptInfect.prototype.KeyRelease = function(self,ply,key) 
  if (key == _G.IN_USE) then 
    __deceptinfect_ecswip_GrabSystem.requestStopSearch(ply.id);
  end;
end
__deceptinfect_DeceptInfect.prototype.PlayerSwitchWeapon = function(self,player,oldWeapon,newWeapon) 
  if (newWeapon:GetClass() == "weapon_infect") then 
    do return true end;
  end;
  do return nil end
end
__deceptinfect_DeceptInfect.prototype.PlayerButtonDown = function(self,ply,button) 
  local tmp = button == _G.KEY_E;
end
__deceptinfect_DeceptInfect.prototype.PlayerDeathSound = function(self) 
  do return false end
end
__deceptinfect_DeceptInfect.prototype.PlayerDeathThink = function(self,ply) 
  local this1 = ply.id;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
  local comp = comparray[this1];
  local comp1 = __deceptinfect_ecswip_ComponentTools.sure(comp);
  local reviveTime;
  local revive = false;
  local _g = comp1.deathTime;
  local tmp;
  local tmp1 = _g[1];
  if (tmp1) == 0 then 
    reviveTime = _G.CurTime() + 1;
    tmp = __deceptinfect_ecswip_DeathTime.DEAD(reviveTime);
  elseif (tmp1) == 1 then 
    local rev = _g[2];
    reviveTime = rev;
    tmp = comp1.deathTime; end;
  comp1.deathTime = tmp;
  if ((ply:IsBot() and (_G.CurTime() > reviveTime)) and __deceptinfect_GameManager.shouldAllowRespawn()) then 
    revive = true;
  end;
  if (_G.IsValid(ply:GetObserverTarget())) then 
    ply:SetPos(ply:GetObserverTarget():GetPos());
  end;
  if (ply:KeyPressed(_G.IN_ATTACK)) then 
    if ((_G.CurTime() > reviveTime) and __deceptinfect_GameManager.shouldAllowRespawn()) then 
      revive = true;
    end;
    __deceptinfect_ecswip_Spectate.chooseSpectateTarget(comp1, __deceptinfect_ecswip_Spec_Direction.FORWARDS);
  else
    if (ply:KeyPressed(_G.IN_ATTACK2)) then 
      __deceptinfect_ecswip_Spectate.chooseSpectateTarget(comp1, __deceptinfect_ecswip_Spec_Direction.BACKWARDS);
    else
      if (ply:KeyPressed(_G.IN_JUMP) and __deceptinfect_util_PlayerExt.shouldFreeRoam(ply)) then 
        ply:UnSpectate();
        ply:Spectate(_G.OBS_MODE_ROAMING);
        comp1.spec_next = 1;
      end;
    end;
  end;
  if (revive) then 
    comp1.deathTime = __deceptinfect_ecswip_DeathTime.ALIVE;
    ply:UnSpectate();
    ply:Spawn();
    do return true end;
  else
    do return false end;
  end;
end
__deceptinfect_DeceptInfect.prototype.IsSpawnpointSuitable = function(self,ply,spawnpoint,makeSuitable) 
  local pos = spawnpoint:GetPos();
  local this1 = _G.Vector(-16, -16, 0);
  local otherVec = this1;
  local blockers = pos + otherVec;
  local this2 = _G.Vector(16, 16, 72);
  local otherVec1 = this2;
  local blockers1 = _G.ents.FindInBox(blockers, pos + otherVec1);
  local ent = __gmod_PairTools.iterator(blockers1);
  while (ent:hasNext()) do 
    local ent1 = ent:next();
    local tmp = ent1:IsPlayer();
  end;
  do return true end
end
__deceptinfect_DeceptInfect.prototype.PlayerSelectSpawn = function(self,ply,transition) 
  local spawns = _G.ents.FindByClass("info_player_start");
  __haxe_Log.trace(#spawns, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/DeceptInfect.hx",lineNumber=209,className="deceptinfect.DeceptInfect",methodName="PlayerSelectSpawn"}));
  _G.PrintTable(spawns);
  local random_spawn = _G.math.random(#spawns);
  if (self:IsSpawnpointSuitable(ply, spawns[random_spawn], false)) then 
    do return spawns[random_spawn] end;
  end;
  do return nil end
end
__deceptinfect_DeceptInfect.prototype.EntityTakeDamage = function(self,target,dmg) 
  local _g;
  local _g1 = target.id;
  if (_g1 == nil) then 
    _g = __haxe_ds_Option.None;
  else
    local x = _g1;
    _g = __haxe_ds_Option.Some(x);
  end;
  if (_g[1] == 0) then 
    local id = _g[2];
    __deceptinfect_ecswip_SignalStorage.entDamageTrigger.handlers:invoke(_hx_o({__fields__={vicID=true,dmg=true,entity=true},vicID=id,dmg=dmg,entity=target}));
  end;
  do return nil end
end
__deceptinfect_DeceptInfect.prototype.PlayerSay = function(self,sender,text,teamChat) 
  do return "aaaaple" end
end
__deceptinfect_DeceptInfect.prototype.PlayerCanHearPlayersVoice = function(self,listener,talker) 
  local tbl = ({});
  local access = _hx_o({__fields__={a=true,b=true},a=false,b=false});
  local _g_access = access;
  local _g_keys = Reflect.fields(access);
  local _g_index = 0;
  while (_g_index < _g_keys.length) do 
    _g_index = _g_index + 1;
    local key = _g_keys[_g_index - 1];
    local _g1 = _hx_o({__fields__={value=true,key=true},value=Reflect.field(_g_access, key),key=key});
    local name = _g1.key;
    local value = _g1.value;
    tbl[_G.string.byte(name, 1) - 96] = value;
  end;
  do return _hx_table.unpack(tbl) end
end

__deceptinfect_DeceptInfect.prototype.__class__ =  __deceptinfect_DeceptInfect
__deceptinfect_DeceptInfect.__super__ = __gmod_hooks_Gm
setmetatable(__deceptinfect_DeceptInfect.prototype,{__index=__gmod_hooks_Gm.prototype})

__gmod_sent_ENT.new = {}
__gmod_sent_ENT.__name__ = "gmod.sent.ENT"
__gmod_sent_ENT.prototype = _hx_a();
__gmod_sent_ENT.prototype.Initialize = function(self) 
end
__gmod_sent_ENT.prototype.AcceptInput = function(self,inputName,activator,caller,data) 
  do return nil end
end
__gmod_sent_ENT.prototype.KeyValue = function(self,key,value) 
  do return nil end
end
__gmod_sent_ENT.prototype.OnReloaded = function(self) 
end
__gmod_sent_ENT.prototype.OnRemove = function(self) 
end
__gmod_sent_ENT.prototype.OnRestore = function(self) 
end
__gmod_sent_ENT.prototype.StoreOutput = function(self,name,info) 
end
__gmod_sent_ENT.prototype.Think = function(self) 
  do return nil end
end
__gmod_sent_ENT.prototype.TriggerOutput = function(self,output,activator,data) 
end
__gmod_sent_ENT.prototype.CalcAbsolutePosition = function(self,pos,ang) 
  do return nil end
end
__gmod_sent_ENT.prototype.CanProperty = function(self,ply,property) 
  do return nil end
end
__gmod_sent_ENT.prototype.DoImpactEffect = function(self,tr,damageType) 
  do return nil end
end
__gmod_sent_ENT.prototype.GravGunPickupAllowed = function(self,ply) 
  do return nil end
end
__gmod_sent_ENT.prototype.GravGunPunt = function(self,ply) 
  do return nil end
end
__gmod_sent_ENT.prototype.HandleAnimEvent = function(self,event,eventTime,cycle,type,options) 
end
__gmod_sent_ENT.prototype.IsJumpLegal = function(self,startPos,apex,endPos) 
  do return nil end
end
__gmod_sent_ENT.prototype.OnDuplicated = function(self,entTable) 
end
__gmod_sent_ENT.prototype.OnEntityCopyTableFinish = function(self,data) 
end
__gmod_sent_ENT.prototype.PostEntityPaste = function(self,ply,ent,createdEntities) 
end
__gmod_sent_ENT.prototype.PreEntityCopy = function(self) 
end
__gmod_sent_ENT.prototype.SetAutomaticFrameAdvance = function(self,enable) 
end
__gmod_sent_ENT.prototype.SetupDataTables = function(self) 
end

__gmod_sent_ENT.prototype.__class__ =  __gmod_sent_ENT

__gmod_sent_ENT_ANIM.new = function() 
  local self = _hx_new(__gmod_sent_ENT_ANIM.prototype)
  __gmod_sent_ENT_ANIM.super(self)
  return self
end
__gmod_sent_ENT_ANIM.super = function(self) 
  self.TYPE = "anim";
end
__gmod_sent_ENT_ANIM.__name__ = "gmod.sent.ENT_ANIM"
__gmod_sent_ENT_ANIM.prototype = _hx_a();
__gmod_sent_ENT_ANIM.prototype.Blocked = function(self,other) 
end
__gmod_sent_ENT_ANIM.prototype.EndTouch = function(self,entity) 
end
__gmod_sent_ENT_ANIM.prototype.OnTakeDamage = function(self,damage) 
end
__gmod_sent_ENT_ANIM.prototype.PhysicsCollide = function(self,colData,collider) 
end
__gmod_sent_ENT_ANIM.prototype.PhysicsSimulate = function(self,phys,deltaTime) 
  do return nil end
end
__gmod_sent_ENT_ANIM.prototype.PhysicsUpdate = function(self,phys) 
end
__gmod_sent_ENT_ANIM.prototype.StartTouch = function(self,entity) 
end
__gmod_sent_ENT_ANIM.prototype.TestCollision = function(self,startpos,delta,isbox,extents,mask) 
  do return nil end
end
__gmod_sent_ENT_ANIM.prototype.Touch = function(self,entity) 
end
__gmod_sent_ENT_ANIM.prototype.UpdateTransmitState = function(self) 
  do return nil end
end
__gmod_sent_ENT_ANIM.prototype.Use = function(self,activator,caller,useType,value) 
end

__gmod_sent_ENT_ANIM.prototype.__class__ =  __gmod_sent_ENT_ANIM
__gmod_sent_ENT_ANIM.__super__ = __gmod_sent_ENT
setmetatable(__gmod_sent_ENT_ANIM.prototype,{__index=__gmod_sent_ENT.prototype})

__gmod_sent_SentBuild.new = {}
__gmod_sent_SentBuild.__name__ = "gmod.sent.SentBuild"
__gmod_sent_SentBuild.prototype = _hx_a();

__gmod_sent_SentBuild.prototype.__class__ =  __gmod_sent_SentBuild

__deceptinfect_Di_battery.new = function(curEnt) 
  local self = _hx_new(__deceptinfect_Di_battery.prototype)
  __deceptinfect_Di_battery.super(self,curEnt)
  return self
end
__deceptinfect_Di_battery.super = function(self,curEnt) 
  self.id = nil;
  self.lastplayer = nil;
  self.properties = _hx_o({__fields__={Base=true},Base="base_entity"});
  __gmod_sent_ENT_ANIM.super(self);
  self["self"] = curEnt;
end
_hx_exports["di_battery"] = __deceptinfect_Di_battery
__deceptinfect_Di_battery.__name__ = "deceptinfect.Di_battery"
__deceptinfect_Di_battery.freeManyouFool = function() 
end
__deceptinfect_Di_battery.prototype = _hx_a();
__deceptinfect_Di_battery.prototype.Initialize = function(self) 
  self["self"]:SetModel("models/props_c17/chair02a.mdl");
  self["self"]:PhysicsInit(_G.SOLID_VPHYSICS);
  local physob = self["self"]:GetPhysicsObject();
  if (_G.IsValid(physob)) then 
    physob:Wake();
  end;
  self["self"]:SetUseType(_G.SIMPLE_USE);
  local x = self["self"];
  local this1 = x;
  x.id = __deceptinfect_ecswip_ComponentManager.addGEnt(this1);
  local ent = this1;
  self.id = ent.id;
  local this2 = self.id;
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_game_BatterySource.new(), this2);
end
__deceptinfect_Di_battery.prototype.Use = function(self,activator,caller,useType,value) 
  if (self["self"]:IsPlayerHolding() or not activator:IsPlayer()) then 
    do return end;
  end;
  local _activator = activator;
  _activator:PickupObject(self["self"]);
  self.lastplayer = _activator;
end
__deceptinfect_Di_battery.prototype.Touch = function(self,entity) 
  local _g;
  local _g1 = entity.id;
  if (_g1 == nil) then 
    _g = __haxe_ds_Option.None;
  else
    local x = _g1;
    _g = __haxe_ds_Option.Some(x);
  end;
  if (_g[1] == 0) then 
    local otherID = _g[2];
    local result = __deceptinfect_ecswip_SystemManager.getSystem(__deceptinfect_game_BatterySystem):addBattery(self.id, otherID);
    if (result) then 
      self["self"]:Remove();
    end;
  end;
end
__deceptinfect_Di_battery.prototype.funkyTown = function(self) 
  __haxe_Log.trace("HAAAR", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/Di_battery.hx",lineNumber=60,className="deceptinfect.Di_battery",methodName="funkyTown"}));
end

__deceptinfect_Di_battery.prototype.__class__ =  __deceptinfect_Di_battery
__deceptinfect_Di_battery.__super__ = __gmod_sent_ENT_ANIM
setmetatable(__deceptinfect_Di_battery.prototype,{__index=__gmod_sent_ENT_ANIM.prototype})

__deceptinfect_Di_charger.new = function(curEnt) 
  local self = _hx_new(__deceptinfect_Di_charger.prototype)
  __deceptinfect_Di_charger.super(self,curEnt)
  return self
end
__deceptinfect_Di_charger.super = function(self,curEnt) 
  self.properties = _hx_o({__fields__={Base=true},Base="base_entity"});
  __gmod_sent_ENT_ANIM.super(self);
  self["self"] = curEnt;
end
_hx_exports["di_charger"] = __deceptinfect_Di_charger
__deceptinfect_Di_charger.__name__ = "deceptinfect.Di_charger"
__deceptinfect_Di_charger.prototype = _hx_a();
__deceptinfect_Di_charger.prototype.Initialize = function(self) 
  self["self"]:SetModel("models/props_c17/chair02a.mdl");
  self["self"]:PhysicsInit(_G.SOLID_VPHYSICS);
  local physob = self["self"]:GetPhysicsObject();
  if (_G.IsValid(physob)) then 
    physob:Wake();
  end;
  physob:EnableMotion(false);
  local x = self["self"];
  local this1 = x;
  x.id = __deceptinfect_ecswip_ComponentManager.addGEnt(this1);
  local ent = this1;
  self.id = ent.id;
  local this2 = self.id;
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_game_BatteryAccepter.new(), this2);
end

__deceptinfect_Di_charger.prototype.__class__ =  __deceptinfect_Di_charger
__deceptinfect_Di_charger.__super__ = __gmod_sent_ENT_ANIM
setmetatable(__deceptinfect_Di_charger.prototype,{__index=__gmod_sent_ENT_ANIM.prototype})

__deceptinfect_Di_nest.new = function(curEnt) 
  local self = _hx_new(__deceptinfect_Di_nest.prototype)
  __deceptinfect_Di_nest.super(self,curEnt)
  return self
end
__deceptinfect_Di_nest.super = function(self,curEnt) 
  self.properties = _hx_o({__fields__={Base=true},Base="base_entity"});
  __gmod_sent_ENT_ANIM.super(self);
  self["self"] = curEnt;
end
_hx_exports["di_nest"] = __deceptinfect_Di_nest
__deceptinfect_Di_nest.__name__ = "deceptinfect.Di_nest"
__deceptinfect_Di_nest.prototype = _hx_a();
__deceptinfect_Di_nest.prototype.Initialize = function(self) 
  self["self"]:SetModel("models/props_c17/chair02a.mdl");
  local x = self["self"];
  local this1 = x;
  x.id = __deceptinfect_ecswip_ComponentManager.addGEnt(this1);
  local ent = this1;
  self.id = ent.id;
  local this2 = self.id;
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_game_NestComponent.new(), this2);
end
__deceptinfect_Di_nest.prototype.Think = function(self) 
  local ent = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
  while (ent:hasNext()) do 
    local ent1 = ent:next();
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectedComponent);
    local comp = comparray[ent1];
    local _g1 = comp;
    local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
    local comp1 = comparray1[ent1];
    local _g2 = comp1;
    if (_g2[1] == 1) then 
      local _g3 = _g2[2];
      local tmp = _g1[1];
      if (tmp) == 0 then 
        local ply = _g3;
        self["self"]:SetPreventTransmit(ply.player, true);
      elseif (tmp) == 1 then 
        local _g4 = _g1[2];
        local ply1 = _g3;
        self["self"]:SetPreventTransmit(ply1.player, false); end;
    end;
  end;
  do return nil end
end
__deceptinfect_Di_nest.prototype.TestCollision = function(self,startpos,delta,isbox,extents,mask) 
  do return _hx_o({__fields__={HitPos=true,Fraction=true},HitPos=startpos,Fraction=0}) end
end

__deceptinfect_Di_nest.prototype.__class__ =  __deceptinfect_Di_nest
__deceptinfect_Di_nest.__super__ = __gmod_sent_ENT_ANIM
setmetatable(__deceptinfect_Di_nest.prototype,{__index=__gmod_sent_ENT_ANIM.prototype})

__deceptinfect__GEntCompat_GEntCompat_Impl_.new = {}
__deceptinfect__GEntCompat_GEntCompat_Impl_.__name__ = "deceptinfect._GEntCompat.GEntCompat_Impl_"
__deceptinfect__GEntCompat_GEntCompat_Impl_.get_id = function(this1) 
  do return this1.id end;
end
__deceptinfect__GEntCompat_GEntCompat_Impl_.has_id = function(this1) 
  local _g = this1.id;
  if (_g == nil) then 
    do return __haxe_ds_Option.None end;
  else
    local x = _g;
    do return __haxe_ds_Option.Some(x) end;
  end;
end
__deceptinfect__GEntCompat_GEntCompat_Impl_.get = function(this1,x) 
  local this2 = this1.id;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x);
  local comp = comparray[this2];
  do return comp end;
end
__deceptinfect__GEntCompat_GEntCompat_Impl_.infectedPlayer = function(this1) 
  local _g;
  local _g1 = this1.id;
  if (_g1 == nil) then 
    _g = __haxe_ds_Option.None;
  else
    local x = _g1;
    _g = __haxe_ds_Option.Some(x);
  end;
  if (_g[1] == 0) then 
    local id = _g[2];
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectedComponent);
    local comp = comparray[id];
    local _g2 = comp;
    local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
    local comp1 = comparray1[id];
    local _g11 = comp1;
    if (_g11[1] == 1) then 
      if (_g2[1] == 1) then 
        local _g3 = _g2[2];
        local p = _g11[2];
        do return __haxe_ds_Option.Some(p) end;
      else
        do return __haxe_ds_Option.None end;
      end;
    else
      do return __haxe_ds_Option.None end;
    end;
  else
    do return __haxe_ds_Option.None end;
  end;
end
__deceptinfect__GEntCompat_GEntCompat_Impl_.isPlayer = function(this1) 
  local _g;
  local _g1 = this1.id;
  if (_g1 == nil) then 
    _g = __haxe_ds_Option.None;
  else
    local x = _g1;
    _g = __haxe_ds_Option.Some(x);
  end;
  if (_g[1] == 0) then 
    local id = _g[2];
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
    local comp = comparray[id];
    local _g2 = comp;
    if (_g2[1] == 1) then 
      local p = _g2[2];
      do return __haxe_ds_Option.Some(p) end;
    else
      do return __haxe_ds_Option.None end;
    end;
  else
    do return __haxe_ds_Option.None end;
  end;
end
__deceptinfect__GEntCompat_GEntCompat_Impl_._new = function(x) 
  local this1 = x;
  x.id = __deceptinfect_ecswip_ComponentManager.addGEnt(this1);
  do return this1 end;
end

__deceptinfect__GEntCompat_GPlayerCompat_Impl_.new = {}
__deceptinfect__GEntCompat_GPlayerCompat_Impl_.__name__ = "deceptinfect._GEntCompat.GPlayerCompat_Impl_"
__deceptinfect__GEntCompat_GPlayerCompat_Impl_.get_id = function(this1) 
  do return this1.id end;
end
__deceptinfect__GEntCompat_GPlayerCompat_Impl_.has_id = function(this1) 
  local _g = this1.id;
  if (_g == nil) then 
    do return __haxe_ds_Option.None end;
  else
    local x = _g;
    do return __haxe_ds_Option.Some(x) end;
  end;
end
__deceptinfect__GEntCompat_GPlayerCompat_Impl_.has_id_2 = function(this1) 
  local _g = this1.id;
  if (_g == nil) then 
    do return false end;
  else
    local x = _g;
    do return true end;
  end;
end
__deceptinfect__GEntCompat_GPlayerCompat_Impl_.get = function(this1,x) 
  local this2 = this1.id;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x);
  local comp = comparray[this2];
  do return comp end;
end
__deceptinfect__GEntCompat_GPlayerCompat_Impl_.isInfected = function(this1) 
  local this2 = this1.id;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectedComponent);
  local comp = comparray[this2];
  do return Type.enumEq(comp, __deceptinfect_ecswip_ComponentState.Comp(nil)) end;
end
__deceptinfect__GEntCompat_GPlayerCompat_Impl_._new = function(x) 
  local this1 = x.player;
  x.player.id = __deceptinfect_ecswip_ComponentManager.addPlayer(this1);
  do return this1 end;
end

__deceptinfect_GameInstance.new = function() 
  local self = _hx_new(__deceptinfect_GameInstance.prototype)
  __deceptinfect_GameInstance.super(self)
  return self
end
__deceptinfect_GameInstance.super = function(self) 
  local ret = ({length = 1});
  ret[0] = 0.0;
  self.baseInfection = ret;
  self.lastTick = nil;
  self.totalGameTime = 0;
  self.players = _hx_tab_array({}, 0);
  self.numPlayers = 0;
end
__deceptinfect_GameInstance.__name__ = "deceptinfect.GameInstance"
__deceptinfect_GameInstance.prototype = _hx_a();
__deceptinfect_GameInstance.prototype.start = function(self) 
  self:setTime();
  self:calcBaseInfection();
end
__deceptinfect_GameInstance.prototype.get_diffTime = function(self) 
  if (self.lastTick ~= nil) then 
    do return _G.CurTime() - self.lastTick end;
  else
    do return 0 end;
  end;
end
__deceptinfect_GameInstance.prototype.think = function(self) 
  self.baseInfection[0] = self:calcBaseInfection();
end
__deceptinfect_GameInstance.prototype.addPlayers = function(self) 
  local player = __gmod_PairTools.iterator(_G.player.GetAll());
  while (player:hasNext()) do 
    local player1 = player:next();
    self.players:push(player1);
  end;
end
__deceptinfect_GameInstance.prototype.calcBaseInfection = function(self) 
  local baseInf = (100 / self.totalGameTime) * self:get_diffTime();
  do return baseInf end
end
__deceptinfect_GameInstance.prototype.setTime = function(self) 
  local time = __deceptinfect_GameValues.GAME_TIMER;
  local variance = __deceptinfect_GameValues.GAME_TIMER_VARIANCE;
  self.totalGameTime = time + _G.math.random(-variance, variance);
  __haxe_Log.trace(Std.string("Time until infection: ") .. Std.string(self.totalGameTime), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/GameInstance.hx",lineNumber=63,className="deceptinfect.GameInstance",methodName="setTime"}));
end

__deceptinfect_GameInstance.prototype.__class__ =  __deceptinfect_GameInstance
_hxClasses["deceptinfect.PLAYING_STATE"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="NORMAL","EVAC"},2)}
__deceptinfect_PLAYING_STATE = _hxClasses["deceptinfect.PLAYING_STATE"];
__deceptinfect_PLAYING_STATE.NORMAL = _hx_tab_array({[0]="NORMAL",0,__enum__ = __deceptinfect_PLAYING_STATE},2)

__deceptinfect_PLAYING_STATE.EVAC = _hx_tab_array({[0]="EVAC",1,__enum__ = __deceptinfect_PLAYING_STATE},2)

_hxClasses["deceptinfect.GAME_STATE"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="WAIT","SETTING_UP","PLAYING","ENDING"},4)}
__deceptinfect_GAME_STATE = _hxClasses["deceptinfect.GAME_STATE"];
__deceptinfect_GAME_STATE.WAIT = _hx_tab_array({[0]="WAIT",0,__enum__ = __deceptinfect_GAME_STATE},2)

__deceptinfect_GAME_STATE.SETTING_UP = function(x) local _x = _hx_tab_array({[0]="SETTING_UP",1,x,__enum__=__deceptinfect_GAME_STATE}, 3); return _x; end 
__deceptinfect_GAME_STATE.PLAYING = function(x) local _x = _hx_tab_array({[0]="PLAYING",2,x,__enum__=__deceptinfect_GAME_STATE}, 3); return _x; end 
__deceptinfect_GAME_STATE.ENDING = function(x) local _x = _hx_tab_array({[0]="ENDING",3,x,__enum__=__deceptinfect_GAME_STATE}, 3); return _x; end 

__deceptinfect_GameManager.new = {}
__deceptinfect_GameManager.__name__ = "deceptinfect.GameManager"
__deceptinfect_GameManager.shouldAllowRespawn = function() 
  if (__deceptinfect_GameManager.state[1] == 0) then 
    do return true end;
  else
    do return false end;
  end;
end
__deceptinfect_GameManager.sure = function() 
  local _g = __deceptinfect_GameManager.state;
  local tmp = _g[1];
  if (tmp) == 0 then 
    _G.error("Game not avaliable at sure statement!",0);
  elseif (tmp) == 1 then 
    local x = _g[2];
    do return x end;
  elseif (tmp) == 2 then 
    local x1 = _g[2];
    do return x1 end;
  elseif (tmp) == 3 then 
    local x2 = _g[2];
    do return x2 end; end;
end
__deceptinfect_GameManager.initPlayer = function(ply) 
  local p = ply.id;
  local infcomp = __deceptinfect_infection_InfectionComponent.new();
  local spec = __deceptinfect_ecswip_SpectateComponent.new();
  local rate = __deceptinfect_infection_RateComponent.new();
  local health = __deceptinfect_ecswip_HiddenHealthComponent.new();
  local grabaccept = __deceptinfect_ecswip_GrabAccepter.new();
  local radaccept = __deceptinfect_radiation_RadiationAccepter.new(_hx_o({__fields__={contaminate=true},contaminate=__deceptinfect_radiation_ContaminationAccepter.new()}));
  local virpos = __deceptinfect_ecswip_VirtualPosition.new(ply);
  __deceptinfect_ecswip_ComponentManager.addComponent(infcomp, p);
  __deceptinfect_ecswip_ComponentManager.addComponent(spec, p);
  __deceptinfect_ecswip_ComponentManager.addComponent(rate, p);
  __deceptinfect_ecswip_ComponentManager.addComponent(health, p);
  __deceptinfect_ecswip_ComponentManager.addComponent(grabaccept, p);
  __deceptinfect_ecswip_ComponentManager.addComponent(radaccept, p);
  __deceptinfect_ecswip_ComponentManager.addComponent(virpos, p);
end
__deceptinfect_GameManager.thinkWait = function() 
  if (_G.player.GetCount() > __deceptinfect_GameValues.MIN_PLAYERS) then 
    __deceptinfect_GameManager.initAllPlayers();
  end;
end
__deceptinfect_GameManager.startWait = function() 
  local player = __gmod_PairTools.iterator(_G.player.GetAll());
  while (player:hasNext()) do 
    local player1 = player:next();
    player1:KillSilent();
  end;
end
__deceptinfect_GameManager.set_state = function(x) 
  local p = __gmod_PairTools.iterator(_G.player.GetAll());
  while (p:hasNext()) do 
    local p1 = p:next();
    __deceptinfect_Networking.sendGameState(_hx_o({__fields__={state=true},state=__deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.fromGAME_STATE(x)}), p1);
  end;
  __haxe_Log.trace("set state...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/GameManager.hx",lineNumber=85,className="deceptinfect.GameManager",methodName="set_state"}));
  __deceptinfect_GameManager.state = x do return __deceptinfect_GameManager.state end;
end
__deceptinfect_GameManager.initInfectedPlayer = function(x) 
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_infection_InfectedComponent.new(), x);
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_ecswip_GrabProducer.new(), x);
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_ecswip_HiddenHealthComponent.new(), x);
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_abilities_FormComponent.new(), x);
  local x1 = __deceptinfect_infection_InfectionComponent;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x1);
  local comp = comparray[x];
  local comp1 = comp:slice(2)[0];
  if (comp1 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x1.__name__),0);
  end;
  local c_inf = comp1;
  c_inf.infection = __deceptinfect_infection_INF_STATE.INFECTED;
  local x2 = __deceptinfect_ecswip_GrabAccepter;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(x2);
  local comp2 = comparray1[x];
  local comp3 = comp2:slice(2)[0];
  if (comp3 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x2.__name__),0);
  end;
  local c_accept = comp3;
  c_accept.grabState = __deceptinfect_ecswip_GrabAcceptState.UNAVALIABLE(__deceptinfect_util_Cooldown.UNAVALIABLE);
  __haxe_Log.trace(c_accept.grabState, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/GameManager.hx",lineNumber=100,className="deceptinfect.GameManager",methodName="initInfectedPlayer"}));
  local rad = __deceptinfect_radiation_RadiationProducer.createFromType(__deceptinfect_radiation_RadTypes.INF);
  rad.state = __deceptinfect_radiation_RadiationState.DISABLED;
  __deceptinfect_ecswip_ComponentManager.addComponent(rad, x);
end
__deceptinfect_GameManager.initAllPlayers = function() 
  local player = __gmod_PairTools.iterator(_G.player.GetAll());
  while (player:hasNext()) do 
    local player1 = player:next();
    __deceptinfect_GameManager.initPlayer(player1);
  end;
end
__deceptinfect_GameManager.startGame = function() 
  __deceptinfect_GameManager.initAllPlayers();
  local game = __deceptinfect_GameInstance.new();
  __deceptinfect_GameManager.set_state(__deceptinfect_GAME_STATE.PLAYING(game));
  game:start();
end
_hx_exports["startGame"] = __deceptinfect_GameManager.startGame

__deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.new = {}
__deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.__name__ = "deceptinfect._GameManager.Net_GAME_STATE_VAL_Impl_"
__deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.fromGAME_STATE = function(x) 
  local tmp = x[1];
  if (tmp) == 0 then 
    do return 0 end;
  elseif (tmp) == 1 then 
    local _g1 = x[2];
    do return 1 end;
  elseif (tmp) == 2 then 
    local _g2 = x[2];
    do return 2 end;
  elseif (tmp) == 3 then 
    local _g = x[2];
    do return 3 end; end;
end

__deceptinfect_GameValues.new = {}
_hx_exports["GameValues"] = __deceptinfect_GameValues
__deceptinfect_GameValues.__name__ = "deceptinfect.GameValues"

__deceptinfect_Misc.new = {}
__deceptinfect_Misc.__name__ = "deceptinfect.Misc"

__deceptinfect_Networking.new = {}
__deceptinfect_Networking.__name__ = "deceptinfect.Networking"
__deceptinfect_Networking.sendInfectionMessage = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("InfectionMessage", unreliable);
  _G.net.WriteFloat(data.infection);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendTblInfectionMessage = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("InfectionMessage", unreliable);
  _G.net.WriteFloat(data.infection);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendFilterInfectionMessage = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("InfectionMessage", unreliable);
  _G.net.WriteFloat(data.infection);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendGameState = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("GameState", unreliable);
  _G.net.WriteInt(data.state, 32);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendTblGameState = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("GameState", unreliable);
  _G.net.WriteInt(data.state, 32);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendFilterGameState = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("GameState", unreliable);
  _G.net.WriteInt(data.state, 32);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendGeiger = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("Geiger", unreliable);
  _G.net.WriteFloat(data.geiger);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendTblGeiger = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("Geiger", unreliable);
  _G.net.WriteFloat(data.geiger);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendFilterGeiger = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("Geiger", unreliable);
  _G.net.WriteFloat(data.geiger);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendGrabUpdate = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("GrabUpdate", unreliable);
  _G.net.WriteEntity(data.ent);
  _G.net.WriteEntity(data.ent2);
  _G.net.WriteInt(data.index, 32);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendTblGrabUpdate = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("GrabUpdate", unreliable);
  _G.net.WriteEntity(data.ent);
  _G.net.WriteEntity(data.ent2);
  _G.net.WriteInt(data.index, 32);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendFilterGrabUpdate = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("GrabUpdate", unreliable);
  _G.net.WriteEntity(data.ent);
  _G.net.WriteEntity(data.ent2);
  _G.net.WriteInt(data.index, 32);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendGrabEnd = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("GrabEnd", unreliable);
  _G.net.WriteInt(data.index, 32);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendTblGrabEnd = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("GrabEnd", unreliable);
  _G.net.WriteInt(data.index, 32);
  _G.net.Send(player);
end
__deceptinfect_Networking.sendFilterGrabEnd = function(data,player,unreliable) 
  if (unreliable == nil) then 
    unreliable = false;
  end;
  _G.net.Start("GrabEnd", unreliable);
  _G.net.WriteInt(data.index, 32);
  _G.net.Send(player);
end
__deceptinfect_Networking.initMessages = function() 
  _G.util.AddNetworkString("InfectionMessage");
  _G.util.AddNetworkString("GameState");
  _G.util.AddNetworkString("Geiger");
  _G.util.AddNetworkString("GrabUpdate");
  _G.util.AddNetworkString("GrabEnd");
end
__deceptinfect_Networking.prototype = _hx_a();

__deceptinfect_Networking.prototype.__class__ =  __deceptinfect_Networking

__haxe_IMap.new = {}
__haxe_IMap.__name__ = "haxe.IMap"
__haxe_IMap.prototype = _hx_a();

__haxe_IMap.prototype.__class__ =  __haxe_IMap

__haxe_ds_IntMap.new = function() 
  local self = _hx_new(__haxe_ds_IntMap.prototype)
  __haxe_ds_IntMap.super(self)
  return self
end
__haxe_ds_IntMap.super = function(self) 
  self.h = ({});
end
__haxe_ds_IntMap.__name__ = "haxe.ds.IntMap"
__haxe_ds_IntMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_IntMap.prototype = _hx_a();
__haxe_ds_IntMap.prototype.set = function(self,key,value) 
  if (value == nil) then 
    self.h[key] = __haxe_ds_IntMap.tnull;
  else
    self.h[key] = value;
  end;
end
__haxe_ds_IntMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__haxe_ds_IntMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_IntMap.prototype.iterator = function(self) 
  local _gthis = self;
  local it = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return it:hasNext() end;
  end,next=function(self) 
    do return _gthis.h[it:next()] end;
  end}) end
end

__haxe_ds_IntMap.prototype.__class__ =  __haxe_ds_IntMap

__deceptinfect_PlayerManager.new = {}
__deceptinfect_PlayerManager.__name__ = "deceptinfect.PlayerManager"
__deceptinfect_PlayerManager.getIDByIndex = function(index) 
  if (__deceptinfect_PlayerManager.indexLookup.h[index] == nil) then 
    _G.error(Std.string("Entity lookup failed for ") .. Std.string(index),0);
  end;
  local ret = __deceptinfect_PlayerManager.indexLookup.h[index];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret end;
end
__deceptinfect_PlayerManager.addID = function(ent,id) 
  local this1 = __deceptinfect_PlayerManager.indexLookup;
  local key = ent:EntIndex();
  local _this = this1;
  if (id == nil) then 
    _this.h[key] = __haxe_ds_IntMap.tnull;
  else
    _this.h[key] = id;
  end;
end
__deceptinfect_PlayerManager.getPlayers = function() 
  do return _G.player.GetAll() end;
end
__deceptinfect_PlayerManager.getActivePlayers = function() 
  do return nil end;
end

__gmod_swep_SWEP.new = {}
__gmod_swep_SWEP.__name__ = "gmod.swep.SWEP"
__gmod_swep_SWEP.prototype = _hx_a();
__gmod_swep_SWEP.prototype.Deploy = function(self) 
  do return nil end
end
__gmod_swep_SWEP.prototype.TakePrimaryAmmo = function(self,amount) 
end
__gmod_swep_SWEP.prototype.CanSecondaryAttack = function(self) 
  do return nil end
end
__gmod_swep_SWEP.prototype.SecondaryAttack = function(self) 
end
__gmod_swep_SWEP.prototype.DoImpactEffect = function(self,tr,damageType) 
  do return nil end
end
__gmod_swep_SWEP.prototype.KeyValue = function(self,key,value) 
  do return nil end
end
__gmod_swep_SWEP.prototype.TranslateFOV = function(self,fov) 
  do return nil end
end
__gmod_swep_SWEP.prototype.CanBePickedUpByNPCs = function(self) 
  do return nil end
end
__gmod_swep_SWEP.prototype.GetNPCRestTimes = function(self) 
  do return nil end
end
__gmod_swep_SWEP.prototype.GetNPCBulletSpread = function(self,proficiency) 
  do return nil end
end
__gmod_swep_SWEP.prototype.GetCapabilities = function(self) 
  do return nil end
end
__gmod_swep_SWEP.prototype.Ammo2 = function(self) 
  do return nil end
end
__gmod_swep_SWEP.prototype.ShootEffects = function(self) 
end
__gmod_swep_SWEP.prototype.TakeSecondaryAmmo = function(self,amount) 
end
__gmod_swep_SWEP.prototype.CanPrimaryAttack = function(self) 
  do return nil end
end
__gmod_swep_SWEP.prototype.Reload = function(self) 
end
__gmod_swep_SWEP.prototype.ShootBullet = function(self,damage,num_bullets,aimcone,ammo_type,force,tracer) 
end
__gmod_swep_SWEP.prototype.AcceptInput = function(self,inputName,activator,called,data) 
  do return nil end
end
__gmod_swep_SWEP.prototype.OnRemove = function(self) 
end
__gmod_swep_SWEP.prototype.OwnerChanged = function(self) 
end
__gmod_swep_SWEP.prototype.Initialize = function(self) 
end
__gmod_swep_SWEP.prototype.EquipAmmo = function(self,ply) 
end
__gmod_swep_SWEP.prototype.TranslateActivity = function(self,act) 
  do return nil end
end
__gmod_swep_SWEP.prototype.Holster = function(self,weapon) 
  do return nil end
end
__gmod_swep_SWEP.prototype.SetDeploySpeed = function(self,speed) 
end
__gmod_swep_SWEP.prototype.Think = function(self) 
end
__gmod_swep_SWEP.prototype.FireAnimationEvent = function(self,pos,ang,event,options) 
  do return nil end
end
__gmod_swep_SWEP.prototype.SetupDataTables = function(self) 
end
__gmod_swep_SWEP.prototype.PrimaryAttack = function(self) 
end
__gmod_swep_SWEP.prototype.Ammo1 = function(self) 
  do return nil end
end
__gmod_swep_SWEP.prototype.OnDrop = function(self) 
end
__gmod_swep_SWEP.prototype.ShouldDropOnDie = function(self) 
  do return nil end
end
__gmod_swep_SWEP.prototype.GetNPCBurstSettings = function(self) 
  do return nil end
end
__gmod_swep_SWEP.prototype.OnRestore = function(self) 
end
__gmod_swep_SWEP.prototype.OnReloaded = function(self) 
end
__gmod_swep_SWEP.prototype.Equip = function(self,NewOwner) 
end
__gmod_swep_SWEP.prototype.SetWeaponHoldType = function(self,name) 
end

__gmod_swep_SWEP.prototype.__class__ =  __gmod_swep_SWEP

__gmod_swep_SwepBuild.new = {}
__gmod_swep_SwepBuild.__name__ = "gmod.swep.SwepBuild"
__gmod_swep_SwepBuild.prototype = _hx_a();

__gmod_swep_SwepBuild.prototype.__class__ =  __gmod_swep_SwepBuild

__deceptinfect_Weapon_di_scan.new = function(curEnt) 
  local self = _hx_new(__deceptinfect_Weapon_di_scan.prototype)
  __deceptinfect_Weapon_di_scan.super(self,curEnt)
  return self
end
__deceptinfect_Weapon_di_scan.super = function(self,curEnt) 
  self.properties = _hx_o({__fields__={Primary=true},Primary=_hx_o({__fields__={DefaultClip=true,ClipSize=true,Automatic=true,Ammo=true},DefaultClip=-1,ClipSize=-1,Automatic=false,Ammo="SMG1"})});
  self["self"] = curEnt;
end
_hx_exports["weapon_di_scan"] = __deceptinfect_Weapon_di_scan
__deceptinfect_Weapon_di_scan.__name__ = "deceptinfect.Weapon_di_scan"
__deceptinfect_Weapon_di_scan.__interfaces__ = {__gmod_swep_SwepBuild}
__deceptinfect_Weapon_di_scan.prototype = _hx_a();
__deceptinfect_Weapon_di_scan.prototype.Initialize = function(self) 
  __haxe_Log.trace("big weapon!", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/Weapon_di_scan.hx",lineNumber=18,className="deceptinfect.Weapon_di_scan",methodName="Initialize"}));
end

__deceptinfect_Weapon_di_scan.prototype.__class__ =  __deceptinfect_Weapon_di_scan
__deceptinfect_Weapon_di_scan.__super__ = __gmod_swep_SWEP
setmetatable(__deceptinfect_Weapon_di_scan.prototype,{__index=__gmod_swep_SWEP.prototype})

__deceptinfect_ecswip_Component.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_Component.prototype)
  __deceptinfect_ecswip_Component.super(self)
  return self
end
__deceptinfect_ecswip_Component.super = function(self) 
end
__deceptinfect_ecswip_Component.__name__ = "deceptinfect.ecswip.Component"
__deceptinfect_ecswip_Component.prototype = _hx_a();

__deceptinfect_ecswip_Component.prototype.__class__ =  __deceptinfect_ecswip_Component

__deceptinfect_abilities_FormComponent.new = function() 
  local self = _hx_new(__deceptinfect_abilities_FormComponent.prototype)
  __deceptinfect_abilities_FormComponent.super(self)
  return self
end
__deceptinfect_abilities_FormComponent.super = function(self) 
  self.formMaxHealth = 60.0;
  self.form = __deceptinfect_abilities_CurrentForm.HUMAN;
  self.nextCooldown = 5;
  self.cooldown = __deceptinfect_abilities_Cooldown.ACTIVE;
  self.formHealth = 60.0;
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_abilities_FormComponent.__name__ = "deceptinfect.abilities.FormComponent"
__deceptinfect_abilities_FormComponent.prototype = _hx_a();

__deceptinfect_abilities_FormComponent.prototype.__class__ =  __deceptinfect_abilities_FormComponent
__deceptinfect_abilities_FormComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_abilities_FormComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})
_hxClasses["deceptinfect.abilities.CurrentForm"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="HUMAN","INFECTED"},2)}
__deceptinfect_abilities_CurrentForm = _hxClasses["deceptinfect.abilities.CurrentForm"];
__deceptinfect_abilities_CurrentForm.HUMAN = _hx_tab_array({[0]="HUMAN",0,__enum__ = __deceptinfect_abilities_CurrentForm},2)

__deceptinfect_abilities_CurrentForm.INFECTED = _hx_tab_array({[0]="INFECTED",1,__enum__ = __deceptinfect_abilities_CurrentForm},2)

_hxClasses["deceptinfect.abilities.Cooldown"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="ACTIVE","COOLDOWN"},2)}
__deceptinfect_abilities_Cooldown = _hxClasses["deceptinfect.abilities.Cooldown"];
__deceptinfect_abilities_Cooldown.ACTIVE = _hx_tab_array({[0]="ACTIVE",0,__enum__ = __deceptinfect_abilities_Cooldown},2)

__deceptinfect_abilities_Cooldown.COOLDOWN = function(time) local _x = _hx_tab_array({[0]="COOLDOWN",1,time,__enum__=__deceptinfect_abilities_Cooldown}, 3); return _x; end 

__deceptinfect_ecswip_System.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_System.prototype)
  __deceptinfect_ecswip_System.super(self)
  return self
end
__deceptinfect_ecswip_System.super = function(self) 
end
__deceptinfect_ecswip_System.__name__ = "deceptinfect.ecswip.System"
__deceptinfect_ecswip_System.prototype = _hx_a();
__deceptinfect_ecswip_System.prototype.init_server = function(self) 
end
__deceptinfect_ecswip_System.prototype.run_server = function(self) 
end
__deceptinfect_ecswip_System.prototype.init_shared = function(self) 
end
__deceptinfect_ecswip_System.prototype.run_shared = function(self) 
end
__deceptinfect_ecswip_System.prototype.init = function(self) 
  self:init_server();
  self:init_shared();
end
__deceptinfect_ecswip_System.prototype.run = function(self) 
  self:run_server();
  self:run_shared();
end

__deceptinfect_ecswip_System.prototype.__class__ =  __deceptinfect_ecswip_System

__deceptinfect_abilities_FormSystem.new = function() 
  local self = _hx_new(__deceptinfect_abilities_FormSystem.prototype)
  __deceptinfect_abilities_FormSystem.super(self)
  return self
end
__deceptinfect_abilities_FormSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
__deceptinfect_abilities_FormSystem.__name__ = "deceptinfect.abilities.FormSystem"
__deceptinfect_abilities_FormSystem.attemptChangeForm = function(ent) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GEntityComponent);
  local comp = comparray[ent];
  local _g = comp;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_abilities_FormComponent);
  local comp1 = comparray1[ent];
  local _g1 = comp1;
  if (_g1[1] == 1) then 
    if (_g[1] == 1) then 
      local _hx_tmp;
      local c_form = _g1[2];
      _hx_tmp = _g[2].entity;
      local g_ent = _hx_tmp;
      local _g2 = c_form.cooldown;
      if (_g2[1] == 1) then 
        local time = _g2[2];
        if (not (_G.CurTime() < time)) then 
          c_form.cooldown = __deceptinfect_abilities_Cooldown.ACTIVE;
        end;
      else
        c_form.cooldown = __deceptinfect_abilities_Cooldown.ACTIVE;
      end;
      if ((c_form.formHealth > 0) and (c_form.cooldown == __deceptinfect_abilities_Cooldown.ACTIVE)) then 
        if (g_ent:Health() > 0) then 
          __deceptinfect_abilities_FormSystem.changeForm(ent);
        end;
      end;
    end;
  end;
end
__deceptinfect_abilities_FormSystem.changeForm = function(ent) 
  local x = __deceptinfect_abilities_FormComponent;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x);
  local comp = comparray[ent];
  local comp1 = comp:slice(2)[0];
  if (comp1 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x.__name__),0);
  end;
  local c_form = comp1;
  local x1 = __deceptinfect_ecswip_GEntityComponent;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(x1);
  local comp2 = comparray1[ent];
  local comp3 = comp2:slice(2)[0];
  if (comp3 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x1.__name__),0);
  end;
  local g_ent = comp3.entity;
  local curHealth = g_ent:Health();
  local curMaxHealth = g_ent:GetMaxHealth();
  g_ent:SetMaxHealth(c_form.formMaxHealth);
  g_ent:SetHealth(c_form.formHealth);
  local tmp;
  local tmp1 = c_form.form[1];
  if (tmp1) == 0 then 
    tmp = __deceptinfect_abilities_CurrentForm.INFECTED;
  elseif (tmp1) == 1 then 
    tmp = __deceptinfect_abilities_CurrentForm.HUMAN; end;
  c_form.form = tmp;
  c_form.formHealth = curHealth;
  c_form.formMaxHealth = curMaxHealth;
  c_form.cooldown = __deceptinfect_abilities_Cooldown.COOLDOWN(_G.CurTime() + c_form.nextCooldown);
end
__deceptinfect_abilities_FormSystem.prototype = _hx_a();

__deceptinfect_abilities_FormSystem.prototype.__class__ =  __deceptinfect_abilities_FormSystem
__deceptinfect_abilities_FormSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_abilities_FormSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_client_GeigerSystem.new = function() 
  local self = _hx_new(__deceptinfect_client_GeigerSystem.prototype)
  __deceptinfect_client_GeigerSystem.super(self)
  return self
end
__deceptinfect_client_GeigerSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hx_exports["geiger"] = __deceptinfect_client_GeigerSystem
__deceptinfect_client_GeigerSystem.__name__ = "deceptinfect.client.GeigerSystem"
__deceptinfect_client_GeigerSystem.prototype = _hx_a();
__deceptinfect_client_GeigerSystem.prototype.run_server = function(self) 
  local plyr = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
  while (plyr:hasNext()) do 
    local plyr1 = plyr:next();
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
    local comp = comparray[plyr1];
    local _g1 = comp;
    local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectionComponent);
    local comp1 = comparray1[plyr1];
    local _g2 = comp1;
    if (_g2[1] == 1) then 
      if (_g1[1] == 1) then 
        local _hx_tmp;
        local inf = _g2[2];
        _hx_tmp = _g1[2].player;
        local player = _hx_tmp;
        local fract = Math.min((inf.rate - 1) / 3, 1);
        __deceptinfect_Networking.sendGeiger(_hx_o({__fields__={geiger=true},geiger=fract}), player, true);
      end;
    end;
  end;
end

__deceptinfect_client_GeigerSystem.prototype.__class__ =  __deceptinfect_client_GeigerSystem
__deceptinfect_client_GeigerSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_client_GeigerSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_client_PVS.new = {}
__deceptinfect_client_PVS.__name__ = "deceptinfect.client.PVS"

__haxe_ds_ObjectMap.new = function() 
  local self = _hx_new(__haxe_ds_ObjectMap.prototype)
  __haxe_ds_ObjectMap.super(self)
  return self
end
__haxe_ds_ObjectMap.super = function(self) 
  self.h = ({});
  self.k = ({});
end
__haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap"
__haxe_ds_ObjectMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_ObjectMap.prototype = _hx_a();
__haxe_ds_ObjectMap.prototype.set = function(self,key,value) 
  self.h[key] = value;
  self.k[key] = true;
end
__haxe_ds_ObjectMap.prototype.get = function(self,key) 
  do return self.h[key] end
end
__haxe_ds_ObjectMap.prototype.keys = function(self) 
  local _gthis = self;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.k, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_ObjectMap.prototype.iterator = function(self) 
  local _gthis = self;
  local itr = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(_,...) return _hx_bind(itr,itr.hasNext)(...) end,next=function(self) 
    do return _gthis.h[itr:next()] end;
  end}) end
end

__haxe_ds_ObjectMap.prototype.__class__ =  __haxe_ds_ObjectMap

__deceptinfect_ecswip_ComponentManager.new = {}
__deceptinfect_ecswip_ComponentManager.__name__ = "deceptinfect.ecswip.ComponentManager"
__deceptinfect_ecswip_ComponentManager.addGEnt = function(x) 
  local id = __deceptinfect_ecswip_ComponentManager.addEntity();
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_ecswip_GEntityComponent.new(x), id);
  do return id end;
end
__deceptinfect_ecswip_ComponentManager.addPlayer = function(x) 
  local id = __deceptinfect_ecswip_ComponentManager.addGEnt(x);
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_ecswip_PlayerComponent.new(x), id);
  __deceptinfect_PlayerManager.addID(x, id);
  do return id end;
end
__deceptinfect_ecswip_ComponentManager.getComponentForID = function(cls,x) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(cls);
  local comp = comparray[x];
  do return comp end;
end
__deceptinfect_ecswip_ComponentManager.addComponent = function(x,to) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(Type.getClass(x));
  comparray[to] = __deceptinfect_ecswip_ComponentState.Comp(x);
end
__deceptinfect_ecswip_ComponentManager.lazyInit = function(x) 
  local comparray = __deceptinfect_ecswip_ComponentManager.components.h[x];
  if (comparray == nil) then 
    comparray = _hx_tab_array({}, 0);
    local _this = __deceptinfect_ecswip_ComponentManager.components;
    _this.h[x] = comparray;
    _this.k[x] = true;
    local entity = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
    while (entity:hasNext()) do 
      local entity1 = entity:next();
      comparray[entity1] = __deceptinfect_ecswip_ComponentState.NONE;
    end;
  end;
  do return comparray end;
end
__deceptinfect_ecswip_ComponentManager.removeComponent = function(x,from) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x);
  comparray[from] = __deceptinfect_ecswip_ComponentState.NONE;
end
__deceptinfect_ecswip_ComponentManager.removeEntity = function(x) 
  local component = __deceptinfect_ecswip_ComponentManager.components:iterator();
  while (component:hasNext()) do 
    local component1 = component:next();
    component1[x] = __deceptinfect_ecswip_ComponentState.NONE;
  end;
  __deceptinfect_ecswip_ComponentManager.activeEntities = __deceptinfect_ecswip_ComponentManager.activeEntities - 1;
end
__deceptinfect_ecswip_ComponentManager.addToAllCompArrays = function() 
  local compArray = __deceptinfect_ecswip_ComponentManager.components:iterator();
  while (compArray:hasNext()) do 
    local compArray1 = compArray:next();
    compArray1:push(__deceptinfect_ecswip_ComponentState.NONE);
  end;
end
__deceptinfect_ecswip_ComponentManager.getComponents = function(cls) 
  do return __deceptinfect_ecswip_ComponentManager.components.h[cls] end;
end
__deceptinfect_ecswip_ComponentManager.addEntity = function() 
  __deceptinfect_ecswip_ComponentManager.entities = __deceptinfect_ecswip_ComponentManager.entities + 1;
  __deceptinfect_ecswip_ComponentManager.activeEntities = __deceptinfect_ecswip_ComponentManager.activeEntities + 1;
  __deceptinfect_ecswip_ComponentManager.addToAllCompArrays();
  do return __deceptinfect_ecswip_ComponentManager.entities - 1 end;
end

__deceptinfect_ecswip__ComponentManager_DI_ID_Impl_.new = {}
__deceptinfect_ecswip__ComponentManager_DI_ID_Impl_.__name__ = "deceptinfect.ecswip._ComponentManager.DI_ID_Impl_"
__deceptinfect_ecswip__ComponentManager_DI_ID_Impl_.get_sure = function(this1,x) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x);
  local comp = comparray[this1];
  local comp1 = comp:slice(2)[0];
  if (comp1 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x.__name__),0);
  end;
  do return comp1 end;
end
__deceptinfect_ecswip__ComponentManager_DI_ID_Impl_._new = function(x) 
  local this1 = x;
  do return this1 end;
end

__deceptinfect_ecswip_ComponentTools.new = {}
__deceptinfect_ecswip_ComponentTools.__name__ = "deceptinfect.ecswip.ComponentTools"
__deceptinfect_ecswip_ComponentTools.sure = function(x) 
  if (x[1] == 1) then 
    local comp = x[2];
    do return comp end;
  else
    _G.error("Component not avaliable...",0);
  end;
end
_hxClasses["deceptinfect.ecswip.ComponentState"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="NONE","Comp"},2)}
__deceptinfect_ecswip_ComponentState = _hxClasses["deceptinfect.ecswip.ComponentState"];
__deceptinfect_ecswip_ComponentState.NONE = _hx_tab_array({[0]="NONE",0,__enum__ = __deceptinfect_ecswip_ComponentState},2)

__deceptinfect_ecswip_ComponentState.Comp = function(comp) local _x = _hx_tab_array({[0]="Comp",1,comp,__enum__=__deceptinfect_ecswip_ComponentState}, 3); return _x; end 
_hxClasses["deceptinfect.ecswip.HasGEnt"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="NONE","GEnt"},2)}
__deceptinfect_ecswip_HasGEnt = _hxClasses["deceptinfect.ecswip.HasGEnt"];
__deceptinfect_ecswip_HasGEnt.NONE = _hx_tab_array({[0]="NONE",0,__enum__ = __deceptinfect_ecswip_HasGEnt},2)

__deceptinfect_ecswip_HasGEnt.GEnt = function(e) local _x = _hx_tab_array({[0]="GEnt",1,e,__enum__=__deceptinfect_ecswip_HasGEnt}, 3); return _x; end 

__deceptinfect_ecswip_Family.new = function(a) 
  local self = _hx_new(__deceptinfect_ecswip_Family.prototype)
  __deceptinfect_ecswip_Family.super(self,a)
  return self
end
__deceptinfect_ecswip_Family.super = function(self,a) 
  a = self.familyMap;
end
__deceptinfect_ecswip_Family.__name__ = "deceptinfect.ecswip.Family"
__deceptinfect_ecswip_Family.prototype = _hx_a();
__deceptinfect_ecswip_Family.prototype.retrieveComponents = function(self,ent) 
  local map = __haxe_ds_ObjectMap.new();
  local _g = 0;
  local _g1 = self.familyMap;
  while (_g < _g1.length) do 
    local component = _g1[_g];
    _g = _g + 1;
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(component);
    local comp = comparray[ent];
    local _g2 = comp;
    local tmp = _g2[1];
    if (tmp) == 0 then 
      do return __haxe_ds_Option.None end;
    elseif (tmp) == 1 then 
      local comp1 = _g2[2];
      map.h[component] = comp1;
      map.k[component] = true; end;
  end;
  do return __haxe_ds_Option.Some(map) end
end

__deceptinfect_ecswip_Family.prototype.__class__ =  __deceptinfect_ecswip_Family

__deceptinfect_ecswip_GEntityComponent.new = function(e) 
  local self = _hx_new(__deceptinfect_ecswip_GEntityComponent.prototype)
  __deceptinfect_ecswip_GEntityComponent.super(self,e)
  return self
end
__deceptinfect_ecswip_GEntityComponent.super = function(self,e) 
  __deceptinfect_ecswip_Component.super(self);
  self.entity = e;
end
__deceptinfect_ecswip_GEntityComponent.__name__ = "deceptinfect.ecswip.GEntityComponent"
__deceptinfect_ecswip_GEntityComponent.prototype = _hx_a();

__deceptinfect_ecswip_GEntityComponent.prototype.__class__ =  __deceptinfect_ecswip_GEntityComponent
__deceptinfect_ecswip_GEntityComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_GEntityComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_ecswip_GrabAccepter.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_GrabAccepter.prototype)
  __deceptinfect_ecswip_GrabAccepter.super(self)
  return self
end
__deceptinfect_ecswip_GrabAccepter.super = function(self) 
  self.overwhelm = 2;
  self.numTargeting = 0;
  self.targeting = __haxe_ds_ObjectMap.new();
  self.grabState = __deceptinfect_ecswip_GrabAcceptState.NOT_GRABBED;
  self.grabAttacker = __haxe_ds_ObjectMap.new();
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_ecswip_GrabAccepter.__name__ = "deceptinfect.ecswip.GrabAccepter"
__deceptinfect_ecswip_GrabAccepter.prototype = _hx_a();

__deceptinfect_ecswip_GrabAccepter.prototype.__class__ =  __deceptinfect_ecswip_GrabAccepter
__deceptinfect_ecswip_GrabAccepter.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_GrabAccepter.prototype,{__index=__deceptinfect_ecswip_Component.prototype})
_hxClasses["deceptinfect.ecswip.GrabAcceptState"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="NOT_GRABBED","GRABBED","UNAVALIABLE"},3)}
__deceptinfect_ecswip_GrabAcceptState = _hxClasses["deceptinfect.ecswip.GrabAcceptState"];
__deceptinfect_ecswip_GrabAcceptState.NOT_GRABBED = _hx_tab_array({[0]="NOT_GRABBED",0,__enum__ = __deceptinfect_ecswip_GrabAcceptState},2)

__deceptinfect_ecswip_GrabAcceptState.GRABBED = _hx_tab_array({[0]="GRABBED",1,__enum__ = __deceptinfect_ecswip_GrabAcceptState},2)

__deceptinfect_ecswip_GrabAcceptState.UNAVALIABLE = function(x) local _x = _hx_tab_array({[0]="UNAVALIABLE",2,x,__enum__=__deceptinfect_ecswip_GrabAcceptState}, 3); return _x; end 

__deceptinfect_ecswip_GrabProducer.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_GrabProducer.prototype)
  __deceptinfect_ecswip_GrabProducer.super(self)
  return self
end
__deceptinfect_ecswip_GrabProducer.super = function(self) 
  self.grabState = __deceptinfect_ecswip_GrabProduceState.READY(__deceptinfect_ecswip_SearchingState.NOT_SEARCHING);
  self.grabDist = 70;
  self.nextCooldown = 5;
  self.targeting = nil;
  self.looktargets = false;
  self.threshold = 50.0;
  self.damage = 0.0;
  self.grabinc = 0.0;
  self.grabindex = 0;
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_ecswip_GrabProducer.__name__ = "deceptinfect.ecswip.GrabProducer"
__deceptinfect_ecswip_GrabProducer.prototype = _hx_a();
__deceptinfect_ecswip_GrabProducer.prototype.set_grabState = function(self,newGrabState) 
  local _g = self.grabState;
  if (_g[1] == 0) then 
    local _g1 = _g[2];
    if (_g1[1] == 2) then 
      local _g2 = _g1[2];
      if (newGrabState[1] == 0) then 
        local _g3 = newGrabState[2];
        if (_g3[1] == 2) then 
          local old = _g2;
          local newt = _g3[2];
          if (old ~= newt) then 
            local old1 = _g2;
            local x = newGrabState;
            local x1 = __deceptinfect_ecswip_GrabAccepter;
            local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x1);
            local comp = comparray[old1];
            local comp1 = comp:slice(2)[0];
            if (comp1 == nil) then 
              _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x1.__name__),0);
            end;
            local c_accept = comp1;
            c_accept.numTargeting = c_accept.numTargeting - 1;
          end;
        else
          local old2 = _g2;
          local x2 = newGrabState;
          local x3 = __deceptinfect_ecswip_GrabAccepter;
          local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(x3);
          local comp2 = comparray1[old2];
          local comp3 = comp2:slice(2)[0];
          if (comp3 == nil) then 
            _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x3.__name__),0);
          end;
          local c_accept1 = comp3;
          c_accept1.numTargeting = c_accept1.numTargeting - 1;
        end;
      else
        local old3 = _g2;
        local x4 = newGrabState;
        local x5 = __deceptinfect_ecswip_GrabAccepter;
        local comparray2 = __deceptinfect_ecswip_ComponentManager.lazyInit(x5);
        local comp4 = comparray2[old3];
        local comp5 = comp4:slice(2)[0];
        if (comp5 == nil) then 
          _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x5.__name__),0);
        end;
        local c_accept2 = comp5;
        c_accept2.numTargeting = c_accept2.numTargeting - 1;
      end;
    end;
  end;
  self.grabState = newGrabState do return self.grabState end
end

__deceptinfect_ecswip_GrabProducer.prototype.__class__ =  __deceptinfect_ecswip_GrabProducer
__deceptinfect_ecswip_GrabProducer.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_GrabProducer.prototype,{__index=__deceptinfect_ecswip_Component.prototype})
_hxClasses["deceptinfect.ecswip.SearchingState"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="NOT_SEARCHING","SEARCHING","TARGET"},3)}
__deceptinfect_ecswip_SearchingState = _hxClasses["deceptinfect.ecswip.SearchingState"];
__deceptinfect_ecswip_SearchingState.NOT_SEARCHING = _hx_tab_array({[0]="NOT_SEARCHING",0,__enum__ = __deceptinfect_ecswip_SearchingState},2)

__deceptinfect_ecswip_SearchingState.SEARCHING = _hx_tab_array({[0]="SEARCHING",1,__enum__ = __deceptinfect_ecswip_SearchingState},2)

__deceptinfect_ecswip_SearchingState.TARGET = function(vic) local _x = _hx_tab_array({[0]="TARGET",2,vic,__enum__=__deceptinfect_ecswip_SearchingState}, 3); return _x; end 
_hxClasses["deceptinfect.ecswip.GrabProduceState"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="READY","GRABBING","NOT_READY"},3)}
__deceptinfect_ecswip_GrabProduceState = _hxClasses["deceptinfect.ecswip.GrabProduceState"];
__deceptinfect_ecswip_GrabProduceState.READY = function(search) local _x = _hx_tab_array({[0]="READY",0,search,__enum__=__deceptinfect_ecswip_GrabProduceState}, 3); return _x; end 
__deceptinfect_ecswip_GrabProduceState.GRABBING = function(victim) local _x = _hx_tab_array({[0]="GRABBING",1,victim,__enum__=__deceptinfect_ecswip_GrabProduceState}, 3); return _x; end 
__deceptinfect_ecswip_GrabProduceState.NOT_READY = function(x) local _x = _hx_tab_array({[0]="NOT_READY",2,x,__enum__=__deceptinfect_ecswip_GrabProduceState}, 3); return _x; end 

__deceptinfect_ecswip_GrabSystem.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_GrabSystem.prototype)
  __deceptinfect_ecswip_GrabSystem.super(self)
  return self
end
__deceptinfect_ecswip_GrabSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
__deceptinfect_ecswip_GrabSystem.__name__ = "deceptinfect.ecswip.GrabSystem"
__deceptinfect_ecswip_GrabSystem.grabDamage = function(ent,dmg) 
  if (ent:IsPlayer()) then 
    local this1 = ent.id;
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabProducer);
    local comp = comparray[this1];
    local _g = comp;
    if (_g[1] == 1) then 
      local c_produce = _g[2];
      local _g1 = c_produce.grabState;
      if (_g1[1] == 1) then 
        local _g11 = _g1[2];
        local c_produce1 = c_produce;
        c_produce1.damage = c_produce1.damage + dmg:GetDamage();
        if (c_produce.damage >= c_produce.threshold) then 
          __deceptinfect_ecswip_GrabSystem.grabStop(ent.id);
          c_produce:set_grabState(__deceptinfect_ecswip_GrabProduceState.NOT_READY(__deceptinfect_util_Cooldown.COOLDOWN(_G.CurTime() + c_produce.nextCooldown)));
        end;
      end;
    end;
  end;
  do return nil end;
end
__deceptinfect_ecswip_GrabSystem.grabStop = function(attack) 
  local x = __deceptinfect_ecswip_GrabProducer;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x);
  local comp = comparray[attack];
  local comp1 = comp:slice(2)[0];
  if (comp1 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x.__name__),0);
  end;
  local c_produce = comp1;
  local x1 = __deceptinfect_ecswip_VirtualPosition;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(x1);
  local comp2 = comparray1[attack];
  local comp3 = comp2:slice(2)[0];
  if (comp3 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x1.__name__),0);
  end;
  local attackPos = comp3:get_pos();
  local vic;
  local _g = c_produce.grabState;
  if (_g[1] == 1) then 
    local victim = _g[2];
    vic = victim;
  else
    do return end;
  end;
  local x2 = __deceptinfect_ecswip_VirtualPosition;
  local comparray2 = __deceptinfect_ecswip_ComponentManager.lazyInit(x2);
  local comp4 = comparray2[vic];
  local comp5 = comp4:slice(2)[0];
  if (comp5 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x2.__name__),0);
  end;
  local vicPos = comp5:get_pos();
  local x3 = __deceptinfect_ecswip_GrabAccepter;
  local comparray3 = __deceptinfect_ecswip_ComponentManager.lazyInit(x3);
  local comp6 = comparray3[vic];
  local comp7 = comp6:slice(2)[0];
  if (comp7 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x3.__name__),0);
  end;
  local c_accept = comp7;
  c_produce:set_grabState(__deceptinfect_ecswip_GrabProduceState.NOT_READY(__deceptinfect_util_Cooldown.COOLDOWN(_G.CurTime() + 2)));
  local _this = c_accept.grabAttacker;
  _this.h[c_produce] = false;
  _this.k[c_produce] = true;
  local comparray4 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
  local comp8 = comparray4[vic];
  local _g2 = comp8;
  if (_g2[1] == 1) then 
    local plyr = _g2[2];
    plyr.player:Freeze(false);
  end;
  local comparray5 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
  local comp9 = comparray5[attack];
  local _g4 = comp9;
  if (_g4[1] == 1) then 
    local plyr1 = _g4[2];
    plyr1.player:Freeze(false);
  end;
  local filter = _G.RecipientFilter();
  filter:AddPVS(attackPos);
  filter:AddPVS(vicPos);
  __deceptinfect_Networking.sendFilterGrabEnd(_hx_o({__fields__={index=true},index=c_produce.grabindex}), filter);
end
__deceptinfect_ecswip_GrabSystem.attemptGrab = function(attack,vic) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabAccepter);
  local comp = comparray[vic];
  local _g = comp;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabProducer);
  local comp1 = comparray1[attack];
  local _g1 = comp1;
  if (_g1[1] == 1) then 
    if (_g[1] == 1) then 
      local c_produce = _g1[2];
      local c_accept = _g[2];
      local _g11 = c_produce.grabState;
      if (_g11[1] == 0) then 
        local _g2 = _g11[2];
        if (_g2[1] == 2) then 
          if (c_accept.grabState[1] == 0) then 
            local vic1 = _g2[2];
            __haxe_Log.trace(Std.string("c_accpet ") .. Std.string(Std.string(c_accept.grabState)), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/ecswip/GrabSystem.hx",lineNumber=234,className="deceptinfect.ecswip.GrabSystem",methodName="attemptGrab"}));
            __deceptinfect_ecswip_GrabSystem.grabStart(attack, vic1);
          end;
        end;
      end;
    end;
  end;
end
__deceptinfect_ecswip_GrabSystem.requestStartSearch = function(attack) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabProducer);
  local comp = comparray[attack];
  local _g = comp;
  if (_g[1] == 1) then 
    local _g1 = _g[2];
    local _hx_tmp = _g1.grabState;
    if (_hx_tmp[1] == 0) then 
      if (_hx_tmp[2][1] == 0) then 
        local c_produce = _g1;
        c_produce:set_grabState(__deceptinfect_ecswip_GrabProduceState.READY(__deceptinfect_ecswip_SearchingState.SEARCHING));
      end;
    end;
  end;
end
__deceptinfect_ecswip_GrabSystem.requestStopSearch = function(attack) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabProducer);
  local comp = comparray[attack];
  local _g = comp;
  if (_g[1] == 1) then 
    local _g1 = _g[2];
    local _hx_tmp = _g1.grabState;
    if (_hx_tmp[1] == 0) then 
      local _g2 = _hx_tmp[2];
      local tmp = _g2[1];
      if (tmp) == 1 then 
        local c_produce = _g1;
        c_produce:set_grabState(__deceptinfect_ecswip_GrabProduceState.READY(__deceptinfect_ecswip_SearchingState.NOT_SEARCHING));
      elseif (tmp) == 2 then 
        local _g3 = _g2[2];
        local c_produce1 = _g1;
        c_produce1:set_grabState(__deceptinfect_ecswip_GrabProduceState.READY(__deceptinfect_ecswip_SearchingState.NOT_SEARCHING));else end;
    end;
  end;
end
__deceptinfect_ecswip_GrabSystem.attemptSneakAttack = function(attack,vic) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GEntityComponent);
  local comp = comparray[attack];
  local _g = comp;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GEntityComponent);
  local comp1 = comparray1[vic];
  local _g1 = comp1;
  if (_g1[1] == 1) then 
    if (_g[1] == 1) then 
      local _hx_tmp;
      local _hx_tmp1;
      _hx_tmp1 = _g1[2].entity;
      local g_vic = _hx_tmp1;
      _hx_tmp = _g[2].entity;
      local g_attack = _hx_tmp;
      if (__deceptinfect_util_EntityExt.facingBehind(g_vic, g_attack)) then 
        __deceptinfect_ecswip_GrabSystem.attemptGrab(attack, vic);
      end;
    end;
  end;
end
__deceptinfect_ecswip_GrabSystem.attemptTarget = function(attack,vic) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabAccepter);
  local comp = comparray[vic];
  local _g = comp;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabProducer);
  local comp1 = comparray1[attack];
  local _g1 = comp1;
  if (_g1[1] == 1) then 
    if (_g[1] == 1) then 
      local c_produce = _g1[2];
      local c_accept = _g[2];
      local _g2 = c_produce.grabState;
      if (c_accept.grabState[1] == 0) then 
        if (_g2[1] == 0) then 
          local _g21 = _g2[2];
          local tmp = _g21[1];
          if (tmp) == 1 then 
            __haxe_Log.trace(c_accept.grabState, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/ecswip/GrabSystem.hx",lineNumber=278,className="deceptinfect.ecswip.GrabSystem",methodName="attemptTarget"}));
            __deceptinfect_ecswip_GrabSystem.attemptSneakAttack(attack, vic);
            __deceptinfect_ecswip_GrabSystem.target(attack, vic);
            if (c_accept.numTargeting >= c_accept.overwhelm) then 
              __deceptinfect_ecswip_GrabSystem.attemptGrab(attack, vic);
            end;
          elseif (tmp) == 2 then 
            local _g3 = _g21[2];
            __haxe_Log.trace(c_accept.grabState, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/ecswip/GrabSystem.hx",lineNumber=278,className="deceptinfect.ecswip.GrabSystem",methodName="attemptTarget"}));
            __deceptinfect_ecswip_GrabSystem.attemptSneakAttack(attack, vic);
            __deceptinfect_ecswip_GrabSystem.target(attack, vic);
            if (c_accept.numTargeting >= c_accept.overwhelm) then 
              __deceptinfect_ecswip_GrabSystem.attemptGrab(attack, vic);
            end;else end;
        end;
      end;
    end;
  end;
end
__deceptinfect_ecswip_GrabSystem.clearTargetingVic = function(vic) 
  local x = __deceptinfect_ecswip_GrabAccepter;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x);
  local comp = comparray[vic];
  local comp1 = comp:slice(2)[0];
  if (comp1 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x.__name__),0);
  end;
  local c_accept = comp1;
  local c_produce = c_accept.targeting:keys();
  while (c_produce:hasNext()) do 
    local c_produce1 = c_produce:next();
    local _g = c_produce1.grabState;
    if (_g[1] == 0) then 
      local _g1 = _g[2];
      if (_g1[1] == 2) then 
        local target = _g1[2];
        if (vic == target) then 
          c_produce1:set_grabState(__deceptinfect_ecswip_GrabProduceState.READY(__deceptinfect_ecswip_SearchingState.SEARCHING));
        end;
      end;
    end;
  end;
  local _this = c_accept.targeting;
  _this.h = ({});
  _this.k = ({});
end
__deceptinfect_ecswip_GrabSystem.grabStart = function(attack,vic) 
  __haxe_Log.trace("starting grab", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/ecswip/GrabSystem.hx",lineNumber=307,className="deceptinfect.ecswip.GrabSystem",methodName="grabStart"}));
  local x = __deceptinfect_ecswip_GrabProducer;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x);
  local comp = comparray[attack];
  local comp1 = comp:slice(2)[0];
  if (comp1 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x.__name__),0);
  end;
  local c_produce = comp1;
  local x1 = __deceptinfect_ecswip_GrabAccepter;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(x1);
  local comp2 = comparray1[vic];
  local comp3 = comp2:slice(2)[0];
  if (comp3 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x1.__name__),0);
  end;
  local c_accept = comp3;
  local _this = c_accept.grabAttacker;
  _this.h[c_produce] = true;
  _this.k[c_produce] = true;
  c_accept.grabState = __deceptinfect_ecswip_GrabAcceptState.GRABBED;
  c_produce:set_grabState(__deceptinfect_ecswip_GrabProduceState.GRABBING(vic));
  c_produce.grabindex = (function() 
  local _hx_obj = __deceptinfect_ecswip_GrabSystem;
  local _hx_fld = 'grabindex';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  __deceptinfect_ecswip_GrabSystem.clearTargetingVic(vic);
  local comparray2 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
  local comp4 = comparray2[vic];
  local _g = comp4;
  if (_g[1] == 1) then 
    local plyr = _g[2];
    plyr.player:Freeze(true);
  end;
  local comparray3 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
  local comp5 = comparray3[attack];
  local _g2 = comp5;
  if (_g2[1] == 1) then 
    local plyr1 = _g2[2];
    plyr1.player:Freeze(true);
  end;
end
__deceptinfect_ecswip_GrabSystem.calcGrabIncrease = function() 
  do return (100 / __deceptinfect_GameValues.GRAB_TIME) / _G.math.floor(1 / _G.engine.TickInterval()) end;
end
__deceptinfect_ecswip_GrabSystem.target = function(attacker,victim) 
  local x = __deceptinfect_ecswip_GrabAccepter;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(x);
  local comp = comparray[victim];
  local comp1 = comp:slice(2)[0];
  if (comp1 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x.__name__),0);
  end;
  local c_accept = comp1;
  local x1 = __deceptinfect_ecswip_GrabProducer;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(x1);
  local comp2 = comparray1[attacker];
  local comp3 = comp2:slice(2)[0];
  if (comp3 == nil) then 
    _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x1.__name__),0);
  end;
  local c_produce = comp3;
  local _this = c_accept.targeting;
  _this.h[c_produce] = true;
  _this.k[c_produce] = true;
  c_accept.numTargeting = c_accept.numTargeting + 1;
  c_produce:set_grabState(__deceptinfect_ecswip_GrabProduceState.READY(__deceptinfect_ecswip_SearchingState.TARGET(victim)));
end
__deceptinfect_ecswip_GrabSystem.checkOverwhelm = function(victim) 
  do return victim.numTargeting >= victim.overwhelm end;
end
__deceptinfect_ecswip_GrabSystem.stopTargeting = function(attacker) 
  local _g = attacker.grabState;
  if (_g[1] == 0) then 
    local _g1 = _g[2];
    if (_g1[1] == 2) then 
      local vic = _g1[2];
      attacker:set_grabState(__deceptinfect_ecswip_GrabProduceState.READY(__deceptinfect_ecswip_SearchingState.SEARCHING));
    end;
  end;
end
__deceptinfect_ecswip_GrabSystem.prototype = _hx_a();
__deceptinfect_ecswip_GrabSystem.prototype.init_server = function(self) 
  _G.hook.Add("EntityTakeDamage", "grabDamage", __deceptinfect_ecswip_GrabSystem.grabDamage);
end
__deceptinfect_ecswip_GrabSystem.prototype.run_server = function(self) 
  local attack = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
  while (attack:hasNext()) do 
    local attack1 = attack:next();
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GEntityComponent);
    local comp = comparray[attack1];
    local _g1 = comp;
    local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabProducer);
    local comp1 = comparray1[attack1];
    local _g2 = comp1;
    if (_g2[1] == 1) then 
      if (_g1[1] == 1) then 
        local _hx_tmp;
        local c_produce = _g2[2];
        _hx_tmp = _g1[2].entity;
        local g_attack = _hx_tmp;
        local _g11 = c_produce.grabState;
        local tmp = _g11[1];
        if (tmp) == 0 then 
          local _g21 = _g11[2];
          local tmp1 = _g21[1];
          if (tmp1) == 1 then 
            local victim = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
            while (victim:hasNext()) do 
              local victim1 = victim:next();
              if (attack1 ~= victim1) then 
                local comparray2 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_VirtualPosition);
                local comp2 = comparray2[victim1];
                local _g22 = comp2;
                local comparray3 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabAccepter);
                local comp3 = comparray3[victim1];
                local _g3 = comp3;
                if (_g3[1] == 1) then 
                  local _g4 = _g3[2];
                  if (_g22[1] == 1) then 
                    local _hx_tmp1;
                    _hx_tmp1 = _g22[2]:get_pos();
                    local vicPos = _hx_tmp1;
                    if (vicPos:Distance(g_attack:GetPos()) < c_produce.grabDist) then 
                      __deceptinfect_ecswip_GrabSystem.attemptTarget(attack1, victim1);
                      local _g23 = c_produce.grabState;
                      local tmp2 = _g23[1];
                      if (tmp2) == 0 then 
                        local _g31 = _g23[2];
                        if (_g31[1] == 2) then 
                          local newTarget = _g31[2];
                          if (newTarget == victim1) then 
                            break;
                          end;
                        end;
                      elseif (tmp2) == 1 then 
                        local _g5 = _g23[2];
                        break;else end;
                    end;
                  end;
                end;
              end;
            end;
          elseif (tmp1) == 2 then 
            local prevVic = _g21[2];
            local x = __deceptinfect_ecswip_VirtualPosition;
            local comparray4 = __deceptinfect_ecswip_ComponentManager.lazyInit(x);
            local comp4 = comparray4[prevVic];
            local comp5 = comp4:slice(2)[0];
            if (comp5 == nil) then 
              _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x.__name__),0);
            end;
            local prevPos = comp5:get_pos();
            local oldDist = prevPos:Distance(g_attack:GetPos());
            if (oldDist > c_produce.grabDist) then 
              c_produce:set_grabState(__deceptinfect_ecswip_GrabProduceState.READY(__deceptinfect_ecswip_SearchingState.SEARCHING));
              break;
            end;
            __deceptinfect_ecswip_GrabSystem.attemptSneakAttack(attack1, prevVic);
            local victim2 = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
            while (victim2:hasNext()) do 
              local victim3 = victim2:next();
              if ((victim3 ~= prevVic) and (attack1 ~= victim3)) then 
                local comparray5 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_VirtualPosition);
                local comp6 = comparray5[victim3];
                local _g24 = comp6;
                local comparray6 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabAccepter);
                local comp7 = comparray6[victim3];
                local _g32 = comp7;
                if (_g32[1] == 1) then 
                  local _g41 = _g32[2];
                  if (_g24[1] == 1) then 
                    local _hx_tmp2;
                    _hx_tmp2 = _g24[2]:get_pos();
                    local vicPos1 = _hx_tmp2;
                    local newDist = vicPos1:Distance(g_attack:GetPos());
                    if ((newDist < oldDist) and (newDist < c_produce.grabDist)) then 
                      __deceptinfect_ecswip_GrabSystem.attemptTarget(attack1, victim3);
                      local _g25 = c_produce.grabState;
                      local tmp3 = _g25[1];
                      if (tmp3) == 0 then 
                        local _g33 = _g25[2];
                        if (_g33[1] == 2) then 
                          local newTarget1 = _g33[2];
                          if (newTarget1 == victim3) then 
                            __haxe_Log.trace(Std.string("switching targets ") .. Std.string(newTarget1), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/ecswip/GrabSystem.hx",lineNumber=136,className="deceptinfect.ecswip.GrabSystem",methodName="run_server"}));
                            break;
                          end;
                        end;
                      elseif (tmp3) == 1 then 
                        local _g51 = _g25[2];
                        break;else end;
                    end;
                  end;
                end;
              end;
            end;else end;
        elseif (tmp) == 1 then 
          local victim4 = _g11[2];
          local g_vic;
          local comparray7 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GEntityComponent);
          local comp8 = comparray7[victim4];
          local _g12 = comp8;
          if (_g12[1] == 1) then 
            local gent = _g12[2];
            g_vic = gent.entity;
          else
            do return end;
          end;
          local filter = _G.RecipientFilter();
          filter:AddPVS(g_attack:GetPos());
          filter:AddPVS(g_vic:GetPos());
          __deceptinfect_Networking.sendFilterGrabUpdate(_hx_o({__fields__={index=true,ent=true,ent2=true},index=c_produce.grabindex,ent=g_vic,ent2=g_attack}), filter, true);
          local comparray8 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectionComponent);
          local comp9 = comparray8[victim4];
          local _g34 = comp9;
          if (_g34[1] == 1) then 
            local inf = _g34[2];
            local _g35 = inf.infection;
            local tmp4 = _g35[1];
            if (tmp4) == 0 then 
              local inf1 = _g35[2];
              local param = __deceptinfect_ecswip_GrabSystem.calcGrabIncrease();
              inf1[0] = inf1[0] + param;
            elseif (tmp4) == 1 then 
              __haxe_Log.trace("infected", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/ecswip/GrabSystem.hx",lineNumber=174,className="deceptinfect.ecswip.GrabSystem",methodName="run_server"}));
              __deceptinfect_ecswip_GrabSystem.grabStop(attack1);
              local x1 = __deceptinfect_ecswip_GrabAccepter;
              local comparray9 = __deceptinfect_ecswip_ComponentManager.lazyInit(x1);
              local comp10 = comparray9[victim4];
              local comp11 = comp10:slice(2)[0];
              if (comp11 == nil) then 
                _G.error(Std.string("Component does not exist at sure statement ") .. Std.string(x1.__name__),0);
              end;
              local c_accept = comp11;
              c_accept.grabState = __deceptinfect_ecswip_GrabAcceptState.UNAVALIABLE(__deceptinfect_util_Cooldown.UNAVALIABLE); end;
          else
            _G.error("Victim has no infection component..",0);
          end;
        elseif (tmp) == 2 then 
          local _g52 = _g11[2];
          if (_g52[1] == 1) then 
            local cool = _g52[2];
            if (_G.CurTime() > cool) then 
              c_produce:set_grabState(__deceptinfect_ecswip_GrabProduceState.READY(__deceptinfect_ecswip_SearchingState.NOT_SEARCHING));
            end;
          end;else end;
      end;
    end;
  end;
end

__deceptinfect_ecswip_GrabSystem.prototype.__class__ =  __deceptinfect_ecswip_GrabSystem
__deceptinfect_ecswip_GrabSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_ecswip_GrabSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_ecswip_HiddenHealthComponent.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_HiddenHealthComponent.prototype)
  __deceptinfect_ecswip_HiddenHealthComponent.super(self)
  return self
end
__deceptinfect_ecswip_HiddenHealthComponent.super = function(self) 
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_ecswip_HiddenHealthComponent.__name__ = "deceptinfect.ecswip.HiddenHealthComponent"
__deceptinfect_ecswip_HiddenHealthComponent.prototype = _hx_a();

__deceptinfect_ecswip_HiddenHealthComponent.prototype.__class__ =  __deceptinfect_ecswip_HiddenHealthComponent
__deceptinfect_ecswip_HiddenHealthComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_HiddenHealthComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_ecswip_HiddenHealthSystem.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_HiddenHealthSystem.prototype)
  __deceptinfect_ecswip_HiddenHealthSystem.super(self)
  return self
end
__deceptinfect_ecswip_HiddenHealthSystem.super = function(self) 
  __deceptinfect_client_GeigerSystem.super(self);
end
__deceptinfect_ecswip_HiddenHealthSystem.__name__ = "deceptinfect.ecswip.HiddenHealthSystem"
__deceptinfect_ecswip_HiddenHealthSystem.hiddenHealthDamage = function(data) 
  local victim = data.vicID;
  local g_attacker = data.dmg:GetAttacker();
  if (not g_attacker:IsPlayer()) then 
    do return end;
  end;
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GEntityComponent);
  local comp = comparray[victim];
  local _g = comp;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_HiddenHealthComponent);
  local comp1 = comparray1[victim];
  local _g1 = comp1;
  if (_g1[1] == 1) then 
    if (_g[1] == 1) then 
      local c_hidHealth = _g1[2];
      local g_victim = _g[2];
      local damageVal = data.dmg:GetDamage();
      local health = g_victim.entity:Health();
      local dmgInfo = data.dmg;
      if (damageVal >= health) then 
        local c_hidHealth1 = c_hidHealth;
        c_hidHealth1.extraHealth = c_hidHealth1.extraHealth - damageVal;
        if (c_hidHealth.extraHealth > 0) then 
          dmgInfo:SetDamage(health - 1);
        else
          dmgInfo:SetDamage(health);
        end;
      end;
    end;
  end;
end
__deceptinfect_ecswip_HiddenHealthSystem.prototype = _hx_a();
__deceptinfect_ecswip_HiddenHealthSystem.prototype.init_server = function(self) 
  __deceptinfect_ecswip_SignalStorage.entDamage:handle(__deceptinfect_ecswip_HiddenHealthSystem.hiddenHealthDamage);
end

__deceptinfect_ecswip_HiddenHealthSystem.prototype.__class__ =  __deceptinfect_ecswip_HiddenHealthSystem
__deceptinfect_ecswip_HiddenHealthSystem.__super__ = __deceptinfect_client_GeigerSystem
setmetatable(__deceptinfect_ecswip_HiddenHealthSystem.prototype,{__index=__deceptinfect_client_GeigerSystem.prototype})

__deceptinfect_ecswip_PlayerComponent.new = function(x) 
  local self = _hx_new(__deceptinfect_ecswip_PlayerComponent.prototype)
  __deceptinfect_ecswip_PlayerComponent.super(self,x)
  return self
end
__deceptinfect_ecswip_PlayerComponent.super = function(self,x) 
  self.playing = true;
  self.deathTime = __deceptinfect_ecswip_DeathTime.ALIVE;
  self.roundModel = "";
  self.spec_next = 1;
  __deceptinfect_ecswip_Component.super(self);
  self.player = x;
end
__deceptinfect_ecswip_PlayerComponent.__name__ = "deceptinfect.ecswip.PlayerComponent"
__deceptinfect_ecswip_PlayerComponent.prototype = _hx_a();

__deceptinfect_ecswip_PlayerComponent.prototype.__class__ =  __deceptinfect_ecswip_PlayerComponent
__deceptinfect_ecswip_PlayerComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_PlayerComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})
_hxClasses["deceptinfect.ecswip.DeathTime"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="ALIVE","DEAD"},2)}
__deceptinfect_ecswip_DeathTime = _hxClasses["deceptinfect.ecswip.DeathTime"];
__deceptinfect_ecswip_DeathTime.ALIVE = _hx_tab_array({[0]="ALIVE",0,__enum__ = __deceptinfect_ecswip_DeathTime},2)

__deceptinfect_ecswip_DeathTime.DEAD = function(reviveTime) local _x = _hx_tab_array({[0]="DEAD",1,reviveTime,__enum__=__deceptinfect_ecswip_DeathTime}, 3); return _x; end 

__tink_core_SignalObject.new = {}
__tink_core_SignalObject.__name__ = "tink.core.SignalObject"
__tink_core_SignalObject.prototype = _hx_a();

__tink_core_SignalObject.prototype.__class__ =  __tink_core_SignalObject

__tink_core_SignalTrigger.new = function() 
  local self = _hx_new(__tink_core_SignalTrigger.prototype)
  __tink_core_SignalTrigger.super(self)
  return self
end
__tink_core_SignalTrigger.super = function(self) 
  self.handlers = __tink_core_CallbackList.new();
end
__tink_core_SignalTrigger.__name__ = "tink.core.SignalTrigger"
__tink_core_SignalTrigger.__interfaces__ = {__tink_core_SignalObject}
__tink_core_SignalTrigger.prototype = _hx_a();
__tink_core_SignalTrigger.prototype.trigger = function(self,event) 
  self.handlers:invoke(event);
end
__tink_core_SignalTrigger.prototype.getLength = function(self) 
  do return self.handlers.used end
end
__tink_core_SignalTrigger.prototype.handle = function(self,cb) 
  local _this = self.handlers;
  local node = __tink_core__Callback_ListCell.new(cb, _this);
  _this.cells:push(node);
  _this.used = _this.used + 1;
  do return node end
end
__tink_core_SignalTrigger.prototype.clear = function(self) 
  self.handlers:clear();
end
__tink_core_SignalTrigger.prototype.asSignal = function(self) 
  do return self end
end

__tink_core_SignalTrigger.prototype.__class__ =  __tink_core_SignalTrigger

__deceptinfect_ecswip_SignalStorage.new = {}
__deceptinfect_ecswip_SignalStorage.__name__ = "deceptinfect.ecswip.SignalStorage"
__deceptinfect_ecswip_SignalStorage.initEvents = function() 
  __deceptinfect_ecswip_SignalStorage.entDamage = __deceptinfect_ecswip_SignalStorage.entDamageTrigger;
  __deceptinfect_ecswip_SignalStorage.onInfected = __deceptinfect_ecswip_SignalStorage.onInfectedTrigger;
end

__deceptinfect_ecswip_Spectate.new = {}
__deceptinfect_ecswip_Spectate.__name__ = "deceptinfect.ecswip.Spectate"
__deceptinfect_ecswip_Spectate.chooseSpectateTarget = function(x,dir) 
  local player = x.player;
  local iter;
  local iter1 = dir[1];
  if (iter1) == 0 then 
    iter = 1;
  elseif (iter1) == 1 then 
    iter = -1; end;
  local specCur = x.spec_next;
  local specNext = x.spec_next + iter;
  local players = _G.player.GetAll();
  local specd = false;
  while (specNext ~= specCur) do 
    local target = players[specNext];
    if (_G.IsValid(target) and target:Alive()) then 
      player:SpectateEntity(target);
      player:SetObserverMode(_G.OBS_MODE_CHASE);
      specd = true;
    end;
    specNext = specNext + iter;
    if (specNext < 1) then 
      specNext = #players;
    else
      if (specNext > #players) then 
        specNext = 0;
      end;
    end;
  end;
  if (not specd) then 
    __haxe_Log.trace("No spectatable players found", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/ecswip/Spectate.hx",lineNumber=33,className="deceptinfect.ecswip.Spectate",methodName="chooseSpectateTarget"}));
  end;
  x.spec_next = specNext;
end
_hxClasses["deceptinfect.ecswip.Spec_Direction"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="FORWARDS","BACKWARDS"},2)}
__deceptinfect_ecswip_Spec_Direction = _hxClasses["deceptinfect.ecswip.Spec_Direction"];
__deceptinfect_ecswip_Spec_Direction.FORWARDS = _hx_tab_array({[0]="FORWARDS",0,__enum__ = __deceptinfect_ecswip_Spec_Direction},2)

__deceptinfect_ecswip_Spec_Direction.BACKWARDS = _hx_tab_array({[0]="BACKWARDS",1,__enum__ = __deceptinfect_ecswip_Spec_Direction},2)


__deceptinfect_ecswip_SpectateComponent.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_SpectateComponent.prototype)
  __deceptinfect_ecswip_SpectateComponent.super(self)
  return self
end
__deceptinfect_ecswip_SpectateComponent.super = function(self) 
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_ecswip_SpectateComponent.__name__ = "deceptinfect.ecswip.SpectateComponent"
__deceptinfect_ecswip_SpectateComponent.prototype = _hx_a();

__deceptinfect_ecswip_SpectateComponent.prototype.__class__ =  __deceptinfect_ecswip_SpectateComponent
__deceptinfect_ecswip_SpectateComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_SpectateComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_infection_InfectionSystem.new = function() 
  local self = _hx_new(__deceptinfect_infection_InfectionSystem.prototype)
  __deceptinfect_infection_InfectionSystem.super(self)
  return self
end
__deceptinfect_infection_InfectionSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
__deceptinfect_infection_InfectionSystem.__name__ = "deceptinfect.infection.InfectionSystem"
__deceptinfect_infection_InfectionSystem.makeInfected = function(ent) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectionComponent);
  local comp = comparray[ent];
  local _g = comp;
  if (_g[1] == 1) then 
    local inf = _g[2];
    local _g1 = inf.infection;
    local tmp;
    if (_g1[1] == 0) then 
      local _g11 = _g1[2];
      __deceptinfect_infection_InfectionSystem.onInfected(ent);
      tmp = __deceptinfect_infection_INF_STATE.INFECTED;
    else
      tmp = __deceptinfect_infection_INF_STATE.INFECTED;
    end;
    inf.infection = tmp;
    __haxe_Log.trace(Std.string("infection : ") .. Std.string(Std.string(inf.infection)), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/infection/InfectionSystem.hx",lineNumber=93,className="deceptinfect.infection.InfectionSystem",methodName="makeInfected"}));
  end;
end
__deceptinfect_infection_InfectionSystem.calcInfectionFromRates = function(rate) 
  local total = 0.0;
  local totalmulti = 1.0;
  local rate1 = rate.addRates:iterator();
  while (rate1:hasNext()) do 
    local rate2 = rate1:next();
    total = total + rate2;
  end;
  local multi = rate.multipliers:iterator();
  while (multi:hasNext()) do 
    local multi1 = multi:next();
    totalmulti = totalmulti + multi1;
  end;
  do return total * totalmulti end;
end
__deceptinfect_infection_InfectionSystem.getBaseInfection = function(inf) 
  local _g = inf.baseInfection;
  local tmp = _g[1];
  if (tmp) == 0 then 
    do return 0 end;
  elseif (tmp) == 1 then 
    local _g1 = __deceptinfect_GameManager.state;
    if (_g1[1] == 2) then 
      local x = _g1[2];
      do return x.baseInfection[0] end;
    else
      __haxe_Log.trace("Not currently playing...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/infection/InfectionSystem.hx",lineNumber=120,className="deceptinfect.infection.InfectionSystem",methodName="getBaseInfection"}));
      inf.baseInfection = __deceptinfect_infection_BaseInfection.USING_STATIC(0.0);
      do return 0 end;
    end;
  elseif (tmp) == 2 then 
    local rate = _g[2];
    do return rate end; end;
end
__deceptinfect_infection_InfectionSystem.fixUpInfection = function(infection) 
  local _g = infection.infection;
  if (_g[1] == 0) then 
    local _g1 = _g[2];
    local inf = _g1;
    if (inf[0] < 0) then 
      inf[0] = 0;
    else
      local inf1 = _g1;
      if (inf1[0] >= 100) then 
        __haxe_Log.trace("Now infected :)", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/infection/InfectionSystem.hx",lineNumber=137,className="deceptinfect.infection.InfectionSystem",methodName="fixUpInfection"}));
        infection.infection = __deceptinfect_infection_INF_STATE.INFECTED;
      end;
    end;
  end;
end
__deceptinfect_infection_InfectionSystem.onInfected = function(ent) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
  local comp = comparray[ent];
  local _g = comp;
  if (_g[1] == 1) then 
    local _g1 = _g[2];
    __haxe_Log.trace("INIT INFECTED PLAYER", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/infection/InfectionSystem.hx",lineNumber=148,className="deceptinfect.infection.InfectionSystem",methodName="onInfected"}));
    __deceptinfect_GameManager.initInfectedPlayer(ent);
  end;
end
__deceptinfect_infection_InfectionSystem.prototype = _hx_a();
__deceptinfect_infection_InfectionSystem.prototype.run_server = function(self) 
  local entity = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
  while (entity:hasNext()) do 
    local entity1 = entity:next();
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectionComponent);
    local comp = comparray[entity1];
    local _g1 = comp;
    if (_g1[1] == 1) then 
      local _g2 = _g1[2];
      if (_g2.acceptingInfection[1] == 0) then 
        local infection = _g2;
        local _g11 = infection.infection;
        if (_g11[1] == 0) then 
          local inf = _g11[2];
          local base = __deceptinfect_infection_InfectionSystem.getBaseInfection(infection);
          local rate;
          local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_RateComponent);
          local comp1 = comparray1[entity1];
          local _g12 = comp1;
          if (_g12[1] == 1) then 
            local rate1 = _g12[2];
            rate = __deceptinfect_infection_InfectionSystem.calcInfectionFromRates(rate1);
          else
            rate = infection.rate;
          end;
          rate = rate + 1;
          inf[0] = inf[0] + (base * rate);
          __deceptinfect_infection_InfectionSystem.fixUpInfection(infection);
          local comparray2 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
          local comp2 = comparray2[entity1];
          local _g3 = comp2;
          if (_g3[1] == 1) then 
            local ply = _g3[2];
            __deceptinfect_Networking.sendInfectionMessage(_hx_o({__fields__={infection=true},infection=inf[0]}), ply.player, true);
          end;
          infection.rate = rate;
          if (infection.infection[1] == 1) then 
            __deceptinfect_infection_InfectionSystem.onInfected(entity1);
          end;
        end;
      end;
    end;
  end;
end

__deceptinfect_infection_InfectionSystem.prototype.__class__ =  __deceptinfect_infection_InfectionSystem
__deceptinfect_infection_InfectionSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_infection_InfectionSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_radiation_RadiationAccepter.new = function(options) 
  local self = _hx_new(__deceptinfect_radiation_RadiationAccepter.prototype)
  __deceptinfect_radiation_RadiationAccepter.super(self,options)
  return self
end
__deceptinfect_radiation_RadiationAccepter.super = function(self,options) 
  self.accepting = false;
  self.acceptContam = __haxe_ds_Option.None;
  self.diminish = 0.75;
  self.radiation = __haxe_ds_IntMap.new();
  __deceptinfect_ecswip_Component.super(self);
  if (options.contaminate ~= nil) then 
    self.acceptContam = __haxe_ds_Option.Some(options.contaminate);
  end;
  if (options.diminish ~= nil) then 
    self.diminish = _hx_funcToField(options.diminish);
  end;
end
__deceptinfect_radiation_RadiationAccepter.__name__ = "deceptinfect.radiation.RadiationAccepter"
__deceptinfect_radiation_RadiationAccepter.prototype = _hx_a();

__deceptinfect_radiation_RadiationAccepter.prototype.__class__ =  __deceptinfect_radiation_RadiationAccepter
__deceptinfect_radiation_RadiationAccepter.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_radiation_RadiationAccepter.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_infection_RateComponent.new = function() 
  local self = _hx_new(__deceptinfect_infection_RateComponent.prototype)
  __deceptinfect_infection_RateComponent.super(self)
  return self
end
__deceptinfect_infection_RateComponent.super = function(self) 
  self.multipliers = __haxe_ds_IntMap.new();
  self.addRates = __haxe_ds_IntMap.new();
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_infection_RateComponent.__name__ = "deceptinfect.infection.RateComponent"
__deceptinfect_infection_RateComponent.prototype = _hx_a();

__deceptinfect_infection_RateComponent.prototype.__class__ =  __deceptinfect_infection_RateComponent
__deceptinfect_infection_RateComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_infection_RateComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_radiation_RadiationProducer.new = function(options) 
  local self = _hx_new(__deceptinfect_radiation_RadiationProducer.prototype)
  __deceptinfect_radiation_RadiationProducer.super(self,options)
  return self
end
__deceptinfect_radiation_RadiationProducer.super = function(self,options) 
  self.contamProducer = __haxe_ds_Option.None;
  self.state = __deceptinfect_radiation_RadiationState.ENABLED;
  self.id = __deceptinfect_radiation_RadiationSystem.getNextRadiatonID();
  __deceptinfect_ecswip_Component.super(self);
  self.maxrate = _hx_funcToField(options.maxrate);
  self.radius = _hx_funcToField(options.radius);
  self.lifetime = _hx_funcToField(options.lifetime);
  if (options.contaminate ~= nil) then 
    self.contamProducer = __haxe_ds_Option.Some(__deceptinfect_radiation_ContaminationProducer.new(options.contaminate));
  end;
end
__deceptinfect_radiation_RadiationProducer.__name__ = "deceptinfect.radiation.RadiationProducer"
__deceptinfect_radiation_RadiationProducer.createFromType = function(type) 
  do return __deceptinfect_radiation_RadiationProducer.new(__deceptinfect_radiation_RadiationTypes.types:get(type)) end;
end
__deceptinfect_radiation_RadiationProducer.prototype = _hx_a();

__deceptinfect_radiation_RadiationProducer.prototype.__class__ =  __deceptinfect_radiation_RadiationProducer
__deceptinfect_radiation_RadiationProducer.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_radiation_RadiationProducer.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_ecswip_VirtualPosition.new = function(_ent,_pos,_ang) 
  local self = _hx_new(__deceptinfect_ecswip_VirtualPosition.prototype)
  __deceptinfect_ecswip_VirtualPosition.super(self,_ent,_pos,_ang)
  return self
end
__deceptinfect_ecswip_VirtualPosition.super = function(self,_ent,_pos,_ang) 
  __deceptinfect_ecswip_Component.super(self);
  if (_ent == nil) then 
    self:set_pos(_pos);
    self:set_ang(_ang);
  else
    if (_pos == nil) then 
      self.ent = _ent;
    end;
  end;
end
__deceptinfect_ecswip_VirtualPosition.__name__ = "deceptinfect.ecswip.VirtualPosition"
__deceptinfect_ecswip_VirtualPosition.prototype = _hx_a();
__deceptinfect_ecswip_VirtualPosition.prototype.get_pos = function(self) 
  if (self.ent == nil) then 
    do return self.pos end;
  else
    do return self.ent:GetPos() end;
  end;
end
__deceptinfect_ecswip_VirtualPosition.prototype.get_ang = function(self) 
  if (self.ent == nil) then 
    do return self.ang end;
  else
    do return self.ent:GetAngles() end;
  end;
end
__deceptinfect_ecswip_VirtualPosition.prototype.set_pos = function(self,set) 
  if (self.ent == nil) then 
    self.pos = set do return self.pos end;
  else
    self.ent:SetPos(set);
    do return set end;
  end;
end
__deceptinfect_ecswip_VirtualPosition.prototype.set_ang = function(self,set) 
  if (self.ent == nil) then 
    self.ang = set do return self.ang end;
  else
    self.ent:SetAngles(set);
    do return set end;
  end;
end

__deceptinfect_ecswip_VirtualPosition.prototype.__class__ =  __deceptinfect_ecswip_VirtualPosition
__deceptinfect_ecswip_VirtualPosition.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_VirtualPosition.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_infection_RateSystem.new = {}
__deceptinfect_infection_RateSystem.__name__ = "deceptinfect.infection.RateSystem"
__deceptinfect_infection_RateSystem.getAddRateTicket = function() 
  __deceptinfect_infection_RateSystem.nextAddRate = __deceptinfect_infection_RateSystem.nextAddRate + 1;
  do return __deceptinfect_infection_RateSystem.nextAddRate - 1 end;
end
__deceptinfect_infection_RateSystem.getMultiRateTicket = function() 
  __deceptinfect_infection_RateSystem.nextMultiRate = __deceptinfect_infection_RateSystem.nextMultiRate + 1;
  do return __deceptinfect_infection_RateSystem.nextMultiRate - 1 end;
end
__deceptinfect_infection_RateSystem.addRate = function(rt,id,rate) 
  rt.addRates:set(id, rate);
end

__deceptinfect_radiation_RadiationSystem.new = function() 
  local self = _hx_new(__deceptinfect_radiation_RadiationSystem.prototype)
  __deceptinfect_radiation_RadiationSystem.super(self)
  return self
end
__deceptinfect_radiation_RadiationSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
__deceptinfect_radiation_RadiationSystem.__name__ = "deceptinfect.radiation.RadiationSystem"
__deceptinfect_radiation_RadiationSystem.getNextRadiatonID = function() 
  __deceptinfect_radiation_RadiationSystem.nextRadiationID = __deceptinfect_radiation_RadiationSystem.nextRadiationID + 1;
  do return __deceptinfect_radiation_RadiationSystem.nextRadiationID - 1 end;
end
__deceptinfect_radiation_RadiationSystem.testRadiation = function(vec) 
  local ent = __deceptinfect_ecswip_ComponentManager.addEntity();
  local this1 = _G.Angle(0, 0, 0);
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_ecswip_VirtualPosition.new(nil, vec, this1), ent);
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_radiation_RadiationProducer.createFromType(__deceptinfect_radiation_RadTypes.NEST), ent);
end
_hx_exports["testRadiation"] = __deceptinfect_radiation_RadiationSystem.testRadiation
__deceptinfect_radiation_RadiationSystem.getTotalRadiation = function(dist,rad) 
  if (dist < rad.radius) then 
    do return __haxe_ds_Option.Some((rad.maxrate - 1) * ((rad.radius - dist) / rad.radius)) end;
  else
    do return __haxe_ds_Option.None end;
  end;
end
__deceptinfect_radiation_RadiationSystem.shouldContam = function(dist,contamProduce) 
  do return dist < contamProduce.dist end;
end
__deceptinfect_radiation_RadiationSystem.shouldRoll = function(time,contamProduce) 
  do return time > contamProduce.check end;
end
__deceptinfect_radiation_RadiationSystem.getTotalRadiationRate = function(r) 
  local sortFunc = function(x,y) 
    if (x == y) then 
      do return 0 end;
    else
      if (x < y) then 
        do return -1 end;
      else
        do return 1 end;
      end;
    end;
  end;
  local sorted = _hx_tab_array({}, 0);
  local _g = __haxe_iterators_MapKeyValueIterator.new(r.radiation);
  while (_g:hasNext()) do 
    local _g1 = _g:next();
    local _ = _g1.key;
    local rate = _g1.value;
    sorted:push(rate);
  end;
  sorted:sort(sortFunc);
  local total = 0;
  local _g2 = 0;
  local _g11 = sorted.length;
  while (_g2 < _g11) do 
    _g2 = _g2 + 1;
    local i = _g2 - 1;
    total = total + (sorted[i] * _G.math.pow(r.diminish, i));
  end;
  do return total end;
end
__deceptinfect_radiation_RadiationSystem.prototype = _hx_a();
__deceptinfect_radiation_RadiationSystem.prototype.run_server = function(self) 
  local acceptEnt = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
  while (acceptEnt:hasNext()) do 
    local acceptEnt1 = acceptEnt:next();
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GEntityComponent);
    local comp = comparray[acceptEnt1];
    local _g1 = comp;
    local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_RateComponent);
    local comp1 = comparray1[acceptEnt1];
    local _g2 = comp1;
    local comparray2 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_radiation_RadiationAccepter);
    local comp2 = comparray2[acceptEnt1];
    local _g3 = comp2;
    if (_g3[1] == 1) then 
      if (_g2[1] == 1) then 
        if (_g1[1] == 1) then 
          local c_rateAccept = _g2[2];
          local c_radAccept = _g3[2];
          local c_radGEnt = _g1[2];
          local produceEnt = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
          while (produceEnt:hasNext()) do 
            local produceEnt1 = produceEnt:next();
            local comparray3 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_VirtualPosition);
            local comp3 = comparray3[produceEnt1];
            local _g21 = comp3;
            local comparray4 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_radiation_RadiationProducer);
            local comp4 = comparray4[produceEnt1];
            local _g31 = comp4;
            if (_g31[1] == 1) then 
              if (_g21[1] == 1) then 
                local c_radProduce = _g31[2];
                local c_producePos = _g21[2];
                local dist = c_producePos:get_pos():Distance(c_radGEnt.entity:GetPos());
                local _g22 = __deceptinfect_radiation_RadiationSystem.getTotalRadiation(dist, c_radProduce);
                if (_g22[1] == 0) then 
                  local rate = _g22[2];
                  local key = c_radProduce.id;
                  local _this = c_radAccept.radiation;
                  if (rate == nil) then 
                    _this.h[key] = __haxe_ds_IntMap.tnull;
                  else
                    _this.h[key] = rate;
                  end;
                end;
                local _g4 = c_radAccept.acceptContam;
                local _g5 = c_radProduce.contamProducer;
                if (_g5[1] == 0) then 
                  if (_g4[1] == 0) then 
                    local c_contamProduce = _g5[2];
                    local c_contamAccept = _g4[2];
                    if (dist < c_contamProduce.dist) then 
                      local time = c_contamAccept.contam_time:addTime(c_radProduce.id);
                      if (time > c_contamProduce.check) then 
                        c_contamAccept.contam_time:resetTime(c_radProduce.id);
                        local randRoll = _G.math.random();
                        local tmp = randRoll < c_contamProduce.chance;
                      end;
                    else
                      c_contamAccept.contam_time:removeTime(c_radProduce.id);
                    end;
                  end;
                end;
              end;
            end;
          end;
          c_rateAccept.addRates:set(__deceptinfect_radiation_RadiationSystem.radRateID, __deceptinfect_radiation_RadiationSystem.getTotalRadiationRate(c_radAccept));
        end;
      end;
    end;
  end;
end

__deceptinfect_radiation_RadiationSystem.prototype.__class__ =  __deceptinfect_radiation_RadiationSystem
__deceptinfect_radiation_RadiationSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_radiation_RadiationSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_game_WinSystem.new = function() 
  local self = _hx_new(__deceptinfect_game_WinSystem.prototype)
  __deceptinfect_game_WinSystem.super(self)
  return self
end
__deceptinfect_game_WinSystem.super = function(self) 
  self.winTrig = __tink_core_SignalTrigger.new();
  __deceptinfect_ecswip_System.super(self);
end
__deceptinfect_game_WinSystem.__name__ = "deceptinfect.game.WinSystem"
__deceptinfect_game_WinSystem.prototype = _hx_a();
__deceptinfect_game_WinSystem.prototype.init_server = function(self) 
  self.newWinner = self.winTrig;
end
__deceptinfect_game_WinSystem.prototype.run_server = function(self) 
  local total = 0;
  local infected = 0;
  local ent = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
  while (ent:hasNext()) do 
    local ent1 = ent:next();
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_PlayerComponent);
    local comp = comparray[ent1];
    local _g1 = comp;
    local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectedComponent);
    local comp1 = comparray1[ent1];
    local _g2 = comp1;
    local tmp = _g2[1];
    if (tmp) == 0 then 
      if (_g1[1] == 1) then 
        local _g3 = _g1[2];
        total = total + 1;
      end;
    elseif (tmp) == 1 then 
      local _g4 = _g2[2];
      if (_g1[1] == 1) then 
        local _g5 = _g1[2];
        infected = infected + 1;
        total = total + 1;
      end; end;
  end;
  if (infected == 0) then 
    self.winTrig.handlers:invoke(__deceptinfect_game_Win.WIN_HUMAN);
    self.winTrig.handlers:clear();
  else
    if (infected >= total) then 
      self.winTrig.handlers:invoke(__deceptinfect_game_Win.WIN_ALIEN);
      self.winTrig.handlers:clear();
    end;
  end;
end

__deceptinfect_game_WinSystem.prototype.__class__ =  __deceptinfect_game_WinSystem
__deceptinfect_game_WinSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_game_WinSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_game_BatterySystem.new = function() 
  local self = _hx_new(__deceptinfect_game_BatterySystem.prototype)
  __deceptinfect_game_BatterySystem.super(self)
  return self
end
__deceptinfect_game_BatterySystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
__deceptinfect_game_BatterySystem.__name__ = "deceptinfect.game.BatterySystem"
__deceptinfect_game_BatterySystem.prototype = _hx_a();
__deceptinfect_game_BatterySystem.prototype.run_server = function(self) 
  local ents = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
  while (ents:hasNext()) do 
    local ents1 = ents:next();
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_game_BatteryAccepter);
    local comp = comparray[ents1];
    local _g1 = comp;
    if (_g1[1] == 1) then 
      local c_accept = _g1[2];
      local c_accept1 = c_accept;
      c_accept1.charge = c_accept1.charge - c_accept.decay;
      if (c_accept.charge < 0.0) then 
        c_accept.charge = 0.0;
      end;
      if (c_accept.charge > c_accept.satisfy) then 
        c_accept.status = __deceptinfect_game_AccepterStatus.SATISIFED;
      end;
      if (c_accept.status[1] == 1) then 
        if (c_accept.charge < c_accept.satisfy) then 
          c_accept.status = __deceptinfect_game_AccepterStatus.AVALIABLE;
        end;
      end;
    end;
  end;
end
__deceptinfect_game_BatterySystem.prototype.addBattery = function(self,source,accepter) 
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_game_BatteryAccepter);
  local comp = comparray[accepter];
  local _g = comp;
  local comparray1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_game_BatterySource);
  local comp1 = comparray1[source];
  local _g1 = comp1;
  if (_g1[1] == 1) then 
    if (_g[1] == 1) then 
      local c_source = _g1[2];
      local c_accept = _g[2];
      local c_accept1 = c_accept;
      c_accept1.charge = c_accept1.charge + c_source.charge;
      do return true end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end

__deceptinfect_game_BatterySystem.prototype.__class__ =  __deceptinfect_game_BatterySystem
__deceptinfect_game_BatterySystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_game_BatterySystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_ecswip_SystemManager.new = {}
__deceptinfect_ecswip_SystemManager.__name__ = "deceptinfect.ecswip.SystemManager"
__deceptinfect_ecswip_SystemManager.make = function() 
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_infection_InfectionSystem;
  local value = __deceptinfect_infection_InfectionSystem.new();
  _this.h[key] = value;
  _this.k[key] = true;
  local _this1 = __deceptinfect_ecswip_SystemManager.getSystems;
  local key1 = __deceptinfect_client_GeigerSystem;
  local value1 = __deceptinfect_client_GeigerSystem.new();
  _this1.h[key1] = value1;
  _this1.k[key1] = true;
  local _this2 = __deceptinfect_ecswip_SystemManager.getSystems;
  local key2 = __deceptinfect_radiation_RadiationSystem;
  local value2 = __deceptinfect_radiation_RadiationSystem.new();
  _this2.h[key2] = value2;
  _this2.k[key2] = true;
  local _this3 = __deceptinfect_ecswip_SystemManager.getSystems;
  local key3 = __deceptinfect_ecswip_GrabSystem;
  local value3 = __deceptinfect_ecswip_GrabSystem.new();
  _this3.h[key3] = value3;
  _this3.k[key3] = true;
  local _this4 = __deceptinfect_ecswip_SystemManager.getSystems;
  local key4 = __deceptinfect_ecswip_HiddenHealthSystem;
  local value4 = __deceptinfect_ecswip_HiddenHealthSystem.new();
  _this4.h[key4] = value4;
  _this4.k[key4] = true;
  local _this5 = __deceptinfect_ecswip_SystemManager.getSystems;
  local key5 = __deceptinfect_game_WinSystem;
  local value5 = __deceptinfect_game_WinSystem.new();
  _this5.h[key5] = value5;
  _this5.k[key5] = true;
  local _this6 = __deceptinfect_ecswip_SystemManager.getSystems;
  local key6 = __deceptinfect_game_BatterySystem;
  local value6 = __deceptinfect_game_BatterySystem.new();
  _this6.h[key6] = value6;
  _this6.k[key6] = true;
end
__deceptinfect_ecswip_SystemManager.getSystem = function(cls) 
  do return __deceptinfect_ecswip_SystemManager.getSystems.h[cls] end;
end
__deceptinfect_ecswip_SystemManager.runAllSystems = function() 
  local _g = 0;
  local _g1 = __deceptinfect_ecswip_SystemManager.runSystems;
  while (_g < _g1.length) do 
    local clsSystem = _g1[_g];
    _g = _g + 1;
    __deceptinfect_ecswip_SystemManager.getSystems.h[clsSystem]:run();
  end;
end
__deceptinfect_ecswip_SystemManager.initAllSystems = function() 
  __deceptinfect_ecswip_SystemManager.make();
  local _g = 0;
  local _g1 = __deceptinfect_ecswip_SystemManager.runSystems;
  while (_g < _g1.length) do 
    local clsSystem = _g1[_g];
    _g = _g + 1;
    __deceptinfect_ecswip_SystemManager.getSystems.h[clsSystem]:init();
  end;
end

__deceptinfect_game_BatteryAccepter.new = function() 
  local self = _hx_new(__deceptinfect_game_BatteryAccepter.prototype)
  __deceptinfect_game_BatteryAccepter.super(self)
  return self
end
__deceptinfect_game_BatteryAccepter.super = function(self) 
  self.status = __deceptinfect_game_AccepterStatus.AVALIABLE;
  self.satisfy = 100.0;
  self.decay = 0.01;
  self.charge = 0.0;
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_game_BatteryAccepter.__name__ = "deceptinfect.game.BatteryAccepter"
__deceptinfect_game_BatteryAccepter.prototype = _hx_a();

__deceptinfect_game_BatteryAccepter.prototype.__class__ =  __deceptinfect_game_BatteryAccepter
__deceptinfect_game_BatteryAccepter.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_game_BatteryAccepter.prototype,{__index=__deceptinfect_ecswip_Component.prototype})
_hxClasses["deceptinfect.game.AccepterStatus"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="AVALIABLE","SATISIFED","UNAVALIABLE"},3)}
__deceptinfect_game_AccepterStatus = _hxClasses["deceptinfect.game.AccepterStatus"];
__deceptinfect_game_AccepterStatus.AVALIABLE = _hx_tab_array({[0]="AVALIABLE",0,__enum__ = __deceptinfect_game_AccepterStatus},2)

__deceptinfect_game_AccepterStatus.SATISIFED = _hx_tab_array({[0]="SATISIFED",1,__enum__ = __deceptinfect_game_AccepterStatus},2)

__deceptinfect_game_AccepterStatus.UNAVALIABLE = function(x) local _x = _hx_tab_array({[0]="UNAVALIABLE",2,x,__enum__=__deceptinfect_game_AccepterStatus}, 3); return _x; end 

__deceptinfect_game_BatterySource.new = function() 
  local self = _hx_new(__deceptinfect_game_BatterySource.prototype)
  __deceptinfect_game_BatterySource.super(self)
  return self
end
__deceptinfect_game_BatterySource.super = function(self) 
  self.charge = 25.0;
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_game_BatterySource.__name__ = "deceptinfect.game.BatterySource"
__deceptinfect_game_BatterySource.prototype = _hx_a();

__deceptinfect_game_BatterySource.prototype.__class__ =  __deceptinfect_game_BatterySource
__deceptinfect_game_BatterySource.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_game_BatterySource.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_game_NestComponent.new = function() 
  local self = _hx_new(__deceptinfect_game_NestComponent.prototype)
  __deceptinfect_game_NestComponent.super(self)
  return self
end
__deceptinfect_game_NestComponent.super = function(self) 
  self.nestState = __deceptinfect_game_NestState.INVISIBLE;
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_game_NestComponent.__name__ = "deceptinfect.game.NestComponent"
__deceptinfect_game_NestComponent.prototype = _hx_a();

__deceptinfect_game_NestComponent.prototype.__class__ =  __deceptinfect_game_NestComponent
__deceptinfect_game_NestComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_game_NestComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})
_hxClasses["deceptinfect.game.NestState"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="INVISIBLE","VISIBLE","DEAD"},3)}
__deceptinfect_game_NestState = _hxClasses["deceptinfect.game.NestState"];
__deceptinfect_game_NestState.INVISIBLE = _hx_tab_array({[0]="INVISIBLE",0,__enum__ = __deceptinfect_game_NestState},2)

__deceptinfect_game_NestState.VISIBLE = _hx_tab_array({[0]="VISIBLE",1,__enum__ = __deceptinfect_game_NestState},2)

__deceptinfect_game_NestState.DEAD = _hx_tab_array({[0]="DEAD",2,__enum__ = __deceptinfect_game_NestState},2)

_hxClasses["deceptinfect.game.Win"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="WIN_HUMAN","WIN_ALIEN","DRAW"},3)}
__deceptinfect_game_Win = _hxClasses["deceptinfect.game.Win"];
__deceptinfect_game_Win.WIN_HUMAN = _hx_tab_array({[0]="WIN_HUMAN",0,__enum__ = __deceptinfect_game_Win},2)

__deceptinfect_game_Win.WIN_ALIEN = _hx_tab_array({[0]="WIN_ALIEN",1,__enum__ = __deceptinfect_game_Win},2)

__deceptinfect_game_Win.DRAW = _hx_tab_array({[0]="DRAW",2,__enum__ = __deceptinfect_game_Win},2)


__deceptinfect_infection_InfectedComponent.new = function() 
  local self = _hx_new(__deceptinfect_infection_InfectedComponent.prototype)
  __deceptinfect_infection_InfectedComponent.super(self)
  return self
end
__deceptinfect_infection_InfectedComponent.super = function(self) 
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_infection_InfectedComponent.__name__ = "deceptinfect.infection.InfectedComponent"
__deceptinfect_infection_InfectedComponent.prototype = _hx_a();

__deceptinfect_infection_InfectedComponent.prototype.__class__ =  __deceptinfect_infection_InfectedComponent
__deceptinfect_infection_InfectedComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_infection_InfectedComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_infection_InfectionComponent.new = function() 
  local self = _hx_new(__deceptinfect_infection_InfectionComponent.prototype)
  __deceptinfect_infection_InfectionComponent.super(self)
  return self
end
__deceptinfect_infection_InfectionComponent.super = function(self) 
  self.acceptingInfection = __deceptinfect_infection_AcceptingInfection.ACCEPTING;
  self.baseInfection = __deceptinfect_infection_BaseInfection.USING_GLOBAL;
  self.rate = 1;
  local ret = ({length = 1});
  ret[0] = 0.0;
  self.infection = __deceptinfect_infection_INF_STATE.NOT_INFECTED(ret);
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_infection_InfectionComponent.__name__ = "deceptinfect.infection.InfectionComponent"
__deceptinfect_infection_InfectionComponent.prototype = _hx_a();
__deceptinfect_infection_InfectionComponent.prototype.getInfValue = function(self) 
  local _g = self.infection;
  local tmp = _g[1];
  if (tmp) == 0 then 
    local inf = _g[2];
    do return inf[0] end;
  elseif (tmp) == 1 then 
    do return -1 end; end;
end

__deceptinfect_infection_InfectionComponent.prototype.__class__ =  __deceptinfect_infection_InfectionComponent
__deceptinfect_infection_InfectionComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_infection_InfectionComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})
_hxClasses["deceptinfect.infection.AcceptingInfection"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="ACCEPTING","REJECTING"},2)}
__deceptinfect_infection_AcceptingInfection = _hxClasses["deceptinfect.infection.AcceptingInfection"];
__deceptinfect_infection_AcceptingInfection.ACCEPTING = _hx_tab_array({[0]="ACCEPTING",0,__enum__ = __deceptinfect_infection_AcceptingInfection},2)

__deceptinfect_infection_AcceptingInfection.REJECTING = _hx_tab_array({[0]="REJECTING",1,__enum__ = __deceptinfect_infection_AcceptingInfection},2)

_hxClasses["deceptinfect.infection.BaseInfection"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="NOT_USING","USING_GLOBAL","USING_STATIC"},3)}
__deceptinfect_infection_BaseInfection = _hxClasses["deceptinfect.infection.BaseInfection"];
__deceptinfect_infection_BaseInfection.NOT_USING = _hx_tab_array({[0]="NOT_USING",0,__enum__ = __deceptinfect_infection_BaseInfection},2)

__deceptinfect_infection_BaseInfection.USING_GLOBAL = _hx_tab_array({[0]="USING_GLOBAL",1,__enum__ = __deceptinfect_infection_BaseInfection},2)

__deceptinfect_infection_BaseInfection.USING_STATIC = function(rate) local _x = _hx_tab_array({[0]="USING_STATIC",2,rate,__enum__=__deceptinfect_infection_BaseInfection}, 3); return _x; end 
_hxClasses["deceptinfect.infection.INF_STATE"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="NOT_INFECTED","INFECTED"},2)}
__deceptinfect_infection_INF_STATE = _hxClasses["deceptinfect.infection.INF_STATE"];
__deceptinfect_infection_INF_STATE.NOT_INFECTED = function(inf) local _x = _hx_tab_array({[0]="NOT_INFECTED",0,inf,__enum__=__deceptinfect_infection_INF_STATE}, 3); return _x; end 
__deceptinfect_infection_INF_STATE.INFECTED = _hx_tab_array({[0]="INFECTED",1,__enum__ = __deceptinfect_infection_INF_STATE},2)


__deceptinfect_radiation_ContaminationAccepter.new = function() 
  local self = _hx_new(__deceptinfect_radiation_ContaminationAccepter.prototype)
  __deceptinfect_radiation_ContaminationAccepter.super(self)
  return self
end
__deceptinfect_radiation_ContaminationAccepter.super = function(self) 
  self.contam_time = __deceptinfect_util_TimeKeep.new();
  __deceptinfect_ecswip_Component.super(self);
end
__deceptinfect_radiation_ContaminationAccepter.__name__ = "deceptinfect.radiation.ContaminationAccepter"
__deceptinfect_radiation_ContaminationAccepter.prototype = _hx_a();

__deceptinfect_radiation_ContaminationAccepter.prototype.__class__ =  __deceptinfect_radiation_ContaminationAccepter
__deceptinfect_radiation_ContaminationAccepter.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_radiation_ContaminationAccepter.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_radiation_ContaminationProducer.new = function(options) 
  local self = _hx_new(__deceptinfect_radiation_ContaminationProducer.prototype)
  __deceptinfect_radiation_ContaminationProducer.super(self,options)
  return self
end
__deceptinfect_radiation_ContaminationProducer.super = function(self,options) 
  self.type = __deceptinfect_radiation_ContaminationType.SAME_TYPE;
  self.chance = _hx_funcToField(options.chance);
  self.time = _hx_funcToField(options.time);
  self.dist = _hx_funcToField(options.dist);
  self.check = _hx_funcToField(options.check);
  if (options.type ~= nil) then 
    self.type = _hx_funcToField(options.type);
  end;
end
__deceptinfect_radiation_ContaminationProducer.__name__ = "deceptinfect.radiation.ContaminationProducer"
__deceptinfect_radiation_ContaminationProducer.prototype = _hx_a();

__deceptinfect_radiation_ContaminationProducer.prototype.__class__ =  __deceptinfect_radiation_ContaminationProducer
_hxClasses["deceptinfect.radiation.ContaminationType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="ALWAYS","SAME_TYPE","SAME_SOURCE"},3)}
__deceptinfect_radiation_ContaminationType = _hxClasses["deceptinfect.radiation.ContaminationType"];
__deceptinfect_radiation_ContaminationType.ALWAYS = _hx_tab_array({[0]="ALWAYS",0,__enum__ = __deceptinfect_radiation_ContaminationType},2)

__deceptinfect_radiation_ContaminationType.SAME_TYPE = _hx_tab_array({[0]="SAME_TYPE",1,__enum__ = __deceptinfect_radiation_ContaminationType},2)

__deceptinfect_radiation_ContaminationType.SAME_SOURCE = _hx_tab_array({[0]="SAME_SOURCE",2,__enum__ = __deceptinfect_radiation_ContaminationType},2)

_hxClasses["deceptinfect.radiation.RadiationState"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="ENABLED","DISABLED","DESTROYED"},3)}
__deceptinfect_radiation_RadiationState = _hxClasses["deceptinfect.radiation.RadiationState"];
__deceptinfect_radiation_RadiationState.ENABLED = _hx_tab_array({[0]="ENABLED",0,__enum__ = __deceptinfect_radiation_RadiationState},2)

__deceptinfect_radiation_RadiationState.DISABLED = _hx_tab_array({[0]="DISABLED",1,__enum__ = __deceptinfect_radiation_RadiationState},2)

__deceptinfect_radiation_RadiationState.DESTROYED = _hx_tab_array({[0]="DESTROYED",2,__enum__ = __deceptinfect_radiation_RadiationState},2)

_hxClasses["deceptinfect.radiation.RadLifetime"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="FINITE","INFINITE"},2)}
__deceptinfect_radiation_RadLifetime = _hxClasses["deceptinfect.radiation.RadLifetime"];
__deceptinfect_radiation_RadLifetime.FINITE = function(x) local _x = _hx_tab_array({[0]="FINITE",0,x,__enum__=__deceptinfect_radiation_RadLifetime}, 3); return _x; end 
__deceptinfect_radiation_RadLifetime.INFINITE = _hx_tab_array({[0]="INFINITE",1,__enum__ = __deceptinfect_radiation_RadLifetime},2)


__haxe_ds_BalancedTree.new = function() 
  local self = _hx_new(__haxe_ds_BalancedTree.prototype)
  __haxe_ds_BalancedTree.super(self)
  return self
end
__haxe_ds_BalancedTree.super = function(self) 
end
__haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree"
__haxe_ds_BalancedTree.__interfaces__ = {__haxe_IMap}
__haxe_ds_BalancedTree.prototype = _hx_a();
__haxe_ds_BalancedTree.prototype.set = function(self,key,value) 
  self.root = self:setLoop(key, value, self.root);
end
__haxe_ds_BalancedTree.prototype.get = function(self,key) 
  local node = self.root;
  while (node ~= nil) do 
    local c = self:compare(key, node.key);
    if (c == 0) then 
      do return node.value end;
    end;
    if (c < 0) then 
      node = node.left;
    else
      node = node.right;
    end;
  end;
  do return nil end
end
__haxe_ds_BalancedTree.prototype.iterator = function(self) 
  local ret = _hx_tab_array({}, 0);
  self:iteratorLoop(self.root, ret);
  local _gthis = ret;
  local cur_length = 0;
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return cur_length < _gthis.length end;
  end,next=function(self) 
    cur_length = cur_length + 1;
    do return _gthis[cur_length - 1] end;
  end}) end
end
__haxe_ds_BalancedTree.prototype.keys = function(self) 
  local ret = _hx_tab_array({}, 0);
  self:keysLoop(self.root, ret);
  local _gthis = ret;
  local cur_length = 0;
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return cur_length < _gthis.length end;
  end,next=function(self) 
    cur_length = cur_length + 1;
    do return _gthis[cur_length - 1] end;
  end}) end
end
__haxe_ds_BalancedTree.prototype.setLoop = function(self,k,v,node) 
  if (node == nil) then 
    do return __haxe_ds_TreeNode.new(nil, k, v, nil) end;
  end;
  local c = self:compare(k, node.key);
  if (c == 0) then 
    do return __haxe_ds_TreeNode.new(node.left, k, v, node.right, (function() 
      local _hx_1
      if (node == nil) then 
      _hx_1 = 0; else 
      _hx_1 = node._height; end
      return _hx_1
    end )()) end;
  else
    if (c < 0) then 
      local nl = self:setLoop(k, v, node.left);
      do return self:balance(nl, node.key, node.value, node.right) end;
    else
      local nr = self:setLoop(k, v, node.right);
      do return self:balance(node.left, node.key, node.value, nr) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.iteratorLoop = function(self,node,acc) 
  if (node ~= nil) then 
    self:iteratorLoop(node.left, acc);
    acc:push(node.value);
    self:iteratorLoop(node.right, acc);
  end;
end
__haxe_ds_BalancedTree.prototype.keysLoop = function(self,node,acc) 
  if (node ~= nil) then 
    self:keysLoop(node.left, acc);
    acc:push(node.key);
    self:keysLoop(node.right, acc);
  end;
end
__haxe_ds_BalancedTree.prototype.balance = function(self,l,k,v,r) 
  local hl = (function() 
    local _hx_1
    if (l == nil) then 
    _hx_1 = 0; else 
    _hx_1 = l._height; end
    return _hx_1
  end )();
  local hr = (function() 
    local _hx_2
    if (r == nil) then 
    _hx_2 = 0; else 
    _hx_2 = r._height; end
    return _hx_2
  end )();
  if (hl > (hr + 2)) then 
    local _this = l.left;
    local _this1 = l.right;
    if ((function() 
      local _hx_3
      if (_this == nil) then 
      _hx_3 = 0; else 
      _hx_3 = _this._height; end
      return _hx_3
    end )() >= (function() 
      local _hx_4
      if (_this1 == nil) then 
      _hx_4 = 0; else 
      _hx_4 = _this1._height; end
      return _hx_4
    end )()) then 
      do return __haxe_ds_TreeNode.new(l.left, l.key, l.value, __haxe_ds_TreeNode.new(l.right, k, v, r)) end;
    else
      do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value, __haxe_ds_TreeNode.new(l.right.right, k, v, r)) end;
    end;
  else
    if (hr > (hl + 2)) then 
      local _this2 = r.right;
      local _this3 = r.left;
      if ((function() 
        local _hx_5
        if (_this2 == nil) then 
        _hx_5 = 0; else 
        _hx_5 = _this2._height; end
        return _hx_5
      end )() > (function() 
        local _hx_6
        if (_this3 == nil) then 
        _hx_6 = 0; else 
        _hx_6 = _this3._height; end
        return _hx_6
      end )()) then 
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left), r.key, r.value, r.right) end;
      else
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left.left), r.left.key, r.left.value, __haxe_ds_TreeNode.new(r.left.right, r.key, r.value, r.right)) end;
      end;
    else
      do return __haxe_ds_TreeNode.new(l, k, v, r, (function() 
        local _hx_7
        if (hl > hr) then 
        _hx_7 = hl; else 
        _hx_7 = hr; end
        return _hx_7
      end )() + 1) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.compare = function(self,k1,k2) 
  do return Reflect.compare(k1, k2) end
end

__haxe_ds_BalancedTree.prototype.__class__ =  __haxe_ds_BalancedTree

__haxe_ds_EnumValueMap.new = function() 
  local self = _hx_new(__haxe_ds_EnumValueMap.prototype)
  __haxe_ds_EnumValueMap.super(self)
  return self
end
__haxe_ds_EnumValueMap.super = function(self) 
  __haxe_ds_BalancedTree.super(self);
end
__haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap"
__haxe_ds_EnumValueMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_EnumValueMap.prototype = _hx_a();
__haxe_ds_EnumValueMap.prototype.compare = function(self,k1,k2) 
  local d = k1[1] - k2[1];
  if (d ~= 0) then 
    do return d end;
  end;
  local p1 = k1:slice(2);
  local p2 = k2:slice(2);
  if ((p1.length == 0) and (p2.length == 0)) then 
    do return 0 end;
  end;
  do return self:compareArgs(p1, p2) end
end
__haxe_ds_EnumValueMap.prototype.compareArgs = function(self,a1,a2) 
  local ld = a1.length - a2.length;
  if (ld ~= 0) then 
    do return ld end;
  end;
  local _g = 0;
  local _g1 = a1.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local d = self:compareArg(a1[i], a2[i]);
    if (d ~= 0) then 
      do return d end;
    end;
  end;
  do return 0 end
end
__haxe_ds_EnumValueMap.prototype.compareArg = function(self,v1,v2) 
  if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)) then 
    do return self:compare(v1, v2) end;
  else
    if (__lua_Boot.__instanceof(v1, Array) and __lua_Boot.__instanceof(v2, Array)) then 
      do return self:compareArgs(v1, v2) end;
    else
      do return Reflect.compare(v1, v2) end;
    end;
  end;
end

__haxe_ds_EnumValueMap.prototype.__class__ =  __haxe_ds_EnumValueMap
__haxe_ds_EnumValueMap.__super__ = __haxe_ds_BalancedTree
setmetatable(__haxe_ds_EnumValueMap.prototype,{__index=__haxe_ds_BalancedTree.prototype})
_hxClasses["deceptinfect.radiation.RadTypes"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="NEST","CORPSE","INF","PUSTLE","SPIT_HIT","SPIT"},6)}
__deceptinfect_radiation_RadTypes = _hxClasses["deceptinfect.radiation.RadTypes"];
__deceptinfect_radiation_RadTypes.NEST = _hx_tab_array({[0]="NEST",0,__enum__ = __deceptinfect_radiation_RadTypes},2)

__deceptinfect_radiation_RadTypes.CORPSE = _hx_tab_array({[0]="CORPSE",1,__enum__ = __deceptinfect_radiation_RadTypes},2)

__deceptinfect_radiation_RadTypes.INF = _hx_tab_array({[0]="INF",2,__enum__ = __deceptinfect_radiation_RadTypes},2)

__deceptinfect_radiation_RadTypes.PUSTLE = _hx_tab_array({[0]="PUSTLE",3,__enum__ = __deceptinfect_radiation_RadTypes},2)

__deceptinfect_radiation_RadTypes.SPIT_HIT = _hx_tab_array({[0]="SPIT_HIT",4,__enum__ = __deceptinfect_radiation_RadTypes},2)

__deceptinfect_radiation_RadTypes.SPIT = _hx_tab_array({[0]="SPIT",5,__enum__ = __deceptinfect_radiation_RadTypes},2)


__deceptinfect_radiation_RadiationTypes.new = {}
__deceptinfect_radiation_RadiationTypes.__name__ = "deceptinfect.radiation.RadiationTypes"
_hxClasses["deceptinfect.util.Cooldown"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="AVALIABLE","COOLDOWN","UNAVALIABLE"},3)}
__deceptinfect_util_Cooldown = _hxClasses["deceptinfect.util.Cooldown"];
__deceptinfect_util_Cooldown.AVALIABLE = _hx_tab_array({[0]="AVALIABLE",0,__enum__ = __deceptinfect_util_Cooldown},2)

__deceptinfect_util_Cooldown.COOLDOWN = function(time) local _x = _hx_tab_array({[0]="COOLDOWN",1,time,__enum__=__deceptinfect_util_Cooldown}, 3); return _x; end 
__deceptinfect_util_Cooldown.UNAVALIABLE = _hx_tab_array({[0]="UNAVALIABLE",2,__enum__ = __deceptinfect_util_Cooldown},2)


__deceptinfect_util_CooldownTools.new = {}
__deceptinfect_util_CooldownTools.__name__ = "deceptinfect.util.CooldownTools"
__deceptinfect_util_CooldownTools.check = function(x) 
  if (x[1] == 1) then 
    local time = x[2];
    if (_G.CurTime() > time) then 
      do return __deceptinfect_util_Cooldown.AVALIABLE end;
    else
      local x1 = x;
      do return x1 end;
    end;
  else
    local x2 = x;
    do return x2 end;
  end;
end
__deceptinfect_util_CooldownTools.add = function(x,add) 
  if (x[1] == 1) then 
    local time = x[2];
    do return __deceptinfect_util_Cooldown.COOLDOWN(time + add) end;
  else
    local x1 = x;
    do return x1 end;
  end;
end
__deceptinfect_util_CooldownTools.set = function(x,set) 
  local tmp = x[1];
  if (tmp) == 0 then 
    do return __deceptinfect_util_Cooldown.COOLDOWN(_G.CurTime() + set) end;
  elseif (tmp) == 1 then 
    local _g = x[2];
    do return __deceptinfect_util_Cooldown.COOLDOWN(_G.CurTime() + set) end;else
  local x1 = x;
  do return x1 end; end;
end

__deceptinfect_util_EntityExt.new = {}
__deceptinfect_util_EntityExt.__name__ = "deceptinfect.util.EntityExt"
__deceptinfect_util_EntityExt.facingBehind = function(me,target) 
  local this1 = _G.Angle(0, me:EyeAngles().y, 0);
  local vec1 = this1:Forward();
  local this2 = _G.Angle(0, target:EyeAngles().y, 0);
  local vec2 = this2:Forward();
  local dot = _G.math.acos(vec1:Dot(vec2));
  do return dot < (_G.math.pi / 4) end;
end

__deceptinfect_util_PlayerExt.new = {}
__deceptinfect_util_PlayerExt.__name__ = "deceptinfect.util.PlayerExt"
__deceptinfect_util_PlayerExt.setWalkthroughable = function(p,b) 
  if (b) then 
    p:SetCollisionGroup(_G.COLLISION_GROUP_PASSABLE_DOOR);
  else
    p:SetCollisionGroup(_G.COLLISION_GROUP_PLAYER);
  end;
end
__deceptinfect_util_PlayerExt.shouldFreeRoam = function(p) 
  local wrongMode = p:GetObserverMode() == _G.OBS_MODE_NONE;
  local targetDead = _G.IsValid(p:GetObserverTarget()) and not p:GetObserverTarget():Alive();
  local freeRoaming = p:GetObserverMode() == _G.OBS_MODE_ROAMING;
  if (not (wrongMode or targetDead)) then 
    do return not freeRoaming end;
  else
    do return true end;
  end;
end
__deceptinfect_util_PlayerExt.randomIncDec = function(x) 
  local _g = _G.math.random(1, 2);
  if (_g) == 1 then 
    do return x end;
  elseif (_g) == 2 then 
    do return -x end;else
  _G.error("Something went spectacularly wrong",0); end;
end
__deceptinfect_util_PlayerExt.disorientate = function(p) 
  local curangs = p:EyeAngles();
  local curY = curangs.y;
  local punchY = __deceptinfect_util_PlayerExt.randomIncDec(_G.math.random(10, 80));
  curY = curY + punchY;
  if (curY >= 90) then 
    local diff = curY - 90;
    curY = -90 + diff;
  else
    if (curY <= -90) then 
      local diff1 = curY + 90;
      curY = 90 + diff1;
    end;
  end;
  local punchR = __deceptinfect_util_PlayerExt.randomIncDec(_G.math.random(20, 160));
  local finalR = _G.math.NormalizeAngle(curangs.r + punchR);
  local this1 = _G.Angle(curY, finalR, 0);
  p:SetEyeAngles(this1);
end

__deceptinfect_util_TimeKeep.new = function(limitZero) 
  local self = _hx_new(__deceptinfect_util_TimeKeep.prototype)
  __deceptinfect_util_TimeKeep.super(self,limitZero)
  return self
end
__deceptinfect_util_TimeKeep.super = function(self,limitZero) 
  if (limitZero == nil) then 
    limitZero = true;
  end;
  self.times = __haxe_ds_IntMap.new();
  self.limitZero = limitZero;
end
__deceptinfect_util_TimeKeep.__name__ = "deceptinfect.util.TimeKeep"
__deceptinfect_util_TimeKeep.prototype = _hx_a();
__deceptinfect_util_TimeKeep.prototype.addTime = function(self,key) 
  self:initTime(key);
  local difftime = __deceptinfect_GameManager.sure():get_diffTime();
  local _g = key;
  local _g1 = self.times;
  local ret = _g1.h[_g];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  local v = ret + difftime;
  if (v == nil) then 
    _g1.h[_g] = __haxe_ds_IntMap.tnull;
  else
    _g1.h[_g] = v;
  end;
  local ret1 = self.times.h[key];
  if (ret1 == __haxe_ds_IntMap.tnull) then 
    ret1 = nil;
  end;
  do return ret1 end
end
__deceptinfect_util_TimeKeep.prototype.initTime = function(self,key) 
  if (self.times.h[key] == nil) then 
    local _this = self.times;
    _this.h[key] = 0;
  end;
end
__deceptinfect_util_TimeKeep.prototype.setTime = function(self,key,f) 
  local _this = self.times;
  if (f == nil) then 
    _this.h[key] = __haxe_ds_IntMap.tnull;
  else
    _this.h[key] = f;
  end;
end
__deceptinfect_util_TimeKeep.prototype.resetTime = function(self,key) 
  local _this = self.times;
  _this.h[key] = 0;
end
__deceptinfect_util_TimeKeep.prototype.removeTime = function(self,key) 
  self:initTime(key);
  local difftime = __deceptinfect_GameManager.sure():get_diffTime();
  local _g = key;
  local _g1 = self.times;
  local ret = _g1.h[_g];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  local v = ret - difftime;
  if (v == nil) then 
    _g1.h[_g] = __haxe_ds_IntMap.tnull;
  else
    _g1.h[_g] = v;
  end;
  local ret1 = self.times.h[key];
  if (ret1 == __haxe_ds_IntMap.tnull) then 
    ret1 = nil;
  end;
  if (ret1 < 0) then 
    local _this = self.times;
    _this.h[key] = 0;
  end;
  local ret2 = self.times.h[key];
  if (ret2 == __haxe_ds_IntMap.tnull) then 
    ret2 = nil;
  end;
  do return ret2 end
end
__deceptinfect_util_TimeKeep.prototype.getTime = function(self,key) 
  local ret = self.times.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end

__deceptinfect_util_TimeKeep.prototype.__class__ =  __deceptinfect_util_TimeKeep

__gmod__EntityClass_EntityClass_Impl_.new = {}
__gmod__EntityClass_EntityClass_Impl_.__name__ = "gmod._EntityClass.EntityClass_Impl_"
__gmod__EntityClass_EntityClass_Impl_._new = function(name) 
  local this1 = name;
  do return this1 end;
end

__gmod__HaxeMultiReturn_HaxeMultiReturn_Impl_.new = {}
__gmod__HaxeMultiReturn_HaxeMultiReturn_Impl_.__name__ = "gmod._HaxeMultiReturn.HaxeMultiReturn_Impl_"
__gmod__HaxeMultiReturn_HaxeMultiReturn_Impl_.multiReturn = function(rtns) 
  local tbl = ({});
  local access = rtns;
  local _g_access = access;
  local _g_keys = Reflect.fields(access);
  local _g_index = 0;
  while (_g_index < _g_keys.length) do 
    _g_index = _g_index + 1;
    local key = _g_keys[_g_index - 1];
    local _g1 = _hx_o({__fields__={value=true,key=true},value=Reflect.field(_g_access, key),key=key});
    local name = _g1.key;
    local value = _g1.value;
    tbl[_G.string.byte(name, 1) - 96] = value;
  end;
  do return _hx_table.unpack(tbl) end;
end

__gmod__Hooks_Hook_Impl_.new = {}
__gmod__Hooks_Hook_Impl_.__name__ = "gmod._Hooks.Hook_Impl_"
__gmod__Hooks_Hook_Impl_._new = function(name) 
  local this1 = name;
  do return this1 end;
end

__gmod_Hooks.new = {}
__gmod_Hooks.__name__ = "gmod.Hooks"

__gmod_PairTools.new = {}
__gmod_PairTools.__name__ = "gmod.PairTools"
__gmod_PairTools.keyValueIterator = function(table) 
  local _hx_1_p_next, _hx_1_p_table, _hx_1_p_index = _G.pairs(table);
  local next = _hx_1_p_next;
  local i = _hx_1_p_index;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local _hx_2_res_index, _hx_2_res_value = next(table, i);
    i = _hx_2_res_index;
    do return _hx_o({__fields__={key=true,value=true},key=_hx_2_res_index,value=_hx_2_res_value}) end;
  end,hasNext=function(self) 
    do return _G.select(2, _G.next(table, i)) ~= nil end;
  end}) end;
end
__gmod_PairTools.iterator = function(table) 
  local _hx_1_p_next, _hx_1_p_table, _hx_1_p_index = _G.pairs(table);
  local next = _hx_1_p_next;
  local i = _hx_1_p_index;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local _hx_2_res_index, _hx_2_res_value = next(table, i);
    i = _hx_2_res_index;
    do return _hx_2_res_value end;
  end,hasNext=function(self) 
    do return _G.select(2, _G.next(table, i)) ~= nil end;
  end}) end;
end
__gmod_PairTools.ipairsIteratorKV = function(table) 
  local _hx_1_p_next, _hx_1_p_table, _hx_1_p_index = _G.ipairs(table);
  local next = _hx_1_p_next;
  local i = _hx_1_p_index;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local _hx_2_res_index, _hx_2_res_value = next(table, i);
    i = _hx_2_res_index;
    do return _hx_o({__fields__={key=true,value=true},key=_hx_2_res_index,value=_hx_2_res_value}) end;
  end,hasNext=function(self) 
    do return _G.select(2, next(table, i)) ~= nil end;
  end}) end;
end
__gmod_PairTools.ipairsIterator = function(table) 
  local _hx_1_p_next, _hx_1_p_table, _hx_1_p_index = _G.ipairs(table);
  local next = _hx_1_p_next;
  local i = _hx_1_p_index;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local _hx_2_res_index, _hx_2_res_value = next(table, i);
    i = _hx_2_res_index;
    do return _hx_2_res_value end;
  end,hasNext=function(self) 
    do return _G.select(2, next(table, i)) ~= nil end;
  end}) end;
end

__gmod_TableTools.new = {}
__gmod_TableTools.__name__ = "gmod.TableTools"
__gmod_TableTools.length = function(table) 
  do return #table end;
end

__gmod_hooks_Swep.new = {}
__gmod_hooks_Swep.__name__ = "gmod.hooks.Swep"
__gmod_hooks_Swep.prototype = _hx_a();
__gmod_hooks_Swep.prototype.Deploy = function(self) 
  do return nil end
end
__gmod_hooks_Swep.prototype.TakePrimaryAmmo = function(self,amount) 
end
__gmod_hooks_Swep.prototype.CanSecondaryAttack = function(self) 
  do return nil end
end
__gmod_hooks_Swep.prototype.SecondaryAttack = function(self) 
end
__gmod_hooks_Swep.prototype.DoImpactEffect = function(self,tr,damageType) 
  do return nil end
end
__gmod_hooks_Swep.prototype.KeyValue = function(self,key,value) 
  do return nil end
end
__gmod_hooks_Swep.prototype.TranslateFOV = function(self,fov) 
  do return nil end
end
__gmod_hooks_Swep.prototype.CanBePickedUpByNPCs = function(self) 
  do return nil end
end
__gmod_hooks_Swep.prototype.GetNPCRestTimes = function(self) 
  do return nil end
end
__gmod_hooks_Swep.prototype.GetNPCBulletSpread = function(self,proficiency) 
  do return nil end
end
__gmod_hooks_Swep.prototype.GetCapabilities = function(self) 
  do return nil end
end
__gmod_hooks_Swep.prototype.Ammo2 = function(self) 
  do return nil end
end
__gmod_hooks_Swep.prototype.ShootEffects = function(self) 
end
__gmod_hooks_Swep.prototype.TakeSecondaryAmmo = function(self,amount) 
end
__gmod_hooks_Swep.prototype.CanPrimaryAttack = function(self) 
  do return nil end
end
__gmod_hooks_Swep.prototype.Reload = function(self) 
end
__gmod_hooks_Swep.prototype.ShootBullet = function(self,damage,num_bullets,aimcone,ammo_type,force,tracer) 
end
__gmod_hooks_Swep.prototype.AcceptInput = function(self,inputName,activator,called,data) 
  do return nil end
end
__gmod_hooks_Swep.prototype.OnRemove = function(self) 
end
__gmod_hooks_Swep.prototype.OwnerChanged = function(self) 
end
__gmod_hooks_Swep.prototype.Initialize = function(self) 
end
__gmod_hooks_Swep.prototype.EquipAmmo = function(self,ply) 
end
__gmod_hooks_Swep.prototype.TranslateActivity = function(self,act) 
  do return nil end
end
__gmod_hooks_Swep.prototype.Holster = function(self,weapon) 
  do return nil end
end
__gmod_hooks_Swep.prototype.SetDeploySpeed = function(self,speed) 
end
__gmod_hooks_Swep.prototype.Think = function(self) 
end
__gmod_hooks_Swep.prototype.FireAnimationEvent = function(self,pos,ang,event,options) 
  do return nil end
end
__gmod_hooks_Swep.prototype.SetupDataTables = function(self) 
end
__gmod_hooks_Swep.prototype.PrimaryAttack = function(self) 
end
__gmod_hooks_Swep.prototype.Ammo1 = function(self) 
  do return nil end
end
__gmod_hooks_Swep.prototype.OnDrop = function(self) 
end
__gmod_hooks_Swep.prototype.ShouldDropOnDie = function(self) 
  do return nil end
end
__gmod_hooks_Swep.prototype.GetNPCBurstSettings = function(self) 
  do return nil end
end
__gmod_hooks_Swep.prototype.OnRestore = function(self) 
end
__gmod_hooks_Swep.prototype.OnReloaded = function(self) 
end
__gmod_hooks_Swep.prototype.Equip = function(self,NewOwner) 
end
__gmod_hooks_Swep.prototype.SetWeaponHoldType = function(self,name) 
end

__gmod_hooks_Swep.prototype.__class__ =  __gmod_hooks_Swep
_hxClasses["haxe.StackItem"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="CFunction","Module","FilePos","Method","LocalFunction"},5)}
__haxe_StackItem = _hxClasses["haxe.StackItem"];
__haxe_StackItem.CFunction = _hx_tab_array({[0]="CFunction",0,__enum__ = __haxe_StackItem},2)

__haxe_StackItem.Module = function(m) local _x = _hx_tab_array({[0]="Module",1,m,__enum__=__haxe_StackItem}, 3); return _x; end 
__haxe_StackItem.FilePos = function(s,file,line,column) local _x = _hx_tab_array({[0]="FilePos",2,s,file,line,column,__enum__=__haxe_StackItem}, 6); return _x; end 
__haxe_StackItem.Method = function(classname,method) local _x = _hx_tab_array({[0]="Method",3,classname,method,__enum__=__haxe_StackItem}, 4); return _x; end 
__haxe_StackItem.LocalFunction = function(v) local _x = _hx_tab_array({[0]="LocalFunction",4,v,__enum__=__haxe_StackItem}, 3); return _x; end 

__haxe_EntryPoint.new = {}
__haxe_EntryPoint.__name__ = "haxe.EntryPoint"
__haxe_EntryPoint.processEvents = function() 
  while (true) do 
    local f = __haxe_EntryPoint.pending:shift();
    if (f == nil) then 
      break;
    end;
    f();
  end;
  local time = __haxe_MainLoop.tick();
  if (not __haxe_MainLoop.hasEvents() and (__haxe_EntryPoint.threadCount == 0)) then 
    do return -1 end;
  end;
  do return time end;
end
__haxe_EntryPoint.run = function() 
  while (true) do 
    local nextTick = __haxe_EntryPoint.processEvents();
    if (nextTick < 0) then 
      break;
    end;
    local tmp = nextTick > 0;
  end;
end

__haxe_Log.new = {}
__haxe_Log.__name__ = "haxe.Log"
__haxe_Log.formatOutput = function(v,infos) 
  local str = Std.string(v);
  if (infos == nil) then 
    do return str end;
  end;
  local pstr = Std.string(Std.string(infos.fileName) .. Std.string(":")) .. Std.string(infos.lineNumber);
  if (infos.customParams ~= nil) then 
    local _g = 0;
    local _g1 = infos.customParams;
    while (_g < _g1.length) do 
      local v1 = _g1[_g];
      _g = _g + 1;
      str = Std.string(str) .. Std.string((Std.string(", ") .. Std.string(Std.string(v1))));
    end;
  end;
  do return Std.string(Std.string(pstr) .. Std.string(": ")) .. Std.string(str) end;
end
__haxe_Log.trace = function(v,infos) 
  local str = __haxe_Log.formatOutput(v, infos);
  _hx_print(str);
end

__haxe_MainEvent.new = function(f,p) 
  local self = _hx_new(__haxe_MainEvent.prototype)
  __haxe_MainEvent.super(self,f,p)
  return self
end
__haxe_MainEvent.super = function(self,f,p) 
  self.isBlocking = true;
  self.f = _hx_funcToField(f);
  self.priority = p;
  self.nextRun = -_G.math.huge;
end
__haxe_MainEvent.__name__ = "haxe.MainEvent"
__haxe_MainEvent.prototype = _hx_a();
__haxe_MainEvent.prototype.delay = function(self,t) 
  self.nextRun = (function() 
    local _hx_1
    if (t == nil) then 
    _hx_1 = -_G.math.huge; else 
    _hx_1 = Sys.time() + t; end
    return _hx_1
  end )();
end
__haxe_MainEvent.prototype.stop = function(self) 
  if (self.f == nil) then 
    do return end;
  end;
  self.f = nil;
  self.nextRun = -_G.math.huge;
  if (self.prev == nil) then 
    __haxe_MainLoop.pending = self.next;
  else
    self.prev.next = self.next;
  end;
  if (self.next ~= nil) then 
    self.next.prev = self.prev;
  end;
end

__haxe_MainEvent.prototype.__class__ =  __haxe_MainEvent

__haxe_MainLoop.new = {}
__haxe_MainLoop.__name__ = "haxe.MainLoop"
__haxe_MainLoop.hasEvents = function() 
  local p = __haxe_MainLoop.pending;
  while (p ~= nil) do 
    if (p.isBlocking) then 
      do return true end;
    end;
    p = p.next;
  end;
  do return false end;
end
__haxe_MainLoop.add = function(f,priority) 
  if (priority == nil) then 
    priority = 0;
  end;
  if (f == nil) then 
    _G.error("Event function is null",0);
  end;
  local e = __haxe_MainEvent.new(f, priority);
  local head = __haxe_MainLoop.pending;
  if (head ~= nil) then 
    head.prev = e;
  end;
  e.next = head;
  __haxe_MainLoop.pending = e;
  do return e end;
end
__haxe_MainLoop.sortEvents = function() 
  local list = __haxe_MainLoop.pending;
  if (list == nil) then 
    do return end;
  end;
  local insize = 1;
  local nmerges;
  local psize = 0;
  local qsize = 0;
  local p;
  local q;
  local e;
  local tail;
  while (true) do 
    p = list;
    list = nil;
    tail = nil;
    nmerges = 0;
    while (p ~= nil) do 
      nmerges = nmerges + 1;
      q = p;
      psize = 0;
      local _g = 0;
      local _g1 = insize;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        psize = psize + 1;
        q = q.next;
        if (q == nil) then 
          break;
        end;
      end;
      qsize = insize;
      while ((psize > 0) or ((qsize > 0) and (q ~= nil))) do 
        if (psize == 0) then 
          e = q;
          q = q.next;
          qsize = qsize - 1;
        else
          if (((qsize == 0) or (q == nil)) or ((p.priority > q.priority) or ((p.priority == q.priority) and (p.nextRun <= q.nextRun)))) then 
            e = p;
            p = p.next;
            psize = psize - 1;
          else
            e = q;
            q = q.next;
            qsize = qsize - 1;
          end;
        end;
        if (tail ~= nil) then 
          tail.next = e;
        else
          list = e;
        end;
        e.prev = tail;
        tail = e;
      end;
      p = q;
    end;
    tail.next = nil;
    if (nmerges <= 1) then 
      break;
    end;
    insize = insize * 2;
  end;
  list.prev = nil;
  __haxe_MainLoop.pending = list;
end
__haxe_MainLoop.tick = function() 
  __haxe_MainLoop.sortEvents();
  local e = __haxe_MainLoop.pending;
  local now = Sys.time();
  local wait = 1e9;
  while (e ~= nil) do 
    local next = e.next;
    local wt = e.nextRun - now;
    if (wt <= 0) then 
      wait = 0;
      if (e.f ~= nil) then 
        e:f();
      end;
    else
      if (wait > wt) then 
        wait = wt;
      end;
    end;
    e = next;
  end;
  do return wait end;
end

__haxe_Timer.new = function(time_ms) 
  local self = _hx_new(__haxe_Timer.prototype)
  __haxe_Timer.super(self,time_ms)
  return self
end
__haxe_Timer.super = function(self,time_ms) 
  local _gthis = self;
  local dt = time_ms / 1000;
  self.event = __haxe_MainLoop.add(function() 
    local _gthis1 = _gthis.event;
    _gthis1.nextRun = _gthis1.nextRun + dt;
    _gthis:run();
  end);
  self.event:delay(dt);
end
__haxe_Timer.__name__ = "haxe.Timer"
__haxe_Timer.delay = function(f,time_ms) 
  local t = __haxe_Timer.new(time_ms);
  t.run = function(self) 
    t:stop();
    f();
   end;
  do return t end;
end
__haxe_Timer.prototype = _hx_a();
__haxe_Timer.prototype.stop = function(self) 
  if (self.event ~= nil) then 
    self.event:stop();
    self.event = nil;
  end;
end
__haxe_Timer.prototype.run = function(self) 
end

__haxe_Timer.prototype.__class__ =  __haxe_Timer

__haxe_ds_TreeNode.new = function(l,k,v,r,h) 
  local self = _hx_new(__haxe_ds_TreeNode.prototype)
  __haxe_ds_TreeNode.super(self,l,k,v,r,h)
  return self
end
__haxe_ds_TreeNode.super = function(self,l,k,v,r,h) 
  if (h == nil) then 
    h = -1;
  end;
  self.left = l;
  self.key = k;
  self.value = v;
  self.right = r;
  if (h == -1) then 
    local tmp;
    local _this = self.left;
    local _this1 = self.right;
    if ((function() 
      local _hx_1
      if (_this == nil) then 
      _hx_1 = 0; else 
      _hx_1 = _this._height; end
      return _hx_1
    end )() > (function() 
      local _hx_2
      if (_this1 == nil) then 
      _hx_2 = 0; else 
      _hx_2 = _this1._height; end
      return _hx_2
    end )()) then 
      local _this2 = self.left;
      tmp = (function() 
        local _hx_3
        if (_this2 == nil) then 
        _hx_3 = 0; else 
        _hx_3 = _this2._height; end
        return _hx_3
      end )();
    else
      local _this3 = self.right;
      tmp = (function() 
        local _hx_4
        if (_this3 == nil) then 
        _hx_4 = 0; else 
        _hx_4 = _this3._height; end
        return _hx_4
      end )();
    end;
    self._height = tmp + 1;
  else
    self._height = h;
  end;
end
__haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode"
__haxe_ds_TreeNode.prototype = _hx_a();

__haxe_ds_TreeNode.prototype.__class__ =  __haxe_ds_TreeNode
_hxClasses["haxe.ds.Either"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Left","Right"},2)}
__haxe_ds_Either = _hxClasses["haxe.ds.Either"];
__haxe_ds_Either.Left = function(v) local _x = _hx_tab_array({[0]="Left",0,v,__enum__=__haxe_ds_Either}, 3); return _x; end 
__haxe_ds_Either.Right = function(v) local _x = _hx_tab_array({[0]="Right",1,v,__enum__=__haxe_ds_Either}, 3); return _x; end 
_hxClasses["haxe.ds.Option"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Some","None"},2)}
__haxe_ds_Option = _hxClasses["haxe.ds.Option"];
__haxe_ds_Option.Some = function(v) local _x = _hx_tab_array({[0]="Some",0,v,__enum__=__haxe_ds_Option}, 3); return _x; end 
__haxe_ds_Option.None = _hx_tab_array({[0]="None",1,__enum__ = __haxe_ds_Option},2)


__lua_Boot.new = {}
__lua_Boot.__name__ = "lua.Boot"
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      local x = o;
      do return (function() 
        local _hx_1
        if (x < __lua_Boot.Min_Int32) then 
        _hx_1 = __lua_Boot.Min_Int32; elseif (x > __lua_Boot.Max_Int32) then 
        _hx_1 = __lua_Boot.Max_Int32; else 
        _hx_1 = _G.math.floor(x); end
        return _hx_1
      end )() == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl2 = o.__class__;
        tmp = (function() 
          local _hx_2
          if (cl2 ~= nil) then 
          _hx_2 = cl2; else 
          _hx_2 = nil; end
          return _hx_2
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Class) then 
      _hx_3 = o.__name__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_4
      if (cl == Enum) then 
      _hx_4 = o.__ename__ ~= nil; else 
      _hx_4 = false; end
      return _hx_4
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.printEnum = function(o,s) 
  if (o.length == 2) then 
    do return o[0] end;
  else
    local str = Std.string(Std.string(o[0])) .. Std.string("(");
    s = Std.string(s) .. Std.string("\t");
    local _g = 2;
    local _g1 = o.length;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      if (i ~= 2) then 
        str = Std.string(str) .. Std.string((Std.string(",") .. Std.string(__lua_Boot.__string_rec(o[i], s))));
      else
        str = Std.string(str) .. Std.string(__lua_Boot.__string_rec(o[i], s));
      end;
    end;
    do return Std.string(str) .. Std.string(")") end;
  end;
end
__lua_Boot.printClassRec = function(c,result,s) 
  if (result == nil) then 
    result = "";
  end;
  local f = __lua_Boot.__string_rec;
  for k,v in pairs(c) do if result ~= '' then result = result .. ', ' end result = result .. k .. ':' .. f(v, s.. '	') end;
  do return result end;
end
__lua_Boot.__string_rec = function(o,s) 
  if (s == nil) then 
    s = "";
  end;
  if (#s >= 5) then 
    do return "<...>" end;
  end;
  local _g = type(o);
  if (_g) == "boolean" then 
    do return tostring(o) end;
  elseif (_g) == "function" then 
    do return "<function>" end;
  elseif (_g) == "nil" then 
    do return "null" end;
  elseif (_g) == "number" then 
    if (o == _G.math.huge) then 
      do return "Infinity" end;
    else
      if (o == -_G.math.huge) then 
        do return "-Infinity" end;
      else
        if (o == 0) then 
          do return "0" end;
        else
          if (o ~= o) then 
            do return "NaN" end;
          else
            do return tostring(o) end;
          end;
        end;
      end;
    end;
  elseif (_g) == "string" then 
    do return o end;
  elseif (_g) == "table" then 
    if (o.__enum__ ~= nil) then 
      do return __lua_Boot.printEnum(o, s) end;
    else
      if ((_hx_wrap_if_string_field(o,'toString') ~= nil) and not __lua_Boot.isArray(o)) then 
        do return _hx_wrap_if_string_field(o,'toString')(o) end;
      else
        if (__lua_Boot.isArray(o)) then 
          local o2 = o;
          if (#s > 5) then 
            do return "[...]" end;
          else
            local _g1 = _hx_tab_array({}, 0);
            local _g11 = 0;
            while (_g11 < o2.length) do 
              local i = o2[_g11];
              _g11 = _g11 + 1;
              _g1:push(__lua_Boot.__string_rec(i, Std.string(s) .. Std.string(1)));
            end;
            do return Std.string(Std.string("[") .. Std.string(_g1:join(","))) .. Std.string("]") end;
          end;
        else
          if (o.__class__ ~= nil) then 
            do return Std.string(Std.string("{") .. Std.string(__lua_Boot.printClassRec(o, "", Std.string(s) .. Std.string("\t")))) .. Std.string("}") end;
          else
            local fields = __lua_Boot.fieldIterator(o);
            local buffer = ({});
            local first = true;
            _G.table.insert(buffer, "{ ");
            local f = fields;
            while (f:hasNext()) do 
              local f1 = f:next();
              if (first) then 
                first = false;
              else
                _G.table.insert(buffer, ", ");
              end;
              _G.table.insert(buffer, Std.string(Std.string(Std.string("") .. Std.string(Std.string(f1))) .. Std.string(" : ")) .. Std.string(__lua_Boot.__string_rec(o[f1], Std.string(s) .. Std.string("\t"))));
            end;
            _G.table.insert(buffer, " }");
            do return _G.table.concat(buffer, "") end;
          end;
        end;
      end;
    end;
  elseif (_g) == "thread" then 
    do return "<thread>" end;
  elseif (_g) == "userdata" then 
    local mt = _G.getmetatable(o);
    if ((mt ~= nil) and (mt.__tostring ~= nil)) then 
      do return _G.tostring(o) end;
    else
      do return "<userdata>" end;
    end;else
  _G.error("Unknown Lua type",0); end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g = 1;
        local _g1 = _hx_table.maxn(intf) + 1;
        while (_g < _g1) do 
          _g = _g + 1;
          local i = _g - 1;
          if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
            do return true end;
          end;
        end;
      end;
    end;
  end;
  do return __lua_Boot.extendsOrImplements(cl1.__super__, cl2) end;
end
__lua_Boot.fieldIterator = function(o) 
  if (_G.type(o) ~= "table") then 
    do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
      do return nil end;
    end,hasNext=function(self) 
      do return false end;
    end}) end;
  end;
  local tbl = (function() 
    local _hx_1
    if (o.__fields__ ~= nil) then 
    _hx_1 = o.__fields__; else 
    _hx_1 = o; end
    return _hx_1
  end )();
  local cur = _G.pairs(tbl);
  local next_valid = function(tbl1,val) 
    while (__lua_Boot.hiddenFields[val] ~= nil) do 
      val = cur(tbl1, val);
    end;
    do return val end;
  end;
  local cur_val = next_valid(tbl, cur(tbl, nil));
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur_val;
    cur_val = next_valid(tbl, cur(tbl, cur_val));
    do return ret end;
  end,hasNext=function(self) 
    do return cur_val ~= nil end;
  end}) end;
end

__haxe_iterators_MapKeyValueIterator.new = function(map) 
  local self = _hx_new(__haxe_iterators_MapKeyValueIterator.prototype)
  __haxe_iterators_MapKeyValueIterator.super(self,map)
  return self
end
__haxe_iterators_MapKeyValueIterator.super = function(self,map) 
  self.map = map;
  self.keys = map:keys();
end
__haxe_iterators_MapKeyValueIterator.__name__ = "haxe.iterators.MapKeyValueIterator"
__haxe_iterators_MapKeyValueIterator.prototype = _hx_a();
__haxe_iterators_MapKeyValueIterator.prototype.hasNext = function(self) 
  do return self.keys:hasNext() end
end
__haxe_iterators_MapKeyValueIterator.prototype.next = function(self) 
  local key = self.keys:next();
  do return _hx_o({__fields__={value=true,key=true},value=self.map:get(key),key=key}) end
end

__haxe_iterators_MapKeyValueIterator.prototype.__class__ =  __haxe_iterators_MapKeyValueIterator

__lua_UserData.new = {}
__lua_UserData.__name__ = "lua.UserData"

__lua_Thread.new = {}
__lua_Thread.__name__ = "lua.Thread"

__tink_core_Annex.new = function(target) 
  local self = _hx_new(__tink_core_Annex.prototype)
  __tink_core_Annex.super(self,target)
  return self
end
__tink_core_Annex.super = function(self,target) 
  self.target = target;
  self.registry = __haxe_ds_ObjectMap.new();
end
__tink_core_Annex.__name__ = "tink.core.Annex"
__tink_core_Annex.prototype = _hx_a();

__tink_core_Annex.prototype.__class__ =  __tink_core_Annex

__tink_core__Callback_Callback_Impl_.new = {}
__tink_core__Callback_Callback_Impl_.__name__ = "tink.core._Callback.Callback_Impl_"
__tink_core__Callback_Callback_Impl_._new = function(f) 
  local this1 = f;
  do return this1 end;
end
__tink_core__Callback_Callback_Impl_.toFunction = function(this1) 
  do return this1 end;
end
__tink_core__Callback_Callback_Impl_.invoke = function(this1,data) 
  if (__tink_core__Callback_Callback_Impl_.depth < 500) then 
    __tink_core__Callback_Callback_Impl_.depth = __tink_core__Callback_Callback_Impl_.depth + 1;
    this1(data);
    __tink_core__Callback_Callback_Impl_.depth = __tink_core__Callback_Callback_Impl_.depth - 1;
  else
    local _e = this1;
    local f = function(data1) 
      __tink_core__Callback_Callback_Impl_.invoke(_e, data1);
    end;
    local data2 = data;
    __tink_core__Callback_Callback_Impl_.defer(function() 
      f(data2);
    end);
  end;
end
__tink_core__Callback_Callback_Impl_.ignore = function(cb) 
  do return function(_) 
    __tink_core__Callback_Callback_Impl_.invoke(cb, __tink_core_Noise.Noise);
  end end;
end
__tink_core__Callback_Callback_Impl_.fromNiladic = function(f) 
  do return function(_) 
    f();
  end end;
end
__tink_core__Callback_Callback_Impl_.fromMany = function(callbacks) 
  do return function(v) 
    local _g = 0;
    while (_g < callbacks.length) do 
      local callback = callbacks[_g];
      _g = _g + 1;
      __tink_core__Callback_Callback_Impl_.invoke(callback, v);
    end;
  end end;
end
__tink_core__Callback_Callback_Impl_.defer = function(f) 
  __haxe_Timer.delay(f, 0);
end

__tink_core_LinkObject.new = {}
__tink_core_LinkObject.__name__ = "tink.core.LinkObject"
__tink_core_LinkObject.prototype = _hx_a();

__tink_core_LinkObject.prototype.__class__ =  __tink_core_LinkObject

__tink_core__Callback_CallbackLink_Impl_.new = {}
__tink_core__Callback_CallbackLink_Impl_.__name__ = "tink.core._Callback.CallbackLink_Impl_"
__tink_core__Callback_CallbackLink_Impl_._new = function(link) 
  local this1 = __tink_core_SimpleLink.new(link);
  do return this1 end;
end
__tink_core__Callback_CallbackLink_Impl_.cancel = function(this1) 
  if (this1 ~= nil) then 
    this1:cancel();
  end;
end
__tink_core__Callback_CallbackLink_Impl_.dissolve = function(this1) 
  if (this1 ~= nil) then 
    this1:cancel();
  end;
end
__tink_core__Callback_CallbackLink_Impl_.noop = function() 
end
__tink_core__Callback_CallbackLink_Impl_.toFunction = function(this1) 
  if (this1 == nil) then 
    do return __tink_core__Callback_CallbackLink_Impl_.noop end;
  else
    do return _hx_bind(this1,_hx_bind(this1,this1.cancel)) end;
  end;
end
__tink_core__Callback_CallbackLink_Impl_.toCallback = function(this1) 
  do return function(_) 
    this1:cancel();
  end end;
end
__tink_core__Callback_CallbackLink_Impl_.fromFunction = function(f) 
  local this1 = __tink_core_SimpleLink.new(f);
  do return this1 end;
end
__tink_core__Callback_CallbackLink_Impl_.join = function(a,b) 
  do return __tink_core__Callback_LinkPair.new(a, b) end;
end
__tink_core__Callback_CallbackLink_Impl_.fromMany = function(callbacks) 
  local this1 = __tink_core_SimpleLink.new(function() 
    if (callbacks ~= nil) then 
      local _g = 0;
      while (_g < callbacks.length) do 
        local cb = callbacks[_g];
        _g = _g + 1;
        if (cb ~= nil) then 
          cb:cancel();
        end;
      end;
    else
      callbacks = nil;
    end;
  end);
  do return this1 end;
end

__tink_core_SimpleLink.new = function(f) 
  local self = _hx_new(__tink_core_SimpleLink.prototype)
  __tink_core_SimpleLink.super(self,f)
  return self
end
__tink_core_SimpleLink.super = function(self,f) 
  self.f = _hx_funcToField(f);
end
__tink_core_SimpleLink.__name__ = "tink.core.SimpleLink"
__tink_core_SimpleLink.__interfaces__ = {__tink_core_LinkObject}
__tink_core_SimpleLink.prototype = _hx_a();
__tink_core_SimpleLink.prototype.cancel = function(self) 
  if (self.f ~= nil) then 
    self:f();
    self.f = nil;
  end;
end

__tink_core_SimpleLink.prototype.__class__ =  __tink_core_SimpleLink

__tink_core__Callback_LinkPair.new = function(a,b) 
  local self = _hx_new(__tink_core__Callback_LinkPair.prototype)
  __tink_core__Callback_LinkPair.super(self,a,b)
  return self
end
__tink_core__Callback_LinkPair.super = function(self,a,b) 
  self.dissolved = false;
  self.a = a;
  self.b = b;
end
__tink_core__Callback_LinkPair.__name__ = "tink.core._Callback.LinkPair"
__tink_core__Callback_LinkPair.__interfaces__ = {__tink_core_LinkObject}
__tink_core__Callback_LinkPair.prototype = _hx_a();
__tink_core__Callback_LinkPair.prototype.cancel = function(self) 
  if (not self.dissolved) then 
    self.dissolved = true;
    local this1 = self.a;
    if (this1 ~= nil) then 
      this1:cancel();
    end;
    local this2 = self.b;
    if (this2 ~= nil) then 
      this2:cancel();
    end;
    self.a = nil;
    self.b = nil;
  end;
end

__tink_core__Callback_LinkPair.prototype.__class__ =  __tink_core__Callback_LinkPair

__tink_core__Callback_ListCell.new = function(cb,list) 
  local self = _hx_new(__tink_core__Callback_ListCell.prototype)
  __tink_core__Callback_ListCell.super(self,cb,list)
  return self
end
__tink_core__Callback_ListCell.super = function(self,cb,list) 
  if (cb == nil) then 
    _G.error("callback expected but null received",0);
  end;
  self.cb = cb;
  self.list = list;
end
__tink_core__Callback_ListCell.__name__ = "tink.core._Callback.ListCell"
__tink_core__Callback_ListCell.__interfaces__ = {__tink_core_LinkObject}
__tink_core__Callback_ListCell.prototype = _hx_a();
__tink_core__Callback_ListCell.prototype.invoke = function(self,data) 
  if (self.list ~= nil) then 
    __tink_core__Callback_Callback_Impl_.invoke(self.cb, data);
  end;
end
__tink_core__Callback_ListCell.prototype.clear = function(self) 
  self.cb = nil;
  self.list = nil;
end
__tink_core__Callback_ListCell.prototype.cancel = function(self) 
  if (self.list ~= nil) then 
    local list = self.list;
    self.cb = nil;
    self.list = nil;
    local tmp = (function() 
    local _hx_obj = list;
    local _hx_fld = 'used';
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  - 1;
     return _hx_obj[_hx_fld];
     end)();
    if (tmp < (_hx_bit.arshift(list.used,1))) then 
      list:compact();
    end;
  end;
end

__tink_core__Callback_ListCell.prototype.__class__ =  __tink_core__Callback_ListCell

__tink_core_CallbackList.new = function() 
  local self = _hx_new(__tink_core_CallbackList.prototype)
  __tink_core_CallbackList.super(self)
  return self
end
__tink_core_CallbackList.super = function(self) 
  self.busy = false;
  self.queue = _hx_tab_array({}, 0);
  self.used = 0;
  self.cells = _hx_tab_array({}, 0);
end
__tink_core_CallbackList.__name__ = "tink.core.CallbackList"
__tink_core_CallbackList.prototype = _hx_a();
__tink_core_CallbackList.prototype.ondrain = function(self) 
end
__tink_core_CallbackList.prototype.get_length = function(self) 
  do return self.used end
end
__tink_core_CallbackList.prototype.release = function(self) 
  local tmp = (function() 
  local _hx_obj = self;
  local _hx_fld = 'used';
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  - 1;
   return _hx_obj[_hx_fld];
   end)();
  if (tmp < (_hx_bit.arshift(self.used,1))) then 
    self:compact();
  end;
end
__tink_core_CallbackList.prototype.add = function(self,cb) 
  local node = __tink_core__Callback_ListCell.new(cb, self);
  self.cells:push(node);
  self.used = self.used + 1;
  do return node end
end
__tink_core_CallbackList.prototype.invoke = function(self,data,destructive) 
  if (self.busy) then 
    local f = _hx_bind(self,self.invoke);
    local data1 = data;
    local destructive1 = destructive;
    local tmp = function() 
      f(data1, destructive1);
      do return end;
    end;
    self.queue:push(tmp);
  else
    self.busy = true;
    local length = self.cells.length;
    local _g = 0;
    local _g1 = length;
    while (_g < _g1) do 
      _g = _g + 1;
      local i = _g - 1;
      local _this = self.cells[i];
      if (_this.list ~= nil) then 
        __tink_core__Callback_Callback_Impl_.invoke(_this.cb, data);
      end;
    end;
    self.busy = false;
    if (destructive) then 
      local added = self.cells.length - length;
      local _g2 = 0;
      local _g3 = length;
      while (_g2 < _g3) do 
        _g2 = _g2 + 1;
        local i1 = _g2 - 1;
        local _this1 = self.cells[i1];
        _this1.cb = nil;
        _this1.list = nil;
      end;
      local _g4 = 0;
      local _g5 = added;
      while (_g4 < _g5) do 
        _g4 = _g4 + 1;
        local i2 = _g4 - 1;
        self.cells[i2] = self.cells[length + i2];
      end;
      self:resize(added);
    else
      if (self.used < self.cells.length) then 
        self:compact();
      end;
    end;
    if (self.queue.length > 0) then 
      (self.queue:shift())();
    end;
  end;
end
__tink_core_CallbackList.prototype.compact = function(self) 
  if (self.busy) then 
    do return end;
  else
    if (self.used == 0) then 
      self:resize(0);
      self:ondrain();
    else
      local compacted = 0;
      local _g = 0;
      local _g1 = self.cells.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        local _g2 = self.cells[i];
        local _g21 = _g2.list;
        if (_g2.cb ~= nil) then 
          local v = _g2;
          if (compacted ~= i) then 
            self.cells[compacted] = v;
          end;
          compacted = compacted + 1;
          if (compacted == self.used) then 
            break;
          end;
        end;
      end;
      self:resize(self.used);
    end;
  end;
end
__tink_core_CallbackList.prototype.resize = function(self,length) 
  self.cells:resize(length);
end
__tink_core_CallbackList.prototype.clear = function(self) 
  if (self.busy) then 
    self.queue:push(_hx_bind(self,self.clear));
  end;
  local _g = 0;
  local _g1 = self.cells;
  while (_g < _g1.length) do 
    local cell = _g1[_g];
    _g = _g + 1;
    cell.cb = nil;
    cell.list = nil;
  end;
  self:resize(0);
end

__tink_core_CallbackList.prototype.__class__ =  __tink_core_CallbackList

__tink_core_TypedError.new = function(code,message,pos) 
  local self = _hx_new(__tink_core_TypedError.prototype)
  __tink_core_TypedError.super(self,code,message,pos)
  return self
end
__tink_core_TypedError.super = function(self,code,message,pos) 
  if (code == nil) then 
    code = 500;
  end;
  self.isTinkError = true;
  self.code = code;
  self.message = message;
  self.pos = pos;
  self.exceptionStack = _hx_tab_array({}, 0);
  self.callStack = _hx_tab_array({}, 0);
end
__tink_core_TypedError.__name__ = "tink.core.TypedError"
__tink_core_TypedError.withData = function(code,message,data,pos) 
  do return __tink_core_TypedError.typed(code, message, data, pos) end;
end
__tink_core_TypedError.typed = function(code,message,data,pos) 
  local ret = __tink_core_TypedError.new(code, message, pos);
  ret.data = data;
  do return ret end;
end
__tink_core_TypedError.asError = function(v) 
  local value = v;
  if (__lua_Boot.__instanceof(value, __tink_core_TypedError)) then 
    do return value end;
  else
    do return nil end;
  end;
end
__tink_core_TypedError.catchExceptions = function(f,report,pos) 
  local _hx_status, _hx_result = pcall(function() 
  
      do return __tink_core_Outcome.Success(f()) end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
  
    local _hx_1 = _hx_result
    local e = _hx_1
    local _g = __tink_core_TypedError.asError(e);
    local tmp;
    if (_g == nil) then 
      tmp = (function() 
        local _hx_2
        if (report == nil) then 
        _hx_2 = __tink_core_TypedError.withData(nil, "Unexpected Error", e, pos); else 
        _hx_2 = report(e); end
        return _hx_2
      end )();
    else
      local e1 = _g;
      tmp = e1;
    end;
    do return __tink_core_Outcome.Failure(tmp) end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__tink_core_TypedError.reporter = function(code,message,pos) 
  do return function(e) 
    do return __tink_core_TypedError.withData(code, message, e, pos) end;
  end end;
end
__tink_core_TypedError.rethrow = function(any) 
  _G.error(any,0);
end
__tink_core_TypedError.tryFinally = function(f,cleanup) 
  local _hx_status, _hx_result = pcall(function() 
  
      local ret = f();
      cleanup();
      do return ret end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
  
    local _hx_1 = _hx_result
    local e = _hx_1
    cleanup();
    _G.error(e,0);
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__tink_core_TypedError.prototype = _hx_a();
__tink_core_TypedError.prototype.printPos = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(self.pos.className) .. Std.string(".")) .. Std.string(self.pos.methodName)) .. Std.string(":")) .. Std.string(self.pos.lineNumber) end
end
__tink_core_TypedError.prototype.toString = function(self) 
  local ret = Std.string(Std.string(Std.string("Error#") .. Std.string(self.code)) .. Std.string(": ")) .. Std.string(self.message);
  if (self.pos ~= nil) then 
    ret = Std.string(ret) .. Std.string((Std.string(" @ ") .. Std.string(self:printPos())));
  end;
  do return ret end
end
__tink_core_TypedError.prototype.throwSelf = function(self) 
  local any = self;
  _G.error(any,0);
end

__tink_core_TypedError.prototype.__class__ =  __tink_core_TypedError

__tink_core__Error_Stack_Impl_.new = {}
__tink_core__Error_Stack_Impl_.__name__ = "tink.core._Error.Stack_Impl_"
__tink_core__Error_Stack_Impl_.toString = function(this1) 
  do return "Error stack not available. Compile with -D error_stack." end;
end

__tink_core__Future_FutureObject.new = {}
__tink_core__Future_FutureObject.__name__ = "tink.core._Future.FutureObject"
__tink_core__Future_FutureObject.prototype = _hx_a();

__tink_core__Future_FutureObject.prototype.__class__ =  __tink_core__Future_FutureObject

__tink_core__Future_NeverFuture.new = function() 
  local self = _hx_new(__tink_core__Future_NeverFuture.prototype)
  __tink_core__Future_NeverFuture.super(self)
  return self
end
__tink_core__Future_NeverFuture.super = function(self) 
end
__tink_core__Future_NeverFuture.__name__ = "tink.core._Future.NeverFuture"
__tink_core__Future_NeverFuture.__interfaces__ = {__tink_core__Future_FutureObject}
__tink_core__Future_NeverFuture.prototype = _hx_a();
__tink_core__Future_NeverFuture.prototype.map = function(self,f) 
  do return __tink_core__Future_NeverFuture.inst end
end
__tink_core__Future_NeverFuture.prototype.flatMap = function(self,f) 
  do return __tink_core__Future_NeverFuture.inst end
end
__tink_core__Future_NeverFuture.prototype.handle = function(self,callback) 
  do return nil end
end
__tink_core__Future_NeverFuture.prototype.gather = function(self) 
  do return __tink_core__Future_NeverFuture.inst end
end
__tink_core__Future_NeverFuture.prototype.eager = function(self) 
  do return __tink_core__Future_NeverFuture.inst end
end

__tink_core__Future_NeverFuture.prototype.__class__ =  __tink_core__Future_NeverFuture
_hxClasses["tink.core.Noise"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Noise"},1)}
__tink_core_Noise = _hxClasses["tink.core.Noise"];
__tink_core_Noise.Noise = _hx_tab_array({[0]="Noise",0,__enum__ = __tink_core_Noise},2)


__tink_core__Lazy_LazyObject.new = {}
__tink_core__Lazy_LazyObject.__name__ = "tink.core._Lazy.LazyObject"
__tink_core__Lazy_LazyObject.prototype = _hx_a();

__tink_core__Lazy_LazyObject.prototype.__class__ =  __tink_core__Lazy_LazyObject

__tink_core__Lazy_LazyConst.new = function(value) 
  local self = _hx_new(__tink_core__Lazy_LazyConst.prototype)
  __tink_core__Lazy_LazyConst.super(self,value)
  return self
end
__tink_core__Lazy_LazyConst.super = function(self,value) 
  self.value = value;
end
__tink_core__Lazy_LazyConst.__name__ = "tink.core._Lazy.LazyConst"
__tink_core__Lazy_LazyConst.__interfaces__ = {__tink_core__Lazy_LazyObject}
__tink_core__Lazy_LazyConst.prototype = _hx_a();
__tink_core__Lazy_LazyConst.prototype.get = function(self) 
  do return self.value end
end
__tink_core__Lazy_LazyConst.prototype.map = function(self,f) 
  local _gthis = self;
  do return __tink_core__Lazy_LazyFunc.new(function() 
    do return f(_gthis.value) end;
  end) end
end
__tink_core__Lazy_LazyConst.prototype.flatMap = function(self,f) 
  local _gthis = self;
  do return __tink_core__Lazy_LazyFunc.new(function() 
    do return f(_gthis.value):get() end;
  end) end
end

__tink_core__Lazy_LazyConst.prototype.__class__ =  __tink_core__Lazy_LazyConst

__tink_core__Future_SyncFuture.new = function(value) 
  local self = _hx_new(__tink_core__Future_SyncFuture.prototype)
  __tink_core__Future_SyncFuture.super(self,value)
  return self
end
__tink_core__Future_SyncFuture.super = function(self,value) 
  self.value = value;
end
__tink_core__Future_SyncFuture.__name__ = "tink.core._Future.SyncFuture"
__tink_core__Future_SyncFuture.__interfaces__ = {__tink_core__Future_FutureObject}
__tink_core__Future_SyncFuture.prototype = _hx_a();
__tink_core__Future_SyncFuture.prototype.map = function(self,f) 
  do return __tink_core__Future_SyncFuture.new(self.value:map(f)) end
end
__tink_core__Future_SyncFuture.prototype.flatMap = function(self,f) 
  local _gthis = self;
  do return __tink_core__Future_SuspendableFuture.new(function(yield) 
    local tmp = _gthis.value:get();
    do return f(tmp):handle(yield) end;
  end) end
end
__tink_core__Future_SyncFuture.prototype.handle = function(self,cb) 
  __tink_core__Callback_Callback_Impl_.invoke(cb, self.value:get());
  do return nil end
end
__tink_core__Future_SyncFuture.prototype.eager = function(self) 
  do return self end
end
__tink_core__Future_SyncFuture.prototype.gather = function(self) 
  do return self end
end

__tink_core__Future_SyncFuture.prototype.__class__ =  __tink_core__Future_SyncFuture

__tink_core__Future_Future_Impl_.new = {}
__tink_core__Future_Future_Impl_.__name__ = "tink.core._Future.Future_Impl_"
__tink_core__Future_Future_Impl_._new = function(f) 
  local this1 = __tink_core__Future_SuspendableFuture.new(f);
  do return this1 end;
end
__tink_core__Future_Future_Impl_.first = function(this1,other) 
  local ret = __tink_core_FutureTrigger.new();
  local l1 = this1:handle(_hx_bind(ret,ret.trigger));
  local l2 = other:handle(_hx_bind(ret,ret.trigger));
  local ret1 = ret;
  if (l1 ~= nil) then 
    local this2 = l1;
    ret1:handle(function(_) 
      this2:cancel();
    end);
  end;
  if (l2 ~= nil) then 
    local this3 = l2;
    ret1:handle(function(_1) 
      this3:cancel();
    end);
  end;
  do return ret1 end;
end
__tink_core__Future_Future_Impl_.map = function(this1,f,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local ret = this1:map(f);
  if (gather) then 
    do return ret:gather() end;
  else
    do return ret end;
  end;
end
__tink_core__Future_Future_Impl_.flatMap = function(this1,next,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local ret = this1:flatMap(next);
  if (gather) then 
    do return ret:gather() end;
  else
    do return ret end;
  end;
end
__tink_core__Future_Future_Impl_.next = function(this1,n) 
  do return this1:flatMap(function(v) 
    do return n(v) end;
  end) end;
end
__tink_core__Future_Future_Impl_.merge = function(this1,other,merger,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local gather1 = gather;
  if (gather1 == nil) then 
    gather1 = true;
  end;
  local ret = this1:flatMap(function(t) 
    local gather2 = false;
    if (gather2 == nil) then 
      gather2 = true;
    end;
    local ret1 = other:map(function(a) 
      do return merger(t, a) end;
    end);
    if (gather2) then 
      do return ret1:gather() end;
    else
      do return ret1 end;
    end;
  end);
  if (gather1) then 
    do return ret:gather() end;
  else
    do return ret end;
  end;
end
__tink_core__Future_Future_Impl_.flatten = function(f) 
  do return __tink_core__Future_SuspendableFuture.new(function(yield) 
    local inner = nil;
    local outer = f:handle(function(second) 
      inner = second:handle(yield);
    end);
    local this1 = __tink_core_SimpleLink.new(function() 
      if (inner ~= nil) then 
        inner:cancel();
      end;
    end);
    do return __tink_core__Callback_LinkPair.new(outer, this1) end;
  end) end;
end
__tink_core__Future_Future_Impl_.ofAny = function(v) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(v)) end;
end
__tink_core__Future_Future_Impl_.asPromise = function(s) 
  do return s end;
end
__tink_core__Future_Future_Impl_.ofMany = function(futures,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local ret = __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(_hx_tab_array({}, 0)));
  local _g = 0;
  while (_g < futures.length) do 
    local f = _hx_tab_array({[0]=futures[_g]}, 1);
    _g = _g + 1;
    local gather1 = false;
    if (gather1 == nil) then 
      gather1 = true;
    end;
    local ret1 = ret:flatMap((function(f1) 
      do return function(results) 
        local gather2 = false;
        if (gather2 == nil) then 
          gather2 = true;
        end;
        local ret2 = (function() 
          do return function(result) 
            do return results:concat(_hx_tab_array({[0]=result}, 1)) end;
          end end;
        end)();
        local ret3 = f1[0]:map(ret2);
        if (gather2) then 
          do return ret3:gather() end;
        else
          do return ret3 end;
        end;
      end end;
    end)(f));
    ret = (function() 
      local _hx_1
      if (gather1) then 
      _hx_1 = ret1:gather(); else 
      _hx_1 = ret1; end
      return _hx_1
    end )();
  end;
  if (gather) then 
    do return ret:gather() end;
  else
    do return ret end;
  end;
end
__tink_core__Future_Future_Impl_.fromMany = function(futures) 
  do return __tink_core__Future_Future_Impl_.ofMany(futures) end;
end
__tink_core__Future_Future_Impl_.lazy = function(l) 
  do return __tink_core__Future_SyncFuture.new(l) end;
end
__tink_core__Future_Future_Impl_.sync = function(v) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(v)) end;
end
__tink_core__Future_Future_Impl_.async = function(f,lazy) 
  if (lazy == nil) then 
    lazy = false;
  end;
  if (lazy) then 
    do return __tink_core__Future_SuspendableFuture.new(function(yield) 
      f(yield);
      do return nil end;
    end) end;
  else
    local op = __tink_core_FutureTrigger.new();
    local wrapped = f;
    __tink_core__Callback_Callback_Impl_.invoke(wrapped, _hx_bind(op,op.trigger));
    do return op end;
  end;
end
__tink_core__Future_Future_Impl_["or"] = function(a,b) 
  do return __tink_core__Future_Future_Impl_.first(a, b) end;
end
__tink_core__Future_Future_Impl_.either = function(a,b) 
  local gather = false;
  if (gather == nil) then 
    gather = true;
  end;
  local ret = a:map(__haxe_ds_Either.Left);
  local tmp = (function() 
    local _hx_1
    if (gather) then 
    _hx_1 = ret:gather(); else 
    _hx_1 = ret; end
    return _hx_1
  end )();
  local gather1 = false;
  if (gather1 == nil) then 
    gather1 = true;
  end;
  local ret1 = b:map(__haxe_ds_Either.Right);
  do return __tink_core__Future_Future_Impl_.first(tmp, (function() 
    local _hx_2
    if (gather1) then 
    _hx_2 = ret1:gather(); else 
    _hx_2 = ret1; end
    return _hx_2
  end )()) end;
end
__tink_core__Future_Future_Impl_["and"] = function(a,b) 
  do return __tink_core__Future_Future_Impl_.merge(a, b, function(a1,b1) 
    local this1 = __tink_core_MPair.new(a1, b1);
    do return this1 end;
  end) end;
end
__tink_core__Future_Future_Impl_._tryFailingFlatMap = function(f,map) 
  local ret = f:flatMap(function(o) 
    local ret1 = o[1];
    if (ret1) == 0 then 
      local d = o[2];
      do return map(d) end;
    elseif (ret1) == 1 then 
      local f1 = o[2];
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Failure(f1))) end; end;
  end);
  do return ret:gather() end;
end
__tink_core__Future_Future_Impl_._tryFlatMap = function(f,map) 
  local ret = f:flatMap(function(o) 
    local ret1 = o[1];
    if (ret1) == 0 then 
      local d = o[2];
      local ret2 = map(d):map(__tink_core_Outcome.Success);
      do return ret2:gather() end;
    elseif (ret1) == 1 then 
      local f1 = o[2];
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Failure(f1))) end; end;
  end);
  do return ret:gather() end;
end
__tink_core__Future_Future_Impl_._tryFailingMap = function(f,map) 
  local ret = f:map(function(o) 
    do return __tink_core_OutcomeTools.flatMap(o, __tink_core__Outcome_OutcomeMapper_Impl_.withSameError(map)) end;
  end);
  do return ret:gather() end;
end
__tink_core__Future_Future_Impl_._tryMap = function(f,map) 
  local ret = f:map(function(o) 
    do return __tink_core_OutcomeTools.map(o, map) end;
  end);
  do return ret:gather() end;
end
__tink_core__Future_Future_Impl_._flatMap = function(f,map) 
  local ret = f:flatMap(map);
  do return ret:gather() end;
end
__tink_core__Future_Future_Impl_._map = function(f,map) 
  local ret = f:map(map);
  do return ret:gather() end;
end
__tink_core__Future_Future_Impl_.trigger = function() 
  do return __tink_core_FutureTrigger.new() end;
end
__tink_core__Future_Future_Impl_.delay = function(ms,value) 
  do return __tink_core__Future_Future_Impl_.async(function(cb) 
    __haxe_Timer.delay(function() 
      cb(value:get());
    end, ms);
  end) end;
end

__tink_core_FutureTrigger.new = function() 
  local self = _hx_new(__tink_core_FutureTrigger.prototype)
  __tink_core_FutureTrigger.super(self)
  return self
end
__tink_core_FutureTrigger.super = function(self) 
  self.list = __tink_core_CallbackList.new();
end
__tink_core_FutureTrigger.__name__ = "tink.core.FutureTrigger"
__tink_core_FutureTrigger.__interfaces__ = {__tink_core__Future_FutureObject}
__tink_core_FutureTrigger.gatherFuture = function(f) 
  do return __tink_core__Future_SuspendableFuture.new(function(yield) 
    do return f:handle(yield) end;
  end) end;
end
__tink_core_FutureTrigger.prototype = _hx_a();
__tink_core_FutureTrigger.prototype.handle = function(self,callback) 
  local _g = self.list;
  if (_g == nil) then 
    __tink_core__Callback_Callback_Impl_.invoke(callback, self.result);
    do return nil end;
  else
    local v = _g;
    local node = __tink_core__Callback_ListCell.new(callback, v);
    v.cells:push(node);
    v.used = v.used + 1;
    do return node end;
  end;
end
__tink_core_FutureTrigger.prototype.map = function(self,f) 
  local _g = self.list;
  if (_g == nil) then 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(f(self.result))) end;
  else
    local v = _g;
    local ret = __tink_core_FutureTrigger.new();
    local _this = self.list;
    local node = __tink_core__Callback_ListCell.new(function(v1) 
      local node1 = f(v1);
      ret:trigger(node1);
    end, _this);
    _this.cells:push(node);
    _this.used = _this.used + 1;
    do return ret end;
  end;
end
__tink_core_FutureTrigger.prototype.flatMap = function(self,f) 
  local _g = self.list;
  if (_g == nil) then 
    do return f(self.result) end;
  else
    local v = _g;
    local ret = __tink_core_FutureTrigger.new();
    local _this = self.list;
    local node = __tink_core__Callback_ListCell.new(function(v1) 
      f(v1):handle(_hx_bind(ret,ret.trigger));
    end, _this);
    _this.cells:push(node);
    _this.used = _this.used + 1;
    do return ret end;
  end;
end
__tink_core_FutureTrigger.prototype.gather = function(self) 
  do return self end
end
__tink_core_FutureTrigger.prototype.eager = function(self) 
  do return self end
end
__tink_core_FutureTrigger.prototype.asFuture = function(self) 
  do return self end
end
__tink_core_FutureTrigger.prototype.trigger = function(self,result) 
  if (self.list == nil) then 
    do return false end;
  else
    local list = self.list;
    self.list = nil;
    self.result = result;
    list:invoke(result, true);
    do return true end;
  end;
end

__tink_core_FutureTrigger.prototype.__class__ =  __tink_core_FutureTrigger

__tink_core__Future_SuspendableFuture.new = function(wakeup) 
  local self = _hx_new(__tink_core__Future_SuspendableFuture.prototype)
  __tink_core__Future_SuspendableFuture.super(self,wakeup)
  return self
end
__tink_core__Future_SuspendableFuture.super = function(self,wakeup) 
  self.suspended = true;
  local _gthis = self;
  self.wakeup = _hx_funcToField(wakeup);
  self.callbacks = __tink_core_CallbackList.new();
  self.callbacks.ondrain = function(self) 
    if (_gthis.callbacks ~= nil) then 
      _gthis.suspended = true;
      local this1 = _gthis.link;
      if (this1 ~= nil) then 
        this1:cancel();
      end;
      _gthis.link = nil;
    end;
   end;
end
__tink_core__Future_SuspendableFuture.__name__ = "tink.core._Future.SuspendableFuture"
__tink_core__Future_SuspendableFuture.__interfaces__ = {__tink_core__Future_FutureObject}
__tink_core__Future_SuspendableFuture.prototype = _hx_a();
__tink_core__Future_SuspendableFuture.prototype.trigger = function(self,value) 
  local _g = self.callbacks;
  if (_g ~= nil) then 
    local list = _g;
    self.callbacks = nil;
    self.suspended = false;
    self.result = value;
    self.link = nil;
    self.wakeup = nil;
    list:invoke(value, true);
  end;
end
__tink_core__Future_SuspendableFuture.prototype.handle = function(self,callback) 
  local _g = self.callbacks;
  if (_g == nil) then 
    __tink_core__Callback_Callback_Impl_.invoke(callback, self.result);
    do return nil end;
  else
    local v = _g;
    local _this = self.callbacks;
    local node = __tink_core__Callback_ListCell.new(callback, _this);
    _this.cells:push(node);
    _this.used = _this.used + 1;
    local ret = node;
    if (self.suspended) then 
      self.suspended = false;
      self.link = self:wakeup(_hx_bind(self,self.trigger));
    end;
    do return ret end;
  end;
end
__tink_core__Future_SuspendableFuture.prototype.map = function(self,f) 
  local _gthis = self;
  do return __tink_core__Future_SuspendableFuture.new(function(yield) 
    do return _gthis:handle(function(res) 
      local tmp = f(res);
      yield(tmp);
    end) end;
  end) end
end
__tink_core__Future_SuspendableFuture.prototype.flatMap = function(self,f) 
  do return __tink_core__Future_Future_Impl_.flatten(self:map(f)) end
end
__tink_core__Future_SuspendableFuture.prototype.gather = function(self) 
  do return self end
end
__tink_core__Future_SuspendableFuture.prototype.eager = function(self) 
  self:handle(__tink_core__Callback_Callback_Impl_.fromNiladic(function() 
  end));
  do return self end
end

__tink_core__Future_SuspendableFuture.prototype.__class__ =  __tink_core__Future_SuspendableFuture

__tink_core__Lazy_Lazy_Impl_.new = {}
__tink_core__Lazy_Lazy_Impl_.__name__ = "tink.core._Lazy.Lazy_Impl_"
__tink_core__Lazy_Lazy_Impl_.get = function(this1) 
  do return this1:get() end;
end
__tink_core__Lazy_Lazy_Impl_.ofFunc = function(f) 
  do return __tink_core__Lazy_LazyFunc.new(f) end;
end
__tink_core__Lazy_Lazy_Impl_.map = function(this1,f) 
  do return this1:map(f) end;
end
__tink_core__Lazy_Lazy_Impl_.flatMap = function(this1,f) 
  do return this1:flatMap(f) end;
end
__tink_core__Lazy_Lazy_Impl_.ofConst = function(c) 
  do return __tink_core__Lazy_LazyConst.new(c) end;
end

__tink_core__Lazy_LazyFunc.new = function(f) 
  local self = _hx_new(__tink_core__Lazy_LazyFunc.prototype)
  __tink_core__Lazy_LazyFunc.super(self,f)
  return self
end
__tink_core__Lazy_LazyFunc.super = function(self,f) 
  self.f = _hx_funcToField(f);
end
__tink_core__Lazy_LazyFunc.__name__ = "tink.core._Lazy.LazyFunc"
__tink_core__Lazy_LazyFunc.__interfaces__ = {__tink_core__Lazy_LazyObject}
__tink_core__Lazy_LazyFunc.prototype = _hx_a();
__tink_core__Lazy_LazyFunc.prototype.get = function(self) 
  if (self.f ~= nil) then 
    self.result = self:f();
    self.f = nil;
  end;
  do return self.result end
end
__tink_core__Lazy_LazyFunc.prototype.map = function(self,f) 
  local _gthis = self;
  do return __tink_core__Lazy_LazyFunc.new(function() 
    local tmp = _gthis:get();
    do return f(tmp) end;
  end) end
end
__tink_core__Lazy_LazyFunc.prototype.flatMap = function(self,f) 
  local _gthis = self;
  do return __tink_core__Lazy_LazyFunc.new(function() 
    local this1 = _gthis:get();
    do return f(this1):get() end;
  end) end
end

__tink_core__Lazy_LazyFunc.prototype.__class__ =  __tink_core__Lazy_LazyFunc

__tink_core_NamedWith.new = function(name,value) 
  local self = _hx_new(__tink_core_NamedWith.prototype)
  __tink_core_NamedWith.super(self,name,value)
  return self
end
__tink_core_NamedWith.super = function(self,name,value) 
  self.name = name;
  self.value = value;
end
__tink_core_NamedWith.__name__ = "tink.core.NamedWith"
__tink_core_NamedWith.prototype = _hx_a();

__tink_core_NamedWith.prototype.__class__ =  __tink_core_NamedWith

__tink_core_OptionTools.new = {}
__tink_core_OptionTools.__name__ = "tink.core.OptionTools"
__tink_core_OptionTools.force = function(o,pos) 
  if (o[1] == 0) then 
    local v = o[2];
    do return v end;
  else
    _G.error(__tink_core_TypedError.new(404, "Some value expected but none found", pos),0);
  end;
end
__tink_core_OptionTools["or"] = function(o,l) 
  if (o[1] == 0) then 
    local v = o[2];
    do return v end;
  else
    do return l:get() end;
  end;
end
__tink_core_OptionTools.orNull = function(o) 
  if (o[1] == 0) then 
    local v = o[2];
    do return v end;
  else
    do return nil end;
  end;
end
__tink_core_OptionTools.filter = function(o,f) 
  if (o[1] == 0) then 
    if (f(o[2]) == false) then 
      do return __haxe_ds_Option.None end;
    else
      do return o end;
    end;
  else
    do return o end;
  end;
end
__tink_core_OptionTools.satisfies = function(o,f) 
  if (o[1] == 0) then 
    local v = o[2];
    do return f(v) end;
  else
    do return false end;
  end;
end
__tink_core_OptionTools.equals = function(o,v) 
  if (o[1] == 0) then 
    local v1 = o[2];
    do return v1 == v end;
  else
    do return false end;
  end;
end
__tink_core_OptionTools.map = function(o,f) 
  if (o[1] == 0) then 
    local v = o[2];
    do return __haxe_ds_Option.Some(f(v)) end;
  else
    do return __haxe_ds_Option.None end;
  end;
end
__tink_core_OptionTools.flatMap = function(o,f) 
  if (o[1] == 0) then 
    local v = o[2];
    do return f(v) end;
  else
    do return __haxe_ds_Option.None end;
  end;
end
__tink_core_OptionTools.iterator = function(o) 
  do return __tink_core_OptionIter.new(o) end;
end
__tink_core_OptionTools.toArray = function(o) 
  if (o[1] == 0) then 
    local v = o[2];
    do return _hx_tab_array({[0]=v}, 1) end;
  else
    do return _hx_tab_array({}, 0) end;
  end;
end

__tink_core_OptionIter.new = function(o) 
  local self = _hx_new(__tink_core_OptionIter.prototype)
  __tink_core_OptionIter.super(self,o)
  return self
end
__tink_core_OptionIter.super = function(self,o) 
  self.alive = true;
  if (o[1] == 0) then 
    local v = o[2];
    self.value = v;
  else
    self.alive = false;
  end;
end
__tink_core_OptionIter.__name__ = "tink.core.OptionIter"
__tink_core_OptionIter.prototype = _hx_a();
__tink_core_OptionIter.prototype.hasNext = function(self) 
  do return self.alive end
end
__tink_core_OptionIter.prototype.next = function(self) 
  self.alive = false;
  do return self.value end
end

__tink_core_OptionIter.prototype.__class__ =  __tink_core_OptionIter
_hxClasses["tink.core.Outcome"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Success","Failure"},2)}
__tink_core_Outcome = _hxClasses["tink.core.Outcome"];
__tink_core_Outcome.Success = function(data) local _x = _hx_tab_array({[0]="Success",0,data,__enum__=__tink_core_Outcome}, 3); return _x; end 
__tink_core_Outcome.Failure = function(failure) local _x = _hx_tab_array({[0]="Failure",1,failure,__enum__=__tink_core_Outcome}, 3); return _x; end 

__tink_core_OutcomeTools.new = {}
__tink_core_OutcomeTools.__name__ = "tink.core.OutcomeTools"
__tink_core_OutcomeTools.sure = function(outcome) 
  local tmp = outcome[1];
  if (tmp) == 0 then 
    local data = outcome[2];
    do return data end;
  elseif (tmp) == 1 then 
    local failure = outcome[2];
    local _g = __tink_core_TypedError.asError(failure);
    if (_g == nil) then 
      _G.error(failure,0);
    else
      local e = _g;
      do return e:throwSelf() end;
    end; end;
end
__tink_core_OutcomeTools.toOption = function(outcome) 
  local tmp = outcome[1];
  if (tmp) == 0 then 
    local data = outcome[2];
    do return __haxe_ds_Option.Some(data) end;
  elseif (tmp) == 1 then 
    local _g = outcome[2];
    do return __haxe_ds_Option.None end; end;
end
__tink_core_OutcomeTools.toOutcome = function(option,pos) 
  local tmp = option[1];
  if (tmp) == 0 then 
    local value = option[2];
    do return __tink_core_Outcome.Success(value) end;
  elseif (tmp) == 1 then 
    do return __tink_core_Outcome.Failure(__tink_core_TypedError.new(404, Std.string(Std.string(Std.string("Some value expected but none found in ") .. Std.string(pos.fileName)) .. Std.string("@line ")) .. Std.string(pos.lineNumber), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="tink/core/Outcome.hx",lineNumber=48,className="tink.core.OutcomeTools",methodName="toOutcome"}))) end; end;
end
__tink_core_OutcomeTools.orNull = function(outcome) 
  local tmp = outcome[1];
  if (tmp) == 0 then 
    local data = outcome[2];
    do return data end;
  elseif (tmp) == 1 then 
    local _g = outcome[2];
    do return nil end; end;
end
__tink_core_OutcomeTools.orUse = function(outcome,fallback) 
  local tmp = outcome[1];
  if (tmp) == 0 then 
    local data = outcome[2];
    do return data end;
  elseif (tmp) == 1 then 
    local _g = outcome[2];
    do return fallback:get() end; end;
end
__tink_core_OutcomeTools.orTry = function(outcome,fallback) 
  local tmp = outcome[1];
  if (tmp) == 0 then 
    local _g1 = outcome[2];
    do return outcome end;
  elseif (tmp) == 1 then 
    local _g = outcome[2];
    do return fallback:get() end; end;
end
__tink_core_OutcomeTools.equals = function(outcome,to) 
  local tmp = outcome[1];
  if (tmp) == 0 then 
    local data = outcome[2];
    do return data == to end;
  elseif (tmp) == 1 then 
    local _g = outcome[2];
    do return false end; end;
end
__tink_core_OutcomeTools.map = function(outcome,transform) 
  local tmp = outcome[1];
  if (tmp) == 0 then 
    local a = outcome[2];
    do return __tink_core_Outcome.Success(transform(a)) end;
  elseif (tmp) == 1 then 
    local f = outcome[2];
    do return __tink_core_Outcome.Failure(f) end; end;
end
__tink_core_OutcomeTools.isSuccess = function(outcome) 
  if (outcome[1] == 0) then 
    local _g = outcome[2];
    do return true end;
  else
    do return false end;
  end;
end
__tink_core_OutcomeTools.flatMap = function(o,mapper) 
  do return __tink_core__Outcome_OutcomeMapper_Impl_.apply(mapper, o) end;
end
__tink_core_OutcomeTools.swap = function(outcome,v) 
  local tmp = outcome[1];
  if (tmp) == 0 then 
    local a = outcome[2];
    do return __tink_core_Outcome.Success(v) end;
  elseif (tmp) == 1 then 
    local f = outcome[2];
    do return __tink_core_Outcome.Failure(f) end; end;
end
__tink_core_OutcomeTools.next = function(outcome,f) 
  local tmp = outcome[1];
  if (tmp) == 0 then 
    local v = outcome[2];
    do return f(v) end;
  elseif (tmp) == 1 then 
    local e = outcome[2];
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Failure(e))) end; end;
end
__tink_core_OutcomeTools.attempt = function(f,report) 
  local _hx_status, _hx_result = pcall(function() 
  
      do return __tink_core_Outcome.Success(f()) end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
  
    local _hx_1 = _hx_result
    local e = _hx_1
    do return __tink_core_Outcome.Failure(report(e)) end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
end
__tink_core_OutcomeTools.flatten = function(o) 
  local tmp = o[1];
  if (tmp) == 0 then 
    local _g1 = o[2];
    local tmp1 = _g1[1];
    if (tmp1) == 0 then 
      local d = _g1[2];
      do return __tink_core_Outcome.Success(d) end;
    elseif (tmp1) == 1 then 
      local f = _g1[2];
      do return __tink_core_Outcome.Failure(f) end; end;
  elseif (tmp) == 1 then 
    local f1 = o[2];
    do return __tink_core_Outcome.Failure(f1) end; end;
end

__tink_core__Outcome_OutcomeMapper_Impl_.new = {}
__tink_core__Outcome_OutcomeMapper_Impl_.__name__ = "tink.core._Outcome.OutcomeMapper_Impl_"
__tink_core__Outcome_OutcomeMapper_Impl_._new = function(f) 
  local this1 = _hx_o({__fields__={f=true},f=function(_,...) return f(...) end});
  do return this1 end;
end
__tink_core__Outcome_OutcomeMapper_Impl_.apply = function(this1,o) 
  do return this1:f(o) end;
end
__tink_core__Outcome_OutcomeMapper_Impl_.withSameError = function(f) 
  do return __tink_core__Outcome_OutcomeMapper_Impl_._new(function(o) 
    local tmp = o[1];
    if (tmp) == 0 then 
      local d = o[2];
      do return f(d) end;
    elseif (tmp) == 1 then 
      local f1 = o[2];
      do return __tink_core_Outcome.Failure(f1) end; end;
  end) end;
end
__tink_core__Outcome_OutcomeMapper_Impl_.withEitherError = function(f) 
  do return __tink_core__Outcome_OutcomeMapper_Impl_._new(function(o) 
    local tmp = o[1];
    if (tmp) == 0 then 
      local d = o[2];
      local _g = f(d);
      local tmp1 = _g[1];
      if (tmp1) == 0 then 
        local d1 = _g[2];
        do return __tink_core_Outcome.Success(d1) end;
      elseif (tmp1) == 1 then 
        local f1 = _g[2];
        do return __tink_core_Outcome.Failure(__haxe_ds_Either.Right(f1)) end; end;
    elseif (tmp) == 1 then 
      local f2 = o[2];
      do return __tink_core_Outcome.Failure(__haxe_ds_Either.Left(f2)) end; end;
  end) end;
end

__tink_core__Pair_Pair_Impl_.new = {}
__tink_core__Pair_Pair_Impl_.__name__ = "tink.core._Pair.Pair_Impl_"
__tink_core__Pair_Pair_Impl_._new = function(a,b) 
  local this1 = __tink_core_MPair.new(a, b);
  do return this1 end;
end
__tink_core__Pair_Pair_Impl_.get_a = function(this1) 
  do return this1.a end;
end
__tink_core__Pair_Pair_Impl_.get_b = function(this1) 
  do return this1.b end;
end
__tink_core__Pair_Pair_Impl_.toBool = function(this1) 
  do return this1 ~= nil end;
end
__tink_core__Pair_Pair_Impl_.isNil = function(this1) 
  do return this1 == nil end;
end
__tink_core__Pair_Pair_Impl_["nil"] = function() 
  do return nil end;
end

__tink_core_MPair.new = function(a,b) 
  local self = _hx_new(__tink_core_MPair.prototype)
  __tink_core_MPair.super(self,a,b)
  return self
end
__tink_core_MPair.super = function(self,a,b) 
  self.a = a;
  self.b = b;
end
__tink_core_MPair.__name__ = "tink.core.MPair"
__tink_core_MPair.prototype = _hx_a();

__tink_core_MPair.prototype.__class__ =  __tink_core_MPair

__tink_core__Promise_Promise_Impl_.new = {}
__tink_core__Promise_Promise_Impl_.__name__ = "tink.core._Promise.Promise_Impl_"
__tink_core__Promise_Promise_Impl_._new = function(f,lazy) 
  if (lazy == nil) then 
    lazy = false;
  end;
  local this1 = __tink_core__Future_Future_Impl_.async(function(cb) 
    f(function(v) 
      cb(__tink_core_Outcome.Success(v));
    end, function(e) 
      cb(__tink_core_Outcome.Failure(e));
    end);
  end, lazy);
  do return this1 end;
end
__tink_core__Promise_Promise_Impl_.eager = function(this1) 
  do return this1:eager() end;
end
__tink_core__Promise_Promise_Impl_.map = function(this1,f) 
  local ret = this1:map(f);
  do return ret:gather() end;
end
__tink_core__Promise_Promise_Impl_.flatMap = function(this1,f) 
  local ret = this1:flatMap(f);
  do return ret:gather() end;
end
__tink_core__Promise_Promise_Impl_.tryRecover = function(this1,f) 
  local ret = this1:flatMap(function(o) 
    local ret1 = o[1];
    if (ret1) == 0 then 
      local d = o[2];
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(o)) end;
    elseif (ret1) == 1 then 
      local e = o[2];
      do return f(e) end; end;
  end);
  do return ret:gather() end;
end
__tink_core__Promise_Promise_Impl_.recover = function(this1,f) 
  local ret = this1:flatMap(function(o) 
    local ret1 = o[1];
    if (ret1) == 0 then 
      local d = o[2];
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(d)) end;
    elseif (ret1) == 1 then 
      local e = o[2];
      do return f(e) end; end;
  end);
  do return ret:gather() end;
end
__tink_core__Promise_Promise_Impl_.mapError = function(this1,f) 
  local ret = this1:map(function(o) 
    local ret1 = o[1];
    if (ret1) == 0 then 
      local _g1 = o[2];
      do return o end;
    elseif (ret1) == 1 then 
      local e = o[2];
      do return __tink_core_Outcome.Failure(f(e)) end; end;
  end);
  do return ret:gather() end;
end
__tink_core__Promise_Promise_Impl_.handle = function(this1,cb) 
  do return this1:handle(cb) end;
end
__tink_core__Promise_Promise_Impl_.noise = function(this1) 
  do return __tink_core__Promise_Promise_Impl_.next(this1, function(v) 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(__tink_core_Noise.Noise))) end;
  end) end;
end
__tink_core__Promise_Promise_Impl_.isSuccess = function(this1) 
  local ret = this1:map(function(o) 
    do return __tink_core_OutcomeTools.isSuccess(o) end;
  end);
  do return ret:gather() end;
end
__tink_core__Promise_Promise_Impl_.next = function(this1,f,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local gather1 = gather;
  if (gather1 == nil) then 
    gather1 = true;
  end;
  local ret = this1:flatMap(function(o) 
    local ret1 = o[1];
    if (ret1) == 0 then 
      local d = o[2];
      do return f(d) end;
    elseif (ret1) == 1 then 
      local f1 = o[2];
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Failure(f1))) end; end;
  end);
  if (gather1) then 
    do return ret:gather() end;
  else
    do return ret end;
  end;
end
__tink_core__Promise_Promise_Impl_.swap = function(this1,v) 
  do return __tink_core__Future_Future_Impl_._tryMap(this1, function(_) 
    do return v end;
  end) end;
end
__tink_core__Promise_Promise_Impl_.swapError = function(this1,e) 
  do return __tink_core__Promise_Promise_Impl_.mapError(this1, function(_) 
    do return e end;
  end) end;
end
__tink_core__Promise_Promise_Impl_.merge = function(this1,other,merger,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  do return __tink_core__Promise_Promise_Impl_.next(this1, function(t) 
    do return __tink_core__Promise_Promise_Impl_.next(other, function(a) 
      do return merger(t, a) end;
    end, false) end;
  end, gather) end;
end
__tink_core__Promise_Promise_Impl_["and"] = function(a,b) 
  do return __tink_core__Promise_Promise_Impl_.merge(a, b, function(a1,b1) 
    local this1 = __tink_core_MPair.new(a1, b1);
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(this1))) end;
  end) end;
end
__tink_core__Promise_Promise_Impl_.iterate = function(promises,yield,fallback,lazy) 
  do return __tink_core__Future_Future_Impl_.async(function(cb) 
    local iter = promises:iterator();
    local next = nil;
    next = function() 
      if (iter:hasNext()) then 
        iter:next():handle(function(o) 
          local next1 = o[1];
          if (next1) == 0 then 
            local v = o[2];
            yield(v):handle(function(o1) 
              local next2 = o1[1];
              if (next2) == 0 then 
                local _g1 = o1[2];
                local next3 = _g1[1];
                if (next3) == 0 then 
                  local ret = _g1[2];
                  cb(__tink_core_Outcome.Success(ret));
                elseif (next3) == 1 then 
                  next(); end;
              elseif (next2) == 1 then 
                local e = o1[2];
                cb(__tink_core_Outcome.Failure(e)); end;
            end);
          elseif (next1) == 1 then 
            local e1 = o[2];
            cb(__tink_core_Outcome.Failure(e1)); end;
        end);
      else
        fallback:handle(cb);
      end;
    end;
    next();
  end, lazy) end;
end
__tink_core__Promise_Promise_Impl_.retry = function(gen,next) 
  local stamp = function() 
    do return Sys.time() * 1000 end;
  end;
  local start = stamp();
  local attempt = nil;
  attempt = function(count) 
    local f = function(error) 
      local f1 = stamp() - start;
      do return __tink_core__Promise_Promise_Impl_.next(next(_hx_o({__fields__={attempt=true,error=true,elapsed=true},attempt=count,error=error,elapsed=f1})), function(_) 
        do return attempt(count + 1) end;
      end) end;
    end;
    local ret = gen():flatMap(function(o) 
      local ret1 = o[1];
      if (ret1) == 0 then 
        local d = o[2];
        do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(o)) end;
      elseif (ret1) == 1 then 
        local e = o[2];
        do return f(e) end; end;
    end);
    do return ret:gather() end;
  end;
  do return attempt(1) end;
end
__tink_core__Promise_Promise_Impl_.ofSpecific = function(s) 
  do return s end;
end
__tink_core__Promise_Promise_Impl_.ofFuture = function(f) 
  local ret = f:map(__tink_core_Outcome.Success);
  do return ret:gather() end;
end
__tink_core__Promise_Promise_Impl_.ofOutcome = function(o) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(o)) end;
end
__tink_core__Promise_Promise_Impl_.ofError = function(e) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Failure(e))) end;
end
__tink_core__Promise_Promise_Impl_.ofData = function(d) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(d))) end;
end
__tink_core__Promise_Promise_Impl_.lazy = function(p) 
  do return __tink_core__Future_Future_Impl_.async(function(cb) 
    p:get():handle(cb);
  end, true) end;
end
__tink_core__Promise_Promise_Impl_.inParallel = function(a,concurrency,lazy) 
  if (a.length == 0) then 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(_hx_tab_array({}, 0)))) end;
  else
    do return __tink_core__Future_Future_Impl_.async(function(cb) 
      local result = _hx_tab_array({}, 0);
      local pending = a.length;
      local links = nil;
      local linkArray = _hx_tab_array({}, 0);
      local sync = false;
      local i = 0;
      local iter_next;
      local iter_hasNext;
      local _gthis = a;
      local cur_length = 0;
      iter_hasNext = function() 
        do return cur_length < _gthis.length end;
      end;
      iter_next = function() 
        cur_length = cur_length + 1;
        do return _gthis[cur_length - 1] end;
      end;
      local next = nil;
      local done = function(o) 
        if (links == nil) then 
          sync = true;
        else
          if (links ~= nil) then 
            links:cancel();
          end;
        end;
        cb(o);
      end;
      local fail = function(e) 
        pending = 0;
        done(__tink_core_Outcome.Failure(e));
      end;
      local set = function(index,value) 
        result[index] = value;
        pending = pending - 1;
        if (pending == 0) then 
          done(__tink_core_Outcome.Success(result));
        else
          if (iter_hasNext() and (pending > 0)) then 
            next();
          end;
        end;
      end;
      next = function() 
        i = i + 1;
        local index1 = i - 1;
        local next1 = iter_next():handle(function(o1) 
          local next2 = o1[1];
          if (next2) == 0 then 
            local v = o1[2];
            set(index1, v);
          elseif (next2) == 1 then 
            local e1 = o1[2];
            fail(e1); end;
        end);
        linkArray:push(next1);
      end;
      while (true) do 
        local tmp;
        if (iter_hasNext() and (pending > 0)) then 
          if (concurrency ~= nil) then 
            concurrency = concurrency - 1;
            tmp = (concurrency + 1) > 0;
          else
            tmp = true;
          end;
        else
          tmp = false;
        end;
        if (not tmp) then 
          break;
        end;
        next();
      end;
      links = __tink_core__Callback_CallbackLink_Impl_.fromMany(linkArray);
      if (sync) then 
        if (links ~= nil) then 
          links:cancel();
        end;
      end;
    end, lazy) end;
  end;
end
__tink_core__Promise_Promise_Impl_.inSequence = function(a) 
  local loop = nil;
  loop = function(index) 
    if (index == a.length) then 
      do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(_hx_tab_array({}, 0)))) end;
    else
      do return __tink_core__Promise_Promise_Impl_.next(a[index], function(head) 
        do return __tink_core__Promise_Promise_Impl_.next(loop(index + 1), function(tail) 
          do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(_hx_tab_array({[0]=head}, 1):concat(tail)))) end;
        end) end;
      end) end;
    end;
  end;
  do return loop(0) end;
end
__tink_core__Promise_Promise_Impl_.cache = function(gen) 
  local p = nil;
  do return function() 
    local ret = p;
    if (ret == nil) then 
      local sync = false;
      ret = __tink_core__Promise_Promise_Impl_.next(gen(), function(o) 
        o.b:handle(function(_) 
          sync = true;
          p = nil;
        end);
        do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(o.a))) end;
      end);
      if (not sync) then 
        p = ret;
      end;
    end;
    local ret1 = ret:map(function(o1) 
      if (not __tink_core_OutcomeTools.isSuccess(o1)) then 
        p = nil;
      end;
      do return o1 end;
    end);
    do return ret1:gather() end;
  end end;
end
__tink_core__Promise_Promise_Impl_.lift = function(p) 
  do return p end;
end
__tink_core__Promise_Promise_Impl_.trigger = function() 
  local this1 = __tink_core_FutureTrigger.new();
  do return this1 end;
end
__tink_core__Promise_Promise_Impl_.resolve = function(v) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(v))) end;
end
__tink_core__Promise_Promise_Impl_.reject = function(e) 
  do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Failure(e))) end;
end

__tink_core__Promise_Next_Impl_.new = {}
__tink_core__Promise_Next_Impl_.__name__ = "tink.core._Promise.Next_Impl_"
__tink_core__Promise_Next_Impl_.ofDynamic = function(f) 
  do return function(x) 
    local d = f(x);
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(d))) end;
  end end;
end
__tink_core__Promise_Next_Impl_.ofSafe = function(f) 
  do return function(x) 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(f(x))) end;
  end end;
end
__tink_core__Promise_Next_Impl_.ofSync = function(f) 
  do return function(x) 
    local ret = f(x):map(__tink_core_Outcome.Success);
    do return ret:gather() end;
  end end;
end
__tink_core__Promise_Next_Impl_.ofSafeSync = function(f) 
  do return function(x) 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(f(x)))) end;
  end end;
end
__tink_core__Promise_Next_Impl_._chain = function(a,b) 
  do return function(v) 
    do return __tink_core__Promise_Promise_Impl_.next(a(v), b) end;
  end end;
end

__tink_core__Promise_Recover_Impl_.new = {}
__tink_core__Promise_Recover_Impl_.__name__ = "tink.core._Promise.Recover_Impl_"
__tink_core__Promise_Recover_Impl_.ofSync = function(f) 
  do return function(e) 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(f(e))) end;
  end end;
end

__tink_core__Promise_Combiner_Impl_.new = {}
__tink_core__Promise_Combiner_Impl_.__name__ = "tink.core._Promise.Combiner_Impl_"
__tink_core__Promise_Combiner_Impl_.ofSafe = function(f) 
  do return function(x1,x2) 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(f(x1, x2))) end;
  end end;
end
__tink_core__Promise_Combiner_Impl_.ofSync = function(f) 
  do return function(x1,x2) 
    local ret = f(x1, x2):map(__tink_core_Outcome.Success);
    do return ret:gather() end;
  end end;
end
__tink_core__Promise_Combiner_Impl_.ofSafeSync = function(f) 
  do return function(x1,x2) 
    do return __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(f(x1, x2)))) end;
  end end;
end

__tink_core__Promise_PromiseTrigger_Impl_.new = {}
__tink_core__Promise_PromiseTrigger_Impl_.__name__ = "tink.core._Promise.PromiseTrigger_Impl_"
__tink_core__Promise_PromiseTrigger_Impl_._new = function() 
  local this1 = __tink_core_FutureTrigger.new();
  do return this1 end;
end
__tink_core__Promise_PromiseTrigger_Impl_.resolve = function(this1,v) 
  do return this1:trigger(__tink_core_Outcome.Success(v)) end;
end
__tink_core__Promise_PromiseTrigger_Impl_.reject = function(this1,e) 
  do return this1:trigger(__tink_core_Outcome.Failure(e)) end;
end
__tink_core__Promise_PromiseTrigger_Impl_.asPromise = function(this1) 
  do return this1 end;
end

__tink_core__Ref_Ref_Impl_.new = {}
__tink_core__Ref_Ref_Impl_.__name__ = "tink.core._Ref.Ref_Impl_"
__tink_core__Ref_Ref_Impl_._new = function() 
  local this1 = ({length = 1});
  local this2 = this1;
  do return this2 end;
end
__tink_core__Ref_Ref_Impl_.get_value = function(this1) 
  do return this1[0] end;
end
__tink_core__Ref_Ref_Impl_.set_value = function(this1,param) 
  do return (function() 
  this1[0] = param; return this1[0] end)() end;
end
__tink_core__Ref_Ref_Impl_.toString = function(this1) 
  do return Std.string(Std.string("@[") .. Std.string(Std.string(this1[0]))) .. Std.string("]") end;
end
__tink_core__Ref_Ref_Impl_.to = function(v) 
  local this1 = ({length = 1});
  local this2 = this1;
  local ret = this2;
  ret[0] = v;
  do return ret end;
end

__tink_core__Signal_Signal_Impl_.new = {}
__tink_core__Signal_Signal_Impl_.__name__ = "tink.core._Signal.Signal_Impl_"
__tink_core__Signal_Signal_Impl_._new = function(f) 
  local this1 = __tink_core__Signal_SimpleSignal.new(f);
  do return this1 end;
end
__tink_core__Signal_Signal_Impl_.map = function(this1,f,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this2 = __tink_core__Signal_SimpleSignal.new(function(cb) 
    do return this1:handle(function(result) 
      local this3 = f(result);
      __tink_core__Callback_Callback_Impl_.invoke(cb, this3);
    end) end;
  end);
  local ret = this2;
  if (gather) then 
    do return __tink_core__Signal_Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end
__tink_core__Signal_Signal_Impl_.flatMap = function(this1,f,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this2 = __tink_core__Signal_SimpleSignal.new(function(cb) 
    do return this1:handle(function(result) 
      f(result):handle(cb);
    end) end;
  end);
  local ret = this2;
  if (gather) then 
    do return __tink_core__Signal_Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end
__tink_core__Signal_Signal_Impl_.filter = function(this1,f,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this2 = __tink_core__Signal_SimpleSignal.new(function(cb) 
    do return this1:handle(function(result) 
      if (f(result)) then 
        __tink_core__Callback_Callback_Impl_.invoke(cb, result);
      end;
    end) end;
  end);
  local ret = this2;
  if (gather) then 
    do return __tink_core__Signal_Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end
__tink_core__Signal_Signal_Impl_.select = function(this1,selector,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this2 = __tink_core__Signal_SimpleSignal.new(function(cb) 
    do return this1:handle(function(result) 
      local _g = selector(result);
      local this3 = _g[1];
      if (this3) == 0 then 
        local v = _g[2];
        __tink_core__Callback_Callback_Impl_.invoke(cb, v);
      elseif (this3) == 1 then  end;
    end) end;
  end);
  local ret = this2;
  if (gather) then 
    do return __tink_core__Signal_Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end
__tink_core__Signal_Signal_Impl_.join = function(this1,other,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this2 = __tink_core__Signal_SimpleSignal.new(function(cb) 
    do return __tink_core__Callback_LinkPair.new(this1:handle(cb), other:handle(cb)) end;
  end);
  local ret = this2;
  if (gather) then 
    do return __tink_core__Signal_Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end
__tink_core__Signal_Signal_Impl_.nextTime = function(this1,condition) 
  local ret = __tink_core_FutureTrigger.new();
  local link = nil;
  local immediate = false;
  link = this1:handle(function(v) 
    if ((condition == nil) or condition(v)) then 
      ret:trigger(v);
      if (link == nil) then 
        immediate = true;
      else
        if (link ~= nil) then 
          link:cancel();
        end;
      end;
    end;
  end);
  if (immediate) then 
    if (link ~= nil) then 
      link:cancel();
    end;
  end;
  do return ret end;
end
__tink_core__Signal_Signal_Impl_["until"] = function(this1,_end) 
  local ret = __tink_core__Signal_Suspendable.new(function(yield) 
    local this2 = this1:handle(yield);
    if (this2 == nil) then 
      do return __tink_core__Callback_CallbackLink_Impl_.noop end;
    else
      do return _hx_bind(this2,(function() local __=this2; return _hx_bind(__,__.cancel) end)()) end;
    end;
  end);
  _end:handle(__tink_core__Callback_Callback_Impl_.fromNiladic(_hx_bind(ret,ret.kill)));
  do return ret end;
end
__tink_core__Signal_Signal_Impl_.next = function(this1,condition) 
  do return __tink_core__Signal_Signal_Impl_.nextTime(this1, condition) end;
end
__tink_core__Signal_Signal_Impl_.noise = function(this1) 
  do return __tink_core__Signal_Signal_Impl_.map(this1, function(_) 
    do return __tink_core_Noise.Noise end;
  end) end;
end
__tink_core__Signal_Signal_Impl_.gather = function(this1) 
  local ret = __tink_core__Signal_Signal_Impl_.trigger();
  this1:handle(function(x) 
    ret.handlers:invoke(x);
  end);
  do return ret end;
end
__tink_core__Signal_Signal_Impl_.generate = function(generator) 
  local ret = __tink_core__Signal_Signal_Impl_.trigger();
  generator(_hx_bind(ret,ret.trigger));
  do return ret end;
end
__tink_core__Signal_Signal_Impl_.trigger = function() 
  do return __tink_core_SignalTrigger.new() end;
end
__tink_core__Signal_Signal_Impl_.create = function(create) 
  do return __tink_core__Signal_Suspendable.new(create) end;
end
__tink_core__Signal_Signal_Impl_.ofClassical = function(add,remove,gather) 
  if (gather == nil) then 
    gather = true;
  end;
  local this1 = __tink_core__Signal_SimpleSignal.new(function(cb) 
    local f = function(a) 
      __tink_core__Callback_Callback_Impl_.invoke(cb, a);
    end;
    add(f);
    local f1 = remove;
    local a1 = f;
    local this2 = __tink_core_SimpleLink.new(function() 
      f1(a1);
    end);
    do return this2 end;
  end);
  local ret = this1;
  if (gather) then 
    do return __tink_core__Signal_Signal_Impl_.gather(ret) end;
  else
    do return ret end;
  end;
end

__tink_core__Signal_SimpleSignal.new = function(f) 
  local self = _hx_new(__tink_core__Signal_SimpleSignal.prototype)
  __tink_core__Signal_SimpleSignal.super(self,f)
  return self
end
__tink_core__Signal_SimpleSignal.super = function(self,f) 
  self.f = _hx_funcToField(f);
end
__tink_core__Signal_SimpleSignal.__name__ = "tink.core._Signal.SimpleSignal"
__tink_core__Signal_SimpleSignal.__interfaces__ = {__tink_core_SignalObject}
__tink_core__Signal_SimpleSignal.prototype = _hx_a();
__tink_core__Signal_SimpleSignal.prototype.handle = function(self,cb) 
  do return self:f(cb) end
end

__tink_core__Signal_SimpleSignal.prototype.__class__ =  __tink_core__Signal_SimpleSignal

__tink_core__Signal_Suspendable.new = function(activate) 
  local self = _hx_new(__tink_core__Signal_Suspendable.prototype)
  __tink_core__Signal_Suspendable.super(self,activate)
  return self
end
__tink_core__Signal_Suspendable.super = function(self,activate) 
  self.killed = false;
  self.trigger = __tink_core_SignalTrigger.new();
  self.activate = _hx_funcToField(activate);
end
__tink_core__Signal_Suspendable.__name__ = "tink.core._Signal.Suspendable"
__tink_core__Signal_Suspendable.__interfaces__ = {__tink_core_SignalObject}
__tink_core__Signal_Suspendable.prototype = _hx_a();
__tink_core__Signal_Suspendable.prototype.kill = function(self) 
  if (not self.killed) then 
    self.killed = true;
    self.trigger = nil;
  end;
end
__tink_core__Signal_Suspendable.prototype.handle = function(self,cb) 
  local _gthis = self;
  if (self.killed) then 
    do return nil end;
  end;
  if (self.trigger.handlers.used == 0) then 
    self.suspend = self:activate(_hx_bind(self.trigger,self.trigger.trigger));
  end;
  local _this = self.trigger.handlers;
  local node = __tink_core__Callback_ListCell.new(cb, _this);
  _this.cells:push(node);
  _this.used = _this.used + 1;
  local this1 = __tink_core_SimpleLink.new(function() 
    if (_gthis.trigger.handlers.used == 0) then 
      _gthis:suspend();
      _gthis.suspend = nil;
    end;
  end);
  do return __tink_core__Callback_LinkPair.new(node, this1) end
end

__tink_core__Signal_Suspendable.prototype.__class__ =  __tink_core__Signal_Suspendable
_hx_bit_clamp = function(v)
  if v <= 2147483647 and v >= -2147483648 then
    if v > 0 then return _G.math.floor(v)
    else return _G.math.ceil(v)
    end
  end
  if v > 2251798999999999 then v = v*2 end;
  if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
  return _hx_bit.band(v, 2147483647 ) - math.abs(_hx_bit.band(v, 2147483648))
end

-- require this for lua 5.1
pcall(require, 'bit')
if bit then
  _hx_bit = bit
else
  local _hx_bit_raw = _G.require('bit32')
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  -- lua 5.2 weirdness
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end

_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  __deceptinfect_GameManager.state = __deceptinfect_GAME_STATE.WAIT;
  
  __deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.WAIT = 0;
  
  __deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.SETTING_UP = 1;
  
  __deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.PLAYING = 2;
  
  __deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.ENDING = 3;
  
  __deceptinfect_GameValues.MIN_PLAYERS = 3;
  
  __deceptinfect_GameValues.INF_INIT_MIN = 1.5;
  
  __deceptinfect_GameValues.INF_INIT_MAX = 7.5;
  
  __deceptinfect_GameValues.CONTAMINATE_WARNING_TIME = 4;
  
  __deceptinfect_GameValues.RADIATION_WARNING_TIME = 1.5;
  
  __deceptinfect_GameValues.MAX_INF_RATE = 12;
  
  __deceptinfect_GameValues.GAME_TIMER = 540;
  
  __deceptinfect_GameValues.GAME_TIMER_VARIANCE = 45;
  
  __deceptinfect_GameValues.EVAC_ARRIVAL = 25;
  
  __deceptinfect_GameValues.LOW_HEALTH_SLOW = 0.75;
  
  __deceptinfect_GameValues.LOW_HEALTH_RATE = 1.6;
  
  __deceptinfect_GameValues.LOW_HEALTH_SLOW_START = 0.4;
  
  __deceptinfect_GameValues.LOW_HEALTH_RATE_START = 0.25;
  
  __deceptinfect_GameValues.AVERAGE_RATE_SAMPLES = 15;
  
  __deceptinfect_GameValues.AVERAGE_RATE_TIME = 3;
  
  __deceptinfect_GameValues.MIN_BATTERY_TIME = 45;
  
  __deceptinfect_GameValues.MAX_BATTERY_TIME = 90;
  
  __deceptinfect_GameValues.MULTIPLE_SOURCES_MODE = 0;
  
  __deceptinfect_GameValues.MULTIPLE_SOURCES_DIMINISH_PERCENT = 0.75;
  
  __deceptinfect_GameValues.MAX_IDENT_DIST = 1000;
  
  __deceptinfect_GameValues.BATTERIES_SPAWNED = 2;
  
  __deceptinfect_GameValues.EVAC_INFECTION_RATE = 0.5;
  
  __deceptinfect_GameValues.BEGIN_EVAC_INF = 0.65;
  
  __deceptinfect_GameValues.BATTERIES_REQUIRED = 4;
  
  __deceptinfect_GameValues.GRAB_TIME = 6;
  
  __deceptinfect_Misc.roundModels = _hx_tab_array({[0]="models/player/mossman.mdl"}, 1);
  
  __deceptinfect_Misc.roundWeapons = _hx_tab_array({[0]="weapon_mor_ump"}, 1);
  
  __haxe_ds_IntMap.tnull = ({});
  
  __deceptinfect_PlayerManager.indexLookup = __haxe_ds_IntMap.new();
  
  __deceptinfect_client_PVS.pvs = __haxe_ds_IntMap.new();
  
  __deceptinfect_ecswip_ComponentManager.components = __haxe_ds_ObjectMap.new();
  
  __deceptinfect_ecswip_ComponentManager.entities = 0;
  
  __deceptinfect_ecswip_ComponentManager.activeEntities = 0;
  
  __deceptinfect_ecswip_ComponentManager.gEntityLookup = __haxe_ds_IntMap.new();
  
  __deceptinfect_ecswip_GrabSystem.grabindex = 0;
  
  __deceptinfect_ecswip_SignalStorage.entDamageTrigger = __tink_core_SignalTrigger.new();
  
  __deceptinfect_infection_InfectionSystem.infectedTrigger = __tink_core_SignalTrigger.new();
  
  __deceptinfect_infection_InfectionSystem.infectedSig = __deceptinfect_infection_InfectionSystem.infectedTrigger;
  
  __deceptinfect_infection_RateSystem.nextAddRate = 0;
  
  __deceptinfect_infection_RateSystem.nextMultiRate = 0;
  
  __deceptinfect_radiation_RadiationSystem.nextRadiationID = (function() 
    local _hx_1
    
    local this1 = 0;
    
    _hx_1 = this1;
    return _hx_1
  end )();
  
  __deceptinfect_radiation_RadiationSystem.radRateID = __deceptinfect_infection_RateSystem.getAddRateTicket();
  
  __deceptinfect_radiation_RadiationSystem._acceptFamily = __deceptinfect_ecswip_Family.new(_hx_tab_array({[0]=__deceptinfect_radiation_RadiationAccepter, __deceptinfect_infection_RateComponent, __deceptinfect_ecswip_GEntityComponent}, 3));
  
  __deceptinfect_radiation_RadiationSystem._produceFamily = __deceptinfect_ecswip_Family.new(_hx_tab_array({[0]=__deceptinfect_radiation_RadiationProducer, __deceptinfect_ecswip_VirtualPosition}, 2));
  
  __deceptinfect_ecswip_SystemManager.getSystems = __haxe_ds_ObjectMap.new();
  
  __deceptinfect_ecswip_SystemManager.runSystems = _hx_tab_array({[0]=__deceptinfect_infection_InfectionSystem, __deceptinfect_client_GeigerSystem, __deceptinfect_radiation_RadiationSystem, __deceptinfect_ecswip_GrabSystem, __deceptinfect_ecswip_HiddenHealthSystem, __deceptinfect_game_WinSystem, __deceptinfect_game_BatterySystem}, 7);
  
  __deceptinfect_radiation_RadiationTypes.types = (function() 
    local _hx_2
    
    local _g = __haxe_ds_EnumValueMap.new();
    
    _g:set(__deceptinfect_radiation_RadTypes.NEST, _hx_o({__fields__={maxrate=true,radius=true,contaminate=true,lifetime=true},maxrate=3,radius=500,contaminate=_hx_o({__fields__={chance=true,dist=true,time=true,check=true,type=true},chance=0.4,dist=20,time=60,check=0.8,type=__deceptinfect_radiation_ContaminationType.SAME_SOURCE}),lifetime=__deceptinfect_radiation_RadLifetime.INFINITE}));
    
    _g:set(__deceptinfect_radiation_RadTypes.CORPSE, _hx_o({__fields__={maxrate=true,radius=true,contaminate=true,lifetime=true},maxrate=6,radius=350,contaminate=_hx_o({__fields__={chance=true,time=true,check=true,dist=true,type=true},chance=0.5,time=35,check=0.5,dist=50,type=__deceptinfect_radiation_ContaminationType.SAME_SOURCE}),lifetime=__deceptinfect_radiation_RadLifetime.FINITE(25)}));
    
    _g:set(__deceptinfect_radiation_RadTypes.INF, _hx_o({__fields__={maxrate=true,radius=true,contaminate=true,lifetime=true},maxrate=4.5,radius=300,contaminate=_hx_o({__fields__={chance=true,time=true,check=true,dist=true,type=true},chance=0.4,time=20,check=0.3,dist=50,type=__deceptinfect_radiation_ContaminationType.SAME_SOURCE}),lifetime=__deceptinfect_radiation_RadLifetime.INFINITE}));
    
    _g:set(__deceptinfect_radiation_RadTypes.PUSTLE, _hx_o({__fields__={maxrate=true,radius=true},maxrate=3,radius=400}));
    
    _g:set(__deceptinfect_radiation_RadTypes.SPIT_HIT, _hx_o({__fields__={maxrate=true,radius=true,contaminate=true},maxrate=5,radius=250,contaminate=_hx_o({__fields__={chance=true,time=true,check=true,dist=true,type=true},chance=0.8,time=7,check=0.3,dist=60,type=__deceptinfect_radiation_ContaminationType.ALWAYS})}));
    
    _g:set(__deceptinfect_radiation_RadTypes.SPIT, _hx_o({__fields__={maxrate=true,radius=true},maxrate=4.5,radius=200}));
    
    _hx_2 = _g;
    return _hx_2
  end )();
  
  __gmod__EntityClass_EntityClass_Impl_.info_player_start = "info_player_start";
  
  __gmod_Hooks.PlayerConnect = "PlayerConnect";
  
  __gmod_Hooks.IsSpawnpointSuitable = "IsSpawnpointSuitable";
  
  __gmod_Hooks.LoadGModSave = "LoadGModSave";
  
  __gmod_Hooks.ShowTeam = "ShowTeam";
  
  __gmod_Hooks.ShouldCollide = "ShouldCollide";
  
  __gmod_Hooks.PlayerCanPickupItem = "PlayerCanPickupItem";
  
  __gmod_Hooks.CreateEntityRagdoll = "CreateEntityRagdoll";
  
  __gmod_Hooks.Saved = "Saved";
  
  __gmod_Hooks.AllowPlayerPickup = "AllowPlayerPickup";
  
  __gmod_Hooks.ScalePlayerDamage = "ScalePlayerDamage";
  
  __gmod_Hooks.PlayerInitialSpawn = "PlayerInitialSpawn";
  
  __gmod_Hooks.PlayerJoinTeam = "PlayerJoinTeam";
  
  __gmod_Hooks.OnPhysgunFreeze = "OnPhysgunFreeze";
  
  __gmod_Hooks.PlayerLoadout = "PlayerLoadout";
  
  __gmod_Hooks.PreCleanupMap = "PreCleanupMap";
  
  __gmod_Hooks.CreateTeams = "CreateTeams";
  
  __gmod_Hooks.OnLuaError = "OnLuaError";
  
  __gmod_Hooks.GravGunOnDropped = "GravGunOnDropped";
  
  __gmod_Hooks.KeyPress = "KeyPress";
  
  __gmod_Hooks.HandlePlayerVaulting = "HandlePlayerVaulting";
  
  __gmod_Hooks.PlayerCanSeePlayersChat = "PlayerCanSeePlayersChat";
  
  __gmod_Hooks.PlayerDeathThink = "PlayerDeathThink";
  
  __gmod_Hooks.EntityKeyValue = "EntityKeyValue";
  
  __gmod_Hooks.HandlePlayerLanding = "HandlePlayerLanding";
  
  __gmod_Hooks.PlayerCanPickupWeapon = "PlayerCanPickupWeapon";
  
  __gmod_Hooks.WorkshopEnd = "WorkshopEnd";
  
  __gmod_Hooks.PostPlayerDeath = "PostPlayerDeath";
  
  __gmod_Hooks.SetPlayerSpeed = "SetPlayerSpeed";
  
  __gmod_Hooks.FinishMove = "FinishMove";
  
  __gmod_Hooks.CanPlayerSuicide = "CanPlayerSuicide";
  
  __gmod_Hooks.StartEntityDriving = "StartEntityDriving";
  
  __gmod_Hooks.PlayerDeath = "PlayerDeath";
  
  __gmod_Hooks.PlayerCanHearPlayersVoice = "PlayerCanHearPlayersVoice";
  
  __gmod_Hooks.OnPlayerChangedTeam = "OnPlayerChangedTeam";
  
  __gmod_Hooks.HandlePlayerDriving = "HandlePlayerDriving";
  
  __gmod_Hooks.PlayerEnteredVehicle = "PlayerEnteredVehicle";
  
  __gmod_Hooks.PlayerSilentDeath = "PlayerSilentDeath";
  
  __gmod_Hooks.OnDamagedByExplosion = "OnDamagedByExplosion";
  
  __gmod_Hooks.PlayerSay = "PlayerSay";
  
  __gmod_Hooks.PostCleanupMap = "PostCleanupMap";
  
  __gmod_Hooks.MouthMoveAnimation = "MouthMoveAnimation";
  
  __gmod_Hooks.PlayerPostThink = "PlayerPostThink";
  
  __gmod_Hooks.PlayerNoClip = "PlayerNoClip";
  
  __gmod_Hooks.PlayerDriveAnimate = "PlayerDriveAnimate";
  
  __gmod_Hooks.PlayerLeaveVehicle = "PlayerLeaveVehicle";
  
  __gmod_Hooks.Restored = "Restored";
  
  __gmod_Hooks.EndEntityDriving = "EndEntityDriving";
  
  __gmod_Hooks.ShowSpare2 = "ShowSpare2";
  
  __gmod_Hooks.PlayerSelectTeamSpawn = "PlayerSelectTeamSpawn";
  
  __gmod_Hooks.NetworkIDValidated = "NetworkIDValidated";
  
  __gmod_Hooks.SetupMove = "SetupMove";
  
  __gmod_Hooks.PlayerButtonDown = "PlayerButtonDown";
  
  __gmod_Hooks.DoAnimationEvent = "DoAnimationEvent";
  
  __gmod_Hooks.MenuStart = "MenuStart";
  
  __gmod_Hooks.StartGame = "StartGame";
  
  __gmod_Hooks.PlayerButtonUp = "PlayerButtonUp";
  
  __gmod_Hooks.WorkshopDownloadFile = "WorkshopDownloadFile";
  
  __gmod_Hooks.VariableEdited = "VariableEdited";
  
  __gmod_Hooks.PlayerSwitchFlashlight = "PlayerSwitchFlashlight";
  
  __gmod_Hooks.OnNPCKilled = "OnNPCKilled";
  
  __gmod_Hooks.PlayerSpray = "PlayerSpray";
  
  __gmod_Hooks.PlayerFootstep = "PlayerFootstep";
  
  __gmod_Hooks.OnViewModelChanged = "OnViewModelChanged";
  
  __gmod_Hooks.PropBreak = "PropBreak";
  
  __gmod_Hooks.GetPreferredCarryAngles = "GetPreferredCarryAngles";
  
  __gmod_Hooks.CanPlayerUnfreeze = "CanPlayerUnfreeze";
  
  __gmod_Hooks.PostGamemodeLoaded = "PostGamemodeLoaded";
  
  __gmod_Hooks.PhysgunDrop = "PhysgunDrop";
  
  __gmod_Hooks.PlayerDeathSound = "PlayerDeathSound";
  
  __gmod_Hooks.HandlePlayerSwimming = "HandlePlayerSwimming";
  
  __gmod_Hooks.CalcMainActivity = "CalcMainActivity";
  
  __gmod_Hooks.PlayerSetHandsModel = "PlayerSetHandsModel";
  
  __gmod_Hooks.OnGamemodeLoaded = "OnGamemodeLoaded";
  
  __gmod_Hooks.PlayerSpawn = "PlayerSpawn";
  
  __gmod_Hooks.GravGunPunt = "GravGunPunt";
  
  __gmod_Hooks.GetFallDamage = "GetFallDamage";
  
  __gmod_Hooks.CanExitVehicle = "CanExitVehicle";
  
  __gmod_Hooks.AcceptInput = "AcceptInput";
  
  __gmod_Hooks.OnPhysgunPickup = "OnPhysgunPickup";
  
  __gmod_Hooks.PhysgunPickup = "PhysgunPickup";
  
  __gmod_Hooks.ShowHelp = "ShowHelp";
  
  __gmod_Hooks.OnPlayerHitGround = "OnPlayerHitGround";
  
  __gmod_Hooks.GravGunOnPickedUp = "GravGunOnPickedUp";
  
  __gmod_Hooks.Move = "Move";
  
  __gmod_Hooks.PlayerTick = "PlayerTick";
  
  __gmod_Hooks.Initialize = "Initialize";
  
  __gmod_Hooks.StartCommand = "StartCommand";
  
  __gmod_Hooks.PlayerCanJoinTeam = "PlayerCanJoinTeam";
  
  __gmod_Hooks.CaptureVideo = "CaptureVideo";
  
  __gmod_Hooks.KeyRelease = "KeyRelease";
  
  __gmod_Hooks.PlayerFrozeObject = "PlayerFrozeObject";
  
  __gmod_Hooks.CheckPassword = "CheckPassword";
  
  __gmod_Hooks.ShowSpare1 = "ShowSpare1";
  
  __gmod_Hooks.WorkshopDownloadProgress = "WorkshopDownloadProgress";
  
  __gmod_Hooks.PlayerUnfrozeObject = "PlayerUnfrozeObject";
  
  __gmod_Hooks.TranslateActivity = "TranslateActivity";
  
  __gmod_Hooks.PlayerShouldTaunt = "PlayerShouldTaunt";
  
  __gmod_Hooks.VehicleMove = "VehicleMove";
  
  __gmod_Hooks.GravGunPickupAllowed = "GravGunPickupAllowed";
  
  __gmod_Hooks.ShutDown = "ShutDown";
  
  __gmod_Hooks.CanEditVariable = "CanEditVariable";
  
  __gmod_Hooks.EntityNetworkedVarChanged = "EntityNetworkedVarChanged";
  
  __gmod_Hooks.EntityFireBullets = "EntityFireBullets";
  
  __gmod_Hooks.HandlePlayerJumping = "HandlePlayerJumping";
  
  __gmod_Hooks.Think = "Think";
  
  __gmod_Hooks.DoPlayerDeath = "DoPlayerDeath";
  
  __gmod_Hooks.EntityTakeDamage = "EntityTakeDamage";
  
  __gmod_Hooks.ScaleNPCDamage = "ScaleNPCDamage";
  
  __gmod_Hooks.WeaponEquip = "WeaponEquip";
  
  __gmod_Hooks.PreGamemodeLoaded = "PreGamemodeLoaded";
  
  __gmod_Hooks.WorkshopStart = "WorkshopStart";
  
  __gmod_Hooks.PlayerHurt = "PlayerHurt";
  
  __gmod_Hooks.WorkshopDownloadTotals = "WorkshopDownloadTotals";
  
  __gmod_Hooks.PlayerShouldTakeDamage = "PlayerShouldTakeDamage";
  
  __gmod_Hooks.Tick = "Tick";
  
  __gmod_Hooks.UpdateAnimation = "UpdateAnimation";
  
  __gmod_Hooks.EntityEmitSound = "EntityEmitSound";
  
  __gmod_Hooks.GameContentChanged = "GameContentChanged";
  
  __gmod_Hooks.CanPlayerEnterVehicle = "CanPlayerEnterVehicle";
  
  __gmod_Hooks.PlayerSpawnAsSpectator = "PlayerSpawnAsSpectator";
  
  __gmod_Hooks.SetupPlayerVisibility = "SetupPlayerVisibility";
  
  __gmod_Hooks.PlayerStartTaunt = "PlayerStartTaunt";
  
  __gmod_Hooks.PlayerTraceAttack = "PlayerTraceAttack";
  
  __gmod_Hooks.GetGameDescription = "GetGameDescription";
  
  __gmod_Hooks.PlayerSelectSpawn = "PlayerSelectSpawn";
  
  __gmod_Hooks.InitPostEntity = "InitPostEntity";
  
  __gmod_Hooks.GrabEarAnimation = "GrabEarAnimation";
  
  __gmod_Hooks.PlayerSetModel = "PlayerSetModel";
  
  __gmod_Hooks.PlayerDroppedWeapon = "PlayerDroppedWeapon";
  
  __gmod_Hooks.WorkshopDownloadedFile = "WorkshopDownloadedFile";
  
  __gmod_Hooks.PlayerRequestTeam = "PlayerRequestTeam";
  
  __gmod_Hooks.PlayerUse = "PlayerUse";
  
  __gmod_Hooks.HandlePlayerNoClipping = "HandlePlayerNoClipping";
  
  __gmod_Hooks.HandlePlayerDucking = "HandlePlayerDucking";
  
  __gmod_Hooks.EntityRemoved = "EntityRemoved";
  
  __gmod_Hooks.OnReloaded = "OnReloaded";
  
  __gmod_Hooks.WorkshopSubscriptionsProgress = "WorkshopSubscriptionsProgress";
  
  __gmod_Hooks.OnEntityCreated = "OnEntityCreated";
  
  __gmod_Hooks.PlayerStepSoundTime = "PlayerStepSoundTime";
  
  __gmod_Hooks.PlayerSwitchWeapon = "PlayerSwitchWeapon";
  
  __gmod_Hooks.PlayerDisconnected = "PlayerDisconnected";
  
  __gmod_Hooks.OnPhysgunReload = "OnPhysgunReload";
  
  __gmod_Hooks.PlayerAuthed = "PlayerAuthed";
  
  __gmod_Hooks.FindUseEntity = "FindUseEntity";
  
  __gmod_Hooks.postIntialize = "postIntialize";
  
  __haxe_EntryPoint.pending = Array.new();
  
  __haxe_EntryPoint.threadCount = 0;
  
  __lua_Boot.Max_Int32 = 2147483647;
  
  __lua_Boot.Min_Int32 = -2147483648;
  
  __lua_Boot.hiddenFields = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true}
  
  __tink_core__Callback_Callback_Impl_.depth = 0;
  
  __tink_core__Callback_Callback_Impl_.MAX_DEPTH = 500;
  
  __tink_core__Future_NeverFuture.inst = __tink_core__Future_NeverFuture.new();
  
  __tink_core__Future_Future_Impl_.NULL = (function() 
    local _hx_3
    
    local v = nil;
    
    _hx_3 = __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(v));
    return _hx_3
  end )();
  
  __tink_core__Future_Future_Impl_.NOISE = __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Noise.Noise));
  
  __tink_core__Future_Future_Impl_.NEVER = __tink_core__Future_NeverFuture.inst;
  
  __tink_core__Lazy_Lazy_Impl_.NULL = (function() 
    local _hx_4
    
    local c = nil;
    
    _hx_4 = __tink_core__Lazy_LazyConst.new(c);
    return _hx_4
  end )();
  
  __tink_core__Promise_Promise_Impl_.NULL = __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(nil)));
  
  __tink_core__Promise_Promise_Impl_.NOISE = __tink_core__Future_SyncFuture.new(__tink_core__Lazy_LazyConst.new(__tink_core_Outcome.Success(__tink_core_Noise.Noise)));
  
  __tink_core__Promise_Promise_Impl_.NEVER = (function() 
    local _hx_5
    
    local ret = __tink_core__Future_Future_Impl_.NEVER:map(__tink_core_Outcome.Success);
    
    _hx_5 = ret:gather();
    return _hx_5
  end )();
  
  
  String.__name__ = "String";
  Array.__name__ = "Array";
end

_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end

_hx_funcToField = function(f)
  if type(f) == 'function' then
    return function(self,...)
      return f(...)
    end
  else
    return f
  end
end

_G.math.randomseed(_G.os.time());

_hx_print = print or (function() end)

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

_hx_wrap_if_string_field = function(o, fld)
  if _G.type(o) == 'string' then
    if fld == 'length' then
      return _G.string.len(o)
    else
      return String.prototype[fld]
    end
  else
    return o[fld]
  end
end

_hx_static_init();

  Main.main();
  __haxe_EntryPoint.run();

return _hx_exports
