-- Generated by Haxe 4.1.1
local _hx_hidden = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true, __fields__=true, __name__=true}

_hx_array_mt = {
    __newindex = function(t,k,v)
        local len = t.length
        t.length =  k >= len and (k + 1) or len
        rawset(t,k,v)
    end
}

function _hx_is_array(o)
    return type(o) == "table"
        and o.__enum__ == nil
        and getmetatable(o) == _hx_array_mt
end



function _hx_tab_array(tab, length)
    tab.length = length
    return setmetatable(tab, _hx_array_mt)
end



function _hx_print_class(obj, depth)
    local first = true
    local result = ''
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            if first then
                first = false
            else
                result = result .. ', '
            end
            if _hx_hidden[k] == nil then
                result = result .. k .. ':' .. _hx_tostring(v, depth+1)
            end
        end
    end
    return '{ ' .. result .. ' }'
end

function _hx_print_enum(o, depth)
    if o.length == 2 then
        return o[0]
    else
        local str = o[0] .. "("
        for i = 2, (o.length-1) do
            if i ~= 2 then
                str = str .. "," .. _hx_tostring(o[i], depth+1)
            else
                str = str .. _hx_tostring(o[i], depth+1)
            end
        end
        return str .. ")"
    end
end

function _hx_tostring(obj, depth)
    if depth == nil then
        depth = 0
    elseif depth > 5 then
        return "<...>"
    end

    local tstr = _G.type(obj)
    if tstr == "string" then return obj
    elseif tstr == "nil" then return "null"
    elseif tstr == "number" then
        if obj == _G.math.POSITIVE_INFINITY then return "Infinity"
        elseif obj == _G.math.NEGATIVE_INFINITY then return "-Infinity"
        elseif obj == 0 then return "0"
        elseif obj ~= obj then return "NaN"
        else return _G.tostring(obj)
        end
    elseif tstr == "boolean" then return _G.tostring(obj)
    elseif tstr == "userdata" then
        local mt = _G.getmetatable(obj)
        if mt ~= nil and mt.__tostring ~= nil then
            return _G.tostring(obj)
        else
            return "<userdata>"
        end
    elseif tstr == "function" then return "<function>"
    elseif tstr == "thread" then return "<thread>"
    elseif tstr == "table" then
        if obj.__enum__ ~= nil then
            return _hx_print_enum(obj, depth)
        elseif obj.toString ~= nil and not _hx_is_array(obj) then return obj:toString()
        elseif _hx_is_array(obj) then
            if obj.length > 5 then
                return "[...]"
            else
                str = ""
                for i=0, (obj.length-1) do
                    if i == 0 then
                        str = str .. _hx_tostring(obj[i], depth+1)
                    else
                        str = str .. "," .. _hx_tostring(obj[i], depth+1)
                    end
                end
                return "[" .. str .. "]"
            end
        elseif obj.__class__ ~= nil then
            return _hx_print_class(obj, depth)
        else
            first = true
            buffer = {}
            for k,v in pairs(obj) do
                if _hx_hidden[k] == nil then
                    _G.table.insert(buffer, _hx_tostring(k, depth+1) .. ' : ' .. _hx_tostring(obj[k], depth+1))
                end
            end
            return "{ " .. table.concat(buffer, ", ") .. " }"
        end
    else
        _G.error("Unknown Lua type", 0)
        return ""
    end
end

function _hx_error(obj)
    print(obj)
    if obj.value then
        _G.print("Runtime Error: " .. _hx_tostring(obj.value));
    else
        _G.print("Runtime Error: " .. tostring(obj));
    end

    if _G.debug and _G.debug.traceback then
        _G.print(debug.traceback());
    end
end


local function _hx_obj_newindex(t,k,v)
    t.__fields__[k] = true
    rawset(t,k,v)
end

local _hx_obj_mt = {__newindex=_hx_obj_newindex, __tostring=_hx_tostring}

local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_obj_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_obj_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_obj_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_obj_newindex, __index=prototype, __tostring=_hx_tostring})
end

function _hx_field_arr(obj)
    res = {}
    idx = 0
    if obj.__fields__ ~= nil then
        obj = obj.__fields__
    end
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            res[idx] = k
            idx = idx + 1
        end
    end
    return _hx_tab_array(res, idx)
end

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();


function _hx_print_class(obj, depth)
    local first = true
    local result = ''
    local x = 0
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            x = x + 1;
            if x > 5 then result = result .. ', <...>' break end
            if first then
                first = false
            else
                result = result .. ', '
            end
            if _hx_hidden[k] == nil then
                result = result .. k .. ':' .. _hx_tostring(v, depth+1)
            end
        end
    end
    return '{ ' .. result .. ' }'
end

function _hx_tostring(obj, depth)
    if depth == nil then
        depth = 0
    elseif depth > 5 then
        return "<...>"
    end

    local tstr = _G.type(obj)
    if tstr == "string" then return obj
    elseif tstr == "nil" then return "null"
    elseif tstr == "number" then
        if obj == _G.math.POSITIVE_INFINITY then return "Infinity"
        elseif obj == _G.math.NEGATIVE_INFINITY then return "-Infinity"
        elseif obj == 0 then return "0"
        elseif obj ~= obj then return "NaN"
        else return _G.tostring(obj)
        end
    elseif tstr == "boolean" then return _G.tostring(obj)
    elseif tstr == "userdata" then
        local mt = _G.getmetatable(obj)
        if mt ~= nil and mt.__tostring ~= nil then
            return _G.tostring(obj)
        else
            return "<userdata>"
        end
    elseif tstr == "function" then return "<function>"
    elseif tstr == "thread" then return "<thread>"
    elseif tstr == "table" then
        if obj.__enum__ ~= nil then
            return _hx_print_enum(obj, depth)
        elseif obj.toString ~= nil and not _hx_is_array(obj) then return obj:toString()
        elseif _hx_is_array(obj) then
            if obj.length > 5 then
                return "[...]"
            else
                str = ""
                for i=0, (obj.length-1) do
                    if i == 0 then
                        str = str .. _hx_tostring(obj[i], depth+1)
                    else
                        str = str .. "," .. _hx_tostring(obj[i], depth+1)
                    end
                end
                return "[" .. str .. "]"
            end
        elseif obj.__class__ ~= nil then
            return _hx_print_class(obj, depth)
        else
            first = true
            buffer = {}
            for k,v in pairs(obj) do
                if _hx_hidden[k] == nil then
                    _G.table.insert(buffer, _hx_tostring(k, depth+1) .. ' : ' .. _hx_tostring(obj[k], depth+1))
                end
            end
            return "{ " .. table.concat(buffer, ", ") .. " }"
        end
    else
        if (_G.TypeID(obj) == _G.TYPE_NONE) then
          _G.error("Unknown lua type")
          return ""
        else
          return _G.tostring(obj)
        end
    end
end

local _hx_obj_mt = {__newindex=_hx_obj_newindex, __tostring=_hx_tostring}

local _hx_exports = _hx_exports or {}
local Array = _hx_e()
local Date = _hx_e()
__haxe_Exception = _hx_e()
__haxe_IMap = _hx_e()
__haxe_ds_StringMap = _hx_e()
__lua_Boot = _hx_e()
local String = _hx_e()
__lua_Thread = _hx_e()
__lua_UserData = _hx_e()
__haxe_ValueException = _hx_e()
local Std = _hx_e()
__haxe_NativeStackTrace = _hx_e()
local IntIterator = _hx_e()
local Main = _hx_e()
local Math = _hx_e()
local NETMESSAGE_di_cleanup = _hx_e()
local NETMESSAGE_di_evac = _hx_e()
local NETMESSAGE_di_infected = _hx_e()
local NETMESSAGE_di_infection = _hx_e()
local NETMESSAGE_di_infinfo = _hx_e()
local NETMESSAGE_di_raginfo = _hx_e()
local NETMESSAGE_di_statinfo = _hx_e()
local NETMESSAGE_gamestate = _hx_e()
local NETMESSAGE_geiger = _hx_e()
local NETMESSAGE_grabend = _hx_e()
local NETMESSAGE_grabupdate = _hx_e()
local NETMESSAGE_statue = _hx_e()
local Reflect = _hx_e()
local StringBuf = _hx_e()
local StringTools = _hx_e()
local Sys = _hx_e()
local ValueType = _hx_e()
local Type = _hx_e()
__deceptinfect_DeceptInfect = _hx_e()
__enumExtractor_EnumExtractor = _hx_e()
__deceptinfect_GAME_STATE = _hx_e()
__tink_core_SignalObject = _hx_e()
__tink_core_SignalTrigger = _hx_e()
__deceptinfect_GameManager = _hx_e()
__deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_ = _hx_e()
__deceptinfect_GameValues = _hx_e()
__deceptinfect_MapStorage = _hx_e()
__deceptinfect_Misc = _hx_e()
__deceptinfect_PlayerManager = _hx_e()
__hxbit_ProxyHost = _hx_e()
__hxbit_Serializable = _hx_e()
__hxbit_NetworkSerializable = _hx_e()
__hxbit_Serializer = _hx_e()
__deceptinfect_TestObject = _hx_e()
__deceptinfect_ecswip_Component = _hx_e()
__deceptinfect_ecswip_System = _hx_e()
__deceptinfect_client_ClientOverrides = _hx_e()
__deceptinfect_client_GeigerSystem = _hx_e()
__deceptinfect_client__Hud_Axis = _hx_e()
__deceptinfect_client_Hud = _hx_e()
__deceptinfect_client_PVS = _hx_e()
__deceptinfect_client_SabotagePanel = _hx_e()
__deceptinfect_client_SaboPanel3 = _hx_e()
__deceptinfect_client_SaboPanel4 = _hx_e()
__deceptinfect_client_SaboPanel2 = _hx_e()
__haxe_ds_ObjectMap = _hx_e()
__deceptinfect_ecswip_ComponentManager = _hx_e()
__deceptinfect_ecswip_ComponentState = _hx_e()
__deceptinfect_ecswip_GEntityComponent = _hx_e()
__deceptinfect_ecswip_GrabDraw = _hx_e()
__deceptinfect_ecswip_GrabSystem = _hx_e()
__deceptinfect_ecswip_HiddenHealthSystem = _hx_e()
__deceptinfect_ecswip_PlayerComponent = _hx_e()
__deceptinfect_ecswip_SignalStorage = _hx_e()
__deceptinfect_infection_InfectionSystem = _hx_e()
__deceptinfect_ecswip_VirtualPosition = _hx_e()
__deceptinfect_radiation_RadiationSystem = _hx_e()
__deceptinfect_game_WinSystem = _hx_e()
__deceptinfect_game_BatterySystem = _hx_e()
__deceptinfect_game_SpawnPointTable = _hx_e()
__deceptinfect_game_SpawnSystem = _hx_e()
__deceptinfect_statuses_WalkthroughSystem = _hx_e()
__deceptinfect_game_NestSystem = _hx_e()
__deceptinfect_game_EvacSystem = _hx_e()
__deceptinfect_game_RagdollSystem = _hx_e()
__deceptinfect_game_SlowMotionSystem = _hx_e()
__deceptinfect_infection_InfectionLookSystem = _hx_e()
__deceptinfect_radiation_ContaminationSystem = _hx_e()
__deceptinfect_radiation_RadSourceSystem = _hx_e()
__deceptinfect_game_LowHealthSystem = _hx_e()
__deceptinfect_items_ScannerSystem = _hx_e()
__deceptinfect_ecswip_SystemManager = _hx_e()
__deceptinfect_ecswip_ChooseVirPos = _hx_e()
__deceptinfect_ents_Di_battery = _hx_e()
__deceptinfect_ents_Di_charger = _hx_e()
__deceptinfect_game_ClientWeaponStatue = _hx_e()
__deceptinfect_game_KeepRestart = _hx_e()
__deceptinfect_game_RagInfo = _hx_e()
__deceptinfect_game_Spawn = _hx_e()
__deceptinfect_game_BoundsSpawn = _hx_e()
__deceptinfect_game_StatInfo = _hx_e()
__deceptinfect_game_Statue = _hx_e()
__deceptinfect_infection_InfectedComponent = _hx_e()
__deceptinfect_infection_InfectionComponent = _hx_e()
__deceptinfect_infection_AcceptingInfection = _hx_e()
__deceptinfect_infection_BaseInfection = _hx_e()
__deceptinfect_infection_INF_STATE = _hx_e()
__deceptinfect_items_Di_cure = _hx_e()
__deceptinfect_items_Weapon_Di_Scan = _hx_e()
__deceptinfect_util_EntityExt = _hx_e()
__deceptinfect_util_ValidID = _hx_e()
__deceptinfect_util_MinMaxTools = _hx_e()
__deceptinfect_util_Util = _hx_e()
__gmod_PairTools = _hx_e()
__gmod_cpanel_PanelBuild = _hx_e()
__hxbit_NetworkHost = _hx_e()
__haxe_ds_IntMap = _hx_e()
__gmod_hxbit_GmodNetHost = _hx_e()
__haxe_io_Input = _hx_e()
__gmod_hxbit_GmodNetworkInput = _hx_e()
__hxbit_NetworkClient = _hx_e()
__gmod_hxbit_Client = _hx_e()
__haxe_EntryPoint = _hx_e()
__haxe__Int64____Int64 = _hx_e()
__haxe_Log = _hx_e()
__haxe_MainEvent = _hx_e()
__haxe_MainLoop = _hx_e()
__haxe_Serializer = _hx_e()
__haxe_Timer = _hx_e()
__haxe__Unserializer_DefaultResolver = _hx_e()
__haxe_Unserializer = _hx_e()
__haxe_crypto_Crc32 = _hx_e()
__haxe_crypto_Md5 = _hx_e()
__haxe_ds_BalancedTree = _hx_e()
__haxe_ds_TreeNode = _hx_e()
__haxe_ds_EnumValueMap = _hx_e()
__haxe_ds_List = _hx_e()
__haxe_ds__List_ListNode = _hx_e()
__haxe_ds_Option = _hx_e()
__haxe_io_Bytes = _hx_e()
__haxe_io_BytesBuffer = _hx_e()
__haxe_io_Encoding = _hx_e()
__haxe_io_Eof = _hx_e()
__haxe_io_Error = _hx_e()
__haxe_io_FPHelper = _hx_e()
__haxe_iterators_ArrayIterator = _hx_e()
__haxe_iterators_ArrayKeyValueIterator = _hx_e()
__haxe_rtti_Meta = _hx_e()
__hxbit_ConvertField = _hx_e()
__hxbit_Convert = _hx_e()
__hxbit_PropTypeDesc = _hx_e()
__hxbit_ProxyChild = _hx_e()
__hxbit_BaseProxy = _hx_e()
__hxbit_NetworkSerializer = _hx_e()
__hxbit_NetworkStats = _hx_e()
__hxbit_Schema = _hx_e()
__hxbit_StructSerializable = _hx_e()
__hxbit_enumSer_Deceptinfect_infection_INF_STATE = _hx_e()
__hxbit_enumSer_Hxbit_PropTypeDesc = _hx_e()
__lua_lib_luv_Misc = _G.require("luv")
__tink_core__Callback_Callback_Impl_ = _hx_e()
__tink_core_LinkObject = _hx_e()
__tink_core__Callback_ListCell = _hx_e()
__tink_core_CallbackList = _hx_e()

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
_hxClasses["Array"] = Array
Array.__name__ = "Array"
Array.prototype = _hx_e();
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local _g1 = 0;
  while (_g1 < a.length) do 
    local i = a[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.join = function(self,sep) 
  local tbl = ({});
  local _g_current = 0;
  local _g_array = self;
  while (_g_current < _g_array.length) do 
    _g_current = _g_current + 1;
    _G.table.insert(tbl, Std.string(_g_array[_g_current - 1]));
  end;
  do return _G.table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do 
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      _G.table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do 
    _g = _g + 1;
    ret:push(self[_g - 1]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do 
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do 
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (_G.math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g = pos + len;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    self[i] = self[i + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = ({});
  _G.table.insert(tbl, "[");
  _G.table.insert(tbl, self:join(","));
  _G.table.insert(tbl, "]");
  do return _G.table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  while (_g < len) do 
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do 
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g = i;
      local _g1 = self.length - 1;
      while (_g < _g1) do 
        _g = _g + 1;
        local j = _g - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.contains = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    if (self[_g - 1] == x) then 
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  while (_g < _end) do 
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do 
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self) end
end
Array.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_ArrayKeyValueIterator.new(self) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do 
        _g = _g + 1;
        self[_g - 1] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

Date.new = function(year,month,day,hour,min,sec) 
  local self = _hx_new(Date.prototype)
  Date.super(self,year,month,day,hour,min,sec)
  return self
end
Date.super = function(self,year,month,day,hour,min,sec) 
  self.t = _G.os.time(_hx_o({__fields__={year=true,month=true,day=true,hour=true,min=true,sec=true},year=year,month=month + 1,day=day,hour=hour,min=min,sec=sec}));
  self.d = _G.os.date("*t", self.t);
  self.dUTC = _G.os.date("!*t", self.t);
end
_hxClasses["Date"] = Date
Date.__name__ = "Date"
Date.prototype = _hx_e();
Date.prototype.getTime = function(self) 
  do return self.t * 1000 end
end

Date.prototype.__class__ =  Date

__haxe_Exception.new = function(message,previous,native) 
  local self = _hx_new(__haxe_Exception.prototype)
  __haxe_Exception.super(self,message,previous,native)
  return self
end
__haxe_Exception.super = function(self,message,previous,native) 
  self.__skipStack = 0;
  self.__exceptionMessage = message;
  self.__previousException = previous;
  if (native ~= nil) then 
    self.__nativeException = native;
    self.__nativeStack = __haxe_NativeStackTrace.exceptionStack();
  else
    self.__nativeException = self;
    self.__nativeStack = __haxe_NativeStackTrace.callStack();
    self.__skipStack = 1;
  end;
end
_hxClasses["haxe.Exception"] = __haxe_Exception
__haxe_Exception.__name__ = "haxe.Exception"
__haxe_Exception.caught = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value end;
  else
    do return __haxe_ValueException.new(value, nil, value) end;
  end;
end
__haxe_Exception.thrown = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value:get_native() end;
  else
    local e = __haxe_ValueException.new(value);
    e.__skipStack = e.__skipStack + 1;
    do return e end;
  end;
end
__haxe_Exception.prototype = _hx_e();
__haxe_Exception.prototype.unwrap = function(self) 
  do return self.__nativeException end
end
__haxe_Exception.prototype.get_native = function(self) 
  do return self.__nativeException end
end

__haxe_Exception.prototype.__class__ =  __haxe_Exception

__haxe_IMap.new = {}
_hxClasses["haxe.IMap"] = __haxe_IMap
__haxe_IMap.__name__ = "haxe.IMap"
__haxe_IMap.prototype = _hx_e();

__haxe_IMap.prototype.__class__ =  __haxe_IMap

__haxe_ds_StringMap.new = function() 
  local self = _hx_new(__haxe_ds_StringMap.prototype)
  __haxe_ds_StringMap.super(self)
  return self
end
__haxe_ds_StringMap.super = function(self) 
  self.h = ({});
end
_hxClasses["haxe.ds.StringMap"] = __haxe_ds_StringMap
__haxe_ds_StringMap.__name__ = "haxe.ds.StringMap"
__haxe_ds_StringMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_StringMap.prototype = _hx_e();
__haxe_ds_StringMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__haxe_ds_StringMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end

__haxe_ds_StringMap.prototype.__class__ =  __haxe_ds_StringMap

__lua_Boot.new = {}
_hxClasses["lua.Boot"] = __lua_Boot
__lua_Boot.__name__ = "lua.Boot"
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl = o.__class__;
        tmp = (function() 
          local _hx_1
          if (cl ~= nil) then 
          _hx_1 = cl; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Class) then 
      _hx_2 = o.__name__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Enum) then 
      _hx_3 = o.__ename__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.strDate = function(s) 
  local _g = #s;
  if (_g) == 8 then 
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (#":" > 0) then 
        newidx = _G.string.find(s, ":", idx, true);
      else
        if (idx >= #s) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        ret:push(_G.string.sub(s, idx, newidx - 1));
        idx = newidx + #":";
      else
        ret:push(_G.string.sub(s, idx, #s));
        idx = nil;
      end;
    end;
    local t = ((_G.tonumber(ret[0]) * 3600000.) + (_G.tonumber(ret[1]) * 60000.)) + (_G.tonumber(ret[2]) * 1000.);
    local d = _hx_e();
    _G.setmetatable(d, _hx_o({__fields__={__index=true},__index=Date.prototype}));
    d.t = t / 1000;
    d.d = _G.os.date("*t", Std.int(d.t));
    d.dUTC = _G.os.date("!*t", Std.int(d.t));
    do return d end;
  elseif (_g) == 10 then 
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (#"-" > 0) then 
        newidx = _G.string.find(s, "-", idx, true);
      else
        if (idx >= #s) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        ret:push(_G.string.sub(s, idx, newidx - 1));
        idx = newidx + #"-";
      else
        ret:push(_G.string.sub(s, idx, #s));
        idx = nil;
      end;
    end;
    do return Date.new(_G.tonumber(ret[0]), _G.tonumber(ret[1]) - 1, _G.tonumber(ret[2]), 0, 0, 0) end;
  elseif (_g) == 19 then 
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (#" " > 0) then 
        newidx = _G.string.find(s, " ", idx, true);
      else
        if (idx >= #s) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        ret:push(_G.string.sub(s, idx, newidx - 1));
        idx = newidx + #" ";
      else
        ret:push(_G.string.sub(s, idx, #s));
        idx = nil;
      end;
    end;
    local _this = ret[0];
    local idx = 1;
    local ret1 = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (#"-" > 0) then 
        newidx = _G.string.find(_this, "-", idx, true);
      else
        if (idx >= #_this) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        ret1:push(_G.string.sub(_this, idx, newidx - 1));
        idx = newidx + #"-";
      else
        ret1:push(_G.string.sub(_this, idx, #_this));
        idx = nil;
      end;
    end;
    local _this = ret[1];
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (#":" > 0) then 
        newidx = _G.string.find(_this, ":", idx, true);
      else
        if (idx >= #_this) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        ret:push(_G.string.sub(_this, idx, newidx - 1));
        idx = newidx + #":";
      else
        ret:push(_G.string.sub(_this, idx, #_this));
        idx = nil;
      end;
    end;
    do return Date.new(_G.tonumber(ret1[0]), _G.tonumber(ret1[1]) - 1, _G.tonumber(ret1[2]), _G.tonumber(ret[0]), _G.tonumber(ret[1]), _G.tonumber(ret[2])) end;else
  _G.error(__haxe_Exception.thrown(Std.string("Invalid date format : ") .. Std.string(s)),0); end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  while (true) do 
    if ((cl1 == nil) or (cl2 == nil)) then 
      do return false end;
    else
      if (cl1 == cl2) then 
        do return true end;
      else
        if (cl1.__interfaces__ ~= nil) then 
          local intf = cl1.__interfaces__;
          local _g = 1;
          local _g1 = _hx_table.maxn(intf) + 1;
          while (_g < _g1) do 
            _g = _g + 1;
            local i = _g - 1;
            if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
              do return true end;
            end;
          end;
        end;
      end;
    end;
    cl1 = cl1.__super__;
  end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
_hxClasses["String"] = String
String.__name__ = "String"
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (_G.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (_G.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.indexOfEmpty = function(s,startIndex) 
  local length = _G.string.len(s);
  if (startIndex < 0) then 
    startIndex = length + startIndex;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
  end;
  if (startIndex > length) then 
    do return length end;
  else
    do return startIndex end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_e();
String.prototype.toUpperCase = function(self) 
  do return _G.string.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return _G.string.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  if (str == "") then 
    do return String.indexOfEmpty(self, startIndex - 1) end;
  end;
  local r = _G.string.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = #self;
  end;
  while (true) do 
    local startIndex1 = ret + 1;
    if (startIndex1 == nil) then 
      startIndex1 = 1;
    else
      startIndex1 = startIndex1 + 1;
    end;
    local p;
    if (str == "") then 
      p = String.indexOfEmpty(self, startIndex1 - 1);
    else
      local r = _G.string.find(self, str, startIndex1, true);
      p = (function() 
        local _hx_1
        if ((r ~= nil) and (r > 0)) then 
        _hx_1 = r - 1; else 
        _hx_1 = -1; end
        return _hx_1
      end )();
    end;
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (#delimiter > 0) then 
      newidx = _G.string.find(self, delimiter, idx, true);
    else
      if (idx >= #self) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      ret:push(_G.string.sub(self, idx, newidx - 1));
      idx = newidx + #delimiter;
    else
      ret:push(_G.string.sub(self, idx, #self));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = #self;
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return _G.string.sub(self, endIndex + 1, startIndex) end;
  else
    do return _G.string.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return _G.string.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return _G.string.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + #self))) then 
    len = #self;
  else
    if (len < 0) then 
      len = #self + len;
    end;
  end;
  if (pos < 0) then 
    pos = #self + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return _G.string.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

__lua_Thread.new = {}
_hxClasses["lua.Thread"] = __lua_Thread
__lua_Thread.__name__ = "lua.Thread"

__lua_UserData.new = {}
_hxClasses["lua.UserData"] = __lua_UserData
__lua_UserData.__name__ = "lua.UserData"

__haxe_ValueException.new = function(value,previous,native) 
  local self = _hx_new(__haxe_ValueException.prototype)
  __haxe_ValueException.super(self,value,previous,native)
  return self
end
__haxe_ValueException.super = function(self,value,previous,native) 
  __haxe_Exception.super(self,Std.string(value),previous,native);
  self.value = value;
end
_hxClasses["haxe.ValueException"] = __haxe_ValueException
__haxe_ValueException.__name__ = "haxe.ValueException"
__haxe_ValueException.prototype = _hx_e();
__haxe_ValueException.prototype.unwrap = function(self) 
  do return self.value end
end

__haxe_ValueException.prototype.__class__ =  __haxe_ValueException
__haxe_ValueException.__super__ = __haxe_Exception
setmetatable(__haxe_ValueException.prototype,{__index=__haxe_Exception.prototype})

Std.new = {}
_hxClasses["Std"] = Std
Std.__name__ = "Std"
Std.string = function(s) 
  do return _hx_tostring(s, 0) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end
Std.parseFloat = function(x) 
  if ((x == nil) or (x == "")) then 
    do return (0/0) end;
  end;
  local digitMatch = _G.string.match(x, "^ *[%.%-+]?[0-9]%d*");
  if (digitMatch == nil) then 
    do return (0/0) end;
  end;
  local pos = #digitMatch;
  local len = nil;
  if ((len == nil) or (len > (pos + #x))) then 
    len = #x;
  else
    if (len < 0) then 
      len = #x + len;
    end;
  end;
  if (pos < 0) then 
    pos = #x + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  x = _G.string.sub(x, pos + 1, pos + len);
  local decimalMatch = _G.string.match(x, "^%.%d*");
  if (decimalMatch == nil) then 
    decimalMatch = "";
  end;
  local pos = #decimalMatch;
  local len = nil;
  if ((len == nil) or (len > (pos + #x))) then 
    len = #x;
  else
    if (len < 0) then 
      len = #x + len;
    end;
  end;
  if (pos < 0) then 
    pos = #x + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  x = _G.string.sub(x, pos + 1, pos + len);
  local eMatch = _G.string.match(x, "^[eE][+%-]?%d+");
  if (eMatch == nil) then 
    eMatch = "";
  end;
  local result = _G.tonumber(Std.string(Std.string(digitMatch) .. Std.string(decimalMatch)) .. Std.string(eMatch));
  if (result ~= nil) then 
    do return result end;
  else
    do return (0/0) end;
  end;
end
Std.random = function(x) 
  if (x <= 0) then 
    do return 0 end;
  else
    do return _G.math.floor(_G.math.random() * x) end;
  end;
end

__haxe_NativeStackTrace.new = {}
_hxClasses["haxe.NativeStackTrace"] = __haxe_NativeStackTrace
__haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace"
__haxe_NativeStackTrace.saveStack = function(exception) 
end
__haxe_NativeStackTrace.callStack = function() 
  local _g = debug.traceback();
  if (_g == nil) then 
    do return _hx_tab_array({}, 0) end;
  else
    local idx = 1;
    local ret = _hx_tab_array({}, 0);
    while (idx ~= nil) do 
      local newidx = 0;
      if (#"\n" > 0) then 
        newidx = _G.string.find(_g, "\n", idx, true);
      else
        if (idx >= #_g) then 
          newidx = nil;
        else
          newidx = idx + 1;
        end;
      end;
      if (newidx ~= nil) then 
        ret:push(_G.string.sub(_g, idx, newidx - 1));
        idx = newidx + #"\n";
      else
        ret:push(_G.string.sub(_g, idx, #_g));
        idx = nil;
      end;
    end;
    do return ret:slice(3) end;
  end;
end
__haxe_NativeStackTrace.exceptionStack = function() 
  do return _hx_tab_array({}, 0) end;
end

IntIterator.new = function(min,max) 
  local self = _hx_new(IntIterator.prototype)
  IntIterator.super(self,min,max)
  return self
end
IntIterator.super = function(self,min,max) 
  self.min = min;
  self.max = max;
end
_hxClasses["IntIterator"] = IntIterator
IntIterator.__name__ = "IntIterator"
IntIterator.prototype = _hx_e();
IntIterator.prototype.hasNext = function(self) 
  do return self.min < self.max end
end
IntIterator.prototype.next = function(self) 
  do return (function() 
  local _hx_obj = self;
  local _hx_fld = 'min';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)() end
end

IntIterator.prototype.__class__ =  IntIterator

Main.new = {}
_hxClasses["Main"] = Main
Main.__name__ = "Main"
Main.main = function() 
  __deceptinfect_DeceptInfect.new();
  local ply = __gmod_PairTools.iterator(_G.player.GetAll());
  while (ply:hasNext()) do 
    local x = __deceptinfect_ecswip_PlayerComponent.new(ply:next());
    x.player.id = __deceptinfect_ecswip_ComponentManager.addPlayer(x.player);
  end;
  Main.nethost = __gmod_hxbit_GmodNetHost.new();
  _G.file.CreateDir("deceptinfect");
  _G.game.CleanUpMap();
  __deceptinfect_ecswip_SignalStorage.initEvents();
  __deceptinfect_GameManager.init();
  local _g = 0;
  local _g1 = __deceptinfect_Misc.roundModels;
  while (_g < _g1.length) do 
    local model = _g1[_g];
    _g = _g + 1;
    _G.util.PrecacheModel(model);
  end;
  __deceptinfect_game_SpawnSystem.generateSpawns();
  _G.util.PrecacheModel(__deceptinfect_Misc.infModel);
  __deceptinfect_client_ClientOverrides.new();
  __deceptinfect_client_SabotagePanel.register();
  __deceptinfect_ecswip_SystemManager.initAllSystems();
  _G.math.randomseed(_G.RealTime());
  __haxe_Log.trace("Deceptinfect server reinit!", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/Main.hx",lineNumber=58,className="Main",methodName="main"}));
end

Math.new = {}
_hxClasses["Math"] = Math
Math.__name__ = "Math"
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -_G.math.huge) then 
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.min(a, b) end;
  end;
end

NETMESSAGE_di_cleanup.new = function() 
  local self = _hx_new(NETMESSAGE_di_cleanup.prototype)
  NETMESSAGE_di_cleanup.super(self)
  return self
end
NETMESSAGE_di_cleanup.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("di_cleanup", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_di_cleanup"] = NETMESSAGE_di_cleanup
NETMESSAGE_di_cleanup.__name__ = "NETMESSAGE_di_cleanup"
NETMESSAGE_di_cleanup.prototype = _hx_e();
NETMESSAGE_di_cleanup.prototype.receive = function(self) 
  self.signalTrigger.handlers:invoke(_hx_e());
end

NETMESSAGE_di_cleanup.prototype.__class__ =  NETMESSAGE_di_cleanup

NETMESSAGE_di_evac.new = function() 
  local self = _hx_new(NETMESSAGE_di_evac.prototype)
  NETMESSAGE_di_evac.super(self)
  return self
end
NETMESSAGE_di_evac.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("di_evac", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_di_evac"] = NETMESSAGE_di_evac
NETMESSAGE_di_evac.__name__ = "NETMESSAGE_di_evac"
NETMESSAGE_di_evac.prototype = _hx_e();
NETMESSAGE_di_evac.prototype.receive = function(self) 
  local _this = self.signalTrigger;
  local event = _hx_o({__fields__={state=true,time=true},state=_G.net.ReadInt(32),time=_G.net.ReadFloat()});
  _this.handlers:invoke(event);
end

NETMESSAGE_di_evac.prototype.__class__ =  NETMESSAGE_di_evac

NETMESSAGE_di_infected.new = function() 
  local self = _hx_new(NETMESSAGE_di_infected.prototype)
  NETMESSAGE_di_infected.super(self)
  return self
end
NETMESSAGE_di_infected.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("di_infected", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_di_infected"] = NETMESSAGE_di_infected
NETMESSAGE_di_infected.__name__ = "NETMESSAGE_di_infected"
NETMESSAGE_di_infected.prototype = _hx_e();
NETMESSAGE_di_infected.prototype.receive = function(self) 
  self.signalTrigger.handlers:invoke(_hx_e());
end

NETMESSAGE_di_infected.prototype.__class__ =  NETMESSAGE_di_infected

NETMESSAGE_di_infection.new = function() 
  local self = _hx_new(NETMESSAGE_di_infection.prototype)
  NETMESSAGE_di_infection.super(self)
  return self
end
NETMESSAGE_di_infection.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("di_infection", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_di_infection"] = NETMESSAGE_di_infection
NETMESSAGE_di_infection.__name__ = "NETMESSAGE_di_infection"
NETMESSAGE_di_infection.prototype = _hx_e();
NETMESSAGE_di_infection.prototype.receive = function(self) 
  local _this = self.signalTrigger;
  local event = _hx_o({__fields__={infection=true},infection=_G.net.ReadFloat()});
  _this.handlers:invoke(event);
end

NETMESSAGE_di_infection.prototype.__class__ =  NETMESSAGE_di_infection

NETMESSAGE_di_infinfo.new = function() 
  local self = _hx_new(NETMESSAGE_di_infinfo.prototype)
  NETMESSAGE_di_infinfo.super(self)
  return self
end
NETMESSAGE_di_infinfo.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("di_infinfo", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_di_infinfo"] = NETMESSAGE_di_infinfo
NETMESSAGE_di_infinfo.__name__ = "NETMESSAGE_di_infinfo"
NETMESSAGE_di_infinfo.prototype = _hx_e();
NETMESSAGE_di_infinfo.prototype.receive = function(self) 
  local _this = self.signalTrigger;
  local event = _hx_o({__fields__={inf=true,isinfected=true,target=true},inf=_G.net.ReadFloat(),isinfected=_G.net.ReadBool(),target=_G.net.ReadEntity()});
  _this.handlers:invoke(event);
end

NETMESSAGE_di_infinfo.prototype.__class__ =  NETMESSAGE_di_infinfo

NETMESSAGE_di_raginfo.new = function() 
  local self = _hx_new(NETMESSAGE_di_raginfo.prototype)
  NETMESSAGE_di_raginfo.super(self)
  return self
end
NETMESSAGE_di_raginfo.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("di_raginfo", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_di_raginfo"] = NETMESSAGE_di_raginfo
NETMESSAGE_di_raginfo.__name__ = "NETMESSAGE_di_raginfo"
NETMESSAGE_di_raginfo.prototype = _hx_e();
NETMESSAGE_di_raginfo.prototype.receive = function(self) 
  local _this = self.signalTrigger;
  local event = _hx_o({__fields__={attacker=true,cause=true,inf=true,name=true,rag=true},attacker=_G.net.ReadString(),cause=_G.net.ReadInt(32),inf=_G.net.ReadFloat(),name=_G.net.ReadString(),rag=_G.net.ReadEntity()});
  _this.handlers:invoke(event);
end

NETMESSAGE_di_raginfo.prototype.__class__ =  NETMESSAGE_di_raginfo

NETMESSAGE_di_statinfo.new = function() 
  local self = _hx_new(NETMESSAGE_di_statinfo.prototype)
  NETMESSAGE_di_statinfo.super(self)
  return self
end
NETMESSAGE_di_statinfo.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("di_statinfo", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_di_statinfo"] = NETMESSAGE_di_statinfo
NETMESSAGE_di_statinfo.__name__ = "NETMESSAGE_di_statinfo"
NETMESSAGE_di_statinfo.prototype = _hx_e();
NETMESSAGE_di_statinfo.prototype.receive = function(self) 
  local _this = self.signalTrigger;
  local event = _hx_o({__fields__={health=true,inf=true,name=true,stat=true},health=_G.net.ReadFloat(),inf=_G.net.ReadFloat(),name=_G.net.ReadString(),stat=_G.net.ReadEntity()});
  _this.handlers:invoke(event);
end

NETMESSAGE_di_statinfo.prototype.__class__ =  NETMESSAGE_di_statinfo

NETMESSAGE_gamestate.new = function() 
  local self = _hx_new(NETMESSAGE_gamestate.prototype)
  NETMESSAGE_gamestate.super(self)
  return self
end
NETMESSAGE_gamestate.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("gamestate", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_gamestate"] = NETMESSAGE_gamestate
NETMESSAGE_gamestate.__name__ = "NETMESSAGE_gamestate"
NETMESSAGE_gamestate.prototype = _hx_e();
NETMESSAGE_gamestate.prototype.receive = function(self) 
  local _this = self.signalTrigger;
  local event = _hx_o({__fields__={state=true,time=true},state=_G.net.ReadInt(32),time=_G.net.ReadFloat()});
  _this.handlers:invoke(event);
end

NETMESSAGE_gamestate.prototype.__class__ =  NETMESSAGE_gamestate

NETMESSAGE_geiger.new = function() 
  local self = _hx_new(NETMESSAGE_geiger.prototype)
  NETMESSAGE_geiger.super(self)
  return self
end
NETMESSAGE_geiger.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("geiger", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_geiger"] = NETMESSAGE_geiger
NETMESSAGE_geiger.__name__ = "NETMESSAGE_geiger"
NETMESSAGE_geiger.prototype = _hx_e();
NETMESSAGE_geiger.prototype.receive = function(self) 
  local _this = self.signalTrigger;
  local event = _hx_o({__fields__={geiger=true},geiger=_G.net.ReadFloat()});
  _this.handlers:invoke(event);
end

NETMESSAGE_geiger.prototype.__class__ =  NETMESSAGE_geiger

NETMESSAGE_grabend.new = function() 
  local self = _hx_new(NETMESSAGE_grabend.prototype)
  NETMESSAGE_grabend.super(self)
  return self
end
NETMESSAGE_grabend.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("grabend", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_grabend"] = NETMESSAGE_grabend
NETMESSAGE_grabend.__name__ = "NETMESSAGE_grabend"
NETMESSAGE_grabend.prototype = _hx_e();
NETMESSAGE_grabend.prototype.receive = function(self) 
  local _this = self.signalTrigger;
  local event = _hx_o({__fields__={index=true},index=_G.net.ReadInt(32)});
  _this.handlers:invoke(event);
end

NETMESSAGE_grabend.prototype.__class__ =  NETMESSAGE_grabend

NETMESSAGE_grabupdate.new = function() 
  local self = _hx_new(NETMESSAGE_grabupdate.prototype)
  NETMESSAGE_grabupdate.super(self)
  return self
end
NETMESSAGE_grabupdate.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("grabupdate", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_grabupdate"] = NETMESSAGE_grabupdate
NETMESSAGE_grabupdate.__name__ = "NETMESSAGE_grabupdate"
NETMESSAGE_grabupdate.prototype = _hx_e();
NETMESSAGE_grabupdate.prototype.receive = function(self) 
  local _this = self.signalTrigger;
  local event = _hx_o({__fields__={ent=true,ent2=true,index=true},ent=_G.net.ReadEntity(),ent2=_G.net.ReadEntity(),index=_G.net.ReadInt(32)});
  _this.handlers:invoke(event);
end

NETMESSAGE_grabupdate.prototype.__class__ =  NETMESSAGE_grabupdate

NETMESSAGE_statue.new = function() 
  local self = _hx_new(NETMESSAGE_statue.prototype)
  NETMESSAGE_statue.super(self)
  return self
end
NETMESSAGE_statue.super = function(self) 
  self.signalTrigger = __tink_core_SignalTrigger.new();
  self.signal = self.signalTrigger;
  _G.net.Receive("statue", _hx_bind(self,self.receive));
end
_hxClasses["NETMESSAGE_statue"] = NETMESSAGE_statue
NETMESSAGE_statue.__name__ = "NETMESSAGE_statue"
NETMESSAGE_statue.prototype = _hx_e();
NETMESSAGE_statue.prototype.receive = function(self) 
  local _this = self.signalTrigger;
  local event = _hx_o({__fields__={playerangle=true,playerbones=true,playermodel=true,playerpos=true,weaponmodel=true},playerangle=_G.net.ReadTable(),playerbones=_G.net.ReadTable(),playermodel=_G.net.ReadString(),playerpos=_G.net.ReadVector(),weaponmodel=_G.net.ReadString()});
  _this.handlers:invoke(event);
end

NETMESSAGE_statue.prototype.__class__ =  NETMESSAGE_statue

Reflect.new = {}
_hxClasses["Reflect"] = Reflect
Reflect.__name__ = "Reflect"
Reflect.field = function(o,field) 
  if (_G.type(o) == "string") then 
    if (field == "length") then 
      do return _hx_wrap_if_string_field(o,'length') end;
    else
      do return String.prototype[field] end;
    end;
  else
    local _hx_status, _hx_result = pcall(function() 
    
        do return o[field] end;
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      do return nil end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end;
end
Reflect.callMethod = function(o,func,args) 
  if ((args == nil) or (args.length == 0)) then 
    do return func(o) end;
  else
    local self_arg = false;
    if ((o ~= nil) and (o.__name__ == nil)) then 
      self_arg = true;
    end;
    if (self_arg) then 
      do return func(o, _hx_table.unpack(args, 0, args.length - 1)) end;
    else
      do return func(_hx_table.unpack(args, 0, args.length - 1)) end;
    end;
  end;
end
Reflect.fields = function(o) 
  local _hx_continue_1 = false;
  while (true) do repeat 
    if (_G.type(o) == "string") then 
      o = String.prototype;
      break;
    else
      do return _hx_field_arr(o) end;
    end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
end
Reflect.isFunction = function(f) 
  if (_G.type(f) == "function") then 
    do return not ((function() 
      local _hx_1
      if (_G.type(f) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = f.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(f) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = f.__ename__; end
      return _hx_2
    end )()) end;
  else
    do return false end;
  end;
end
Reflect.compare = function(a,b) 
  if (a == b) then 
    do return 0 end;
  else
    if (a == nil) then 
      do return -1 end;
    else
      if (b == nil) then 
        do return 1 end;
      else
        if (a > b) then 
          do return 1 end;
        else
          do return -1 end;
        end;
      end;
    end;
  end;
end
Reflect.isEnumValue = function(v) 
  if ((v ~= nil) and __lua_Boot.__instanceof(v, _G.table)) then 
    do return v.__enum__ ~= nil end;
  else
    do return false end;
  end;
end

StringBuf.new = function() 
  local self = _hx_new(StringBuf.prototype)
  StringBuf.super(self)
  return self
end
StringBuf.super = function(self) 
  self.b = ({});
  self.length = 0;
end
_hxClasses["StringBuf"] = StringBuf
StringBuf.__name__ = "StringBuf"
StringBuf.prototype = _hx_e();

StringBuf.prototype.__class__ =  StringBuf

StringTools.new = {}
_hxClasses["StringTools"] = StringTools
StringTools.__name__ = "StringTools"
StringTools.urlEncode = function(s) 
  s = _G.string.gsub(s, "\n", "\r\n");
  s = _G.string.gsub(s, "([^%w %-%_%.%~])", function(c) 
    do return _G.string.format("%%%02X", Std.string(_G.string.byte(c)) .. Std.string("")) end;
  end);
  s = _G.string.gsub(s, " ", "+");
  do return s end;
end
StringTools.urlDecode = function(s) 
  s = _G.string.gsub(s, "+", " ");
  s = _G.string.gsub(s, "%%(%x%x)", function(h) 
    do return _G.string.char(_G.tonumber(h, 16)) end;
  end);
  s = _G.string.gsub(s, "\r\n", "\n");
  do return s end;
end

Sys.new = {}
_hxClasses["Sys"] = Sys
Sys.__name__ = "Sys"
Sys.time = function() 
  local _hx_1_stamp_seconds, _hx_1_stamp_microseconds = __lua_lib_luv_Misc.gettimeofday();
  do return _hx_1_stamp_seconds + (_hx_1_stamp_microseconds / 100000) end;
end
_hxClasses["ValueType"] = ValueType;
_hxClasses["ValueType"] = { __ename__ = "ValueType", __constructs__ = _hx_tab_array({[0]="TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"},9)}
ValueType = _hxClasses["ValueType"];
ValueType.TNull = _hx_tab_array({[0]="TNull",0,__enum__ = ValueType},2)

ValueType.TInt = _hx_tab_array({[0]="TInt",1,__enum__ = ValueType},2)

ValueType.TFloat = _hx_tab_array({[0]="TFloat",2,__enum__ = ValueType},2)

ValueType.TBool = _hx_tab_array({[0]="TBool",3,__enum__ = ValueType},2)

ValueType.TObject = _hx_tab_array({[0]="TObject",4,__enum__ = ValueType},2)

ValueType.TFunction = _hx_tab_array({[0]="TFunction",5,__enum__ = ValueType},2)

ValueType.TClass = function(c) local _x = _hx_tab_array({[0]="TClass",6,c,__enum__=ValueType}, 3); return _x; end 
ValueType.TEnum = function(e) local _x = _hx_tab_array({[0]="TEnum",7,e,__enum__=ValueType}, 3); return _x; end 
ValueType.TUnknown = _hx_tab_array({[0]="TUnknown",8,__enum__ = ValueType},2)


Type.new = {}
_hxClasses["Type"] = Type
Type.__name__ = "Type"
Type.getClass = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o = o;
  if (__lua_Boot.__instanceof(o, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o, String)) then 
      do return String end;
    else
      local cl = o.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end
Type.getSuperClass = function(c) 
  do return c.__super__ end;
end
Type.getEnumName = function(e) 
  if (e.__ename__ == nil) then 
    do return nil end;
  end;
  do return e.__ename__ end;
end
Type.resolveClass = function(name) 
  local cl = _hxClasses[name];
  local tmp;
  if (cl ~= nil) then 
    local o = cl;
    tmp = not ((function() 
      local _hx_1
      if (_G.type(o) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = o.__name__; end
      return _hx_1
    end )());
  else
    tmp = true;
  end;
  if (tmp) then 
    do return nil end;
  end;
  do return cl end;
end
Type.resolveEnum = function(name) 
  local e = _hxClasses[name];
  if ((e == nil) or not ((function() 
    local _hx_1
    if (_G.type(e) ~= "table") then 
    _hx_1 = false; else 
    _hx_1 = e.__ename__; end
    return _hx_1
  end )())) then 
    do return nil end;
  end;
  do return e end;
end
Type.createInstance = function(cl,args) 
  do return cl.new(_hx_table.unpack(args, 0)) end;
end
Type.createEmptyInstance = function(cl) 
  local ret = ({});
  _G.setmetatable(ret, _hx_o({__fields__={__index=true},__index=cl.prototype}));
  do return ret end;
end
Type.createEnum = function(e,constr,params) 
  local f = Reflect.field(e, constr);
  if (f == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string("No such constructor ") .. Std.string(constr)),0);
  end;
  if (Reflect.isFunction(f)) then 
    if (params == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string(Std.string("Constructor ") .. Std.string(constr)) .. Std.string(" need parameters")),0);
    end;
    do return Reflect.callMethod(nil,f,params) end;
  end;
  if ((params ~= nil) and (params.length ~= 0)) then 
    _G.error(__haxe_Exception.thrown(Std.string(Std.string("Constructor ") .. Std.string(constr)) .. Std.string(" does not need parameters")),0);
  end;
  do return f end;
end
Type.getEnumConstructs = function(e) 
  local a = e.__constructs__;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = a;
  while (_g1 < _g2.length) do 
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end;
end
Type.typeof = function(v) 
  local _g = _G.type(v);
  if (_g) == "boolean" then 
    do return ValueType.TBool end;
  elseif (_g) == "function" then 
    if ((function() 
      local _hx_1
      if (_G.type(v) ~= "table") then 
      _hx_1 = false; else 
      _hx_1 = v.__name__; end
      return _hx_1
    end )() or (function() 
      local _hx_2
      if (_G.type(v) ~= "table") then 
      _hx_2 = false; else 
      _hx_2 = v.__ename__; end
      return _hx_2
    end )()) then 
      do return ValueType.TObject end;
    end;
    do return ValueType.TFunction end;
  elseif (_g) == "nil" then 
    do return ValueType.TNull end;
  elseif (_g) == "number" then 
    if (_G.math.ceil(v) == (_G.math.fmod(v, 2147483648.0))) then 
      do return ValueType.TInt end;
    end;
    do return ValueType.TFloat end;
  elseif (_g) == "string" then 
    do return ValueType.TClass(String) end;
  elseif (_g) == "table" then 
    local e = v.__enum__;
    if (e ~= nil) then 
      do return ValueType.TEnum(e) end;
    end;
    local c;
    if (__lua_Boot.__instanceof(v, Array)) then 
      c = Array;
    else
      if (__lua_Boot.__instanceof(v, String)) then 
        c = String;
      else
        local cl = v.__class__;
        c = (function() 
          local _hx_3
          if (cl ~= nil) then 
          _hx_3 = cl; else 
          _hx_3 = nil; end
          return _hx_3
        end )();
      end;
    end;
    if (c ~= nil) then 
      do return ValueType.TClass(c) end;
    end;
    do return ValueType.TObject end;else
  do return ValueType.TUnknown end; end;
end
Type.enumEq = function(a,b) 
  if (a == b) then 
    do return true end;
  end;
  local _hx_status, _hx_result = pcall(function() 
  
      if (a[0] ~= b[0]) then 
        do return false end;
      end;
      local _g = 2;
      local _g1 = a.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        if (not Type.enumEq(a[i], b[i])) then 
          do return false end;
        end;
      end;
      local e = a.__enum__;
      if ((e ~= b.__enum__) or (e == nil)) then 
        do return false end;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    do return false end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return true end;
end

__deceptinfect_DeceptInfect.new = function() 
  local self = _hx_new(__deceptinfect_DeceptInfect.prototype)
  __deceptinfect_DeceptInfect.super(self)
  return self
end
__deceptinfect_DeceptInfect.super = function(self) 
  self.underperforming = false;
  self.timestart = 0;
  GM.CreateClientsideRagdoll = function(GM,...) return self:CreateClientsideRagdoll(...) end;
  GM.Think = function(GM,...) return self:Think(...) end;
  GM.OnEntityCreated = function(GM,...) return self:OnEntityCreated(...) end;
  GM.EntityRemoved = function(GM,...) return self:EntityRemoved(...) end;
  self["self"] = GM;
  __deceptinfect_DeceptInfect.instance = self;
end
_hxClasses["deceptinfect.DeceptInfect"] = __deceptinfect_DeceptInfect
__deceptinfect_DeceptInfect.__name__ = "deceptinfect.DeceptInfect"
__deceptinfect_DeceptInfect.prototype = _hx_e();
__deceptinfect_DeceptInfect.prototype.CreateClientsideRagdoll = function(self,entity,ragdoll) 
  ragdoll:SetNoDraw(true);
end
__deceptinfect_DeceptInfect.prototype.Think = function(self) 
  local nethost = Main.nethost;
  __deceptinfect_ecswip_SystemManager.runAllSystems();
  local _g = 0;
  local _g1 = nethost.clients;
  while (_g < _g1.length) do 
    local c = _g1[_g];
    _g = _g + 1;
    c:sync();
  end;
  nethost:flush();
end
__deceptinfect_DeceptInfect.prototype.checkPerformance = function(self) 
  if ((_G.FrameTime() > 0.016666666666667) and not self.underperforming) then 
    __haxe_Log.trace("Server underperforming! ", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/DeceptInfect.hx",lineNumber=70,className="deceptinfect.DeceptInfect",methodName="checkPerformance"}));
    self.underperforming = true;
  else
    if (self.underperforming) then 
      __haxe_Log.trace("Server recovered", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/DeceptInfect.hx",lineNumber=73,className="deceptinfect.DeceptInfect",methodName="checkPerformance"}));
      self.underperforming = false;
    end;
  end;
end
__deceptinfect_DeceptInfect.prototype.OnEntityCreated = function(self,entity) 
  if (entity:IsPlayer()) then 
    local x = __deceptinfect_ecswip_PlayerComponent.new(entity);
    x.player.id = __deceptinfect_ecswip_ComponentManager.addPlayer(x.player);
  end;
end
__deceptinfect_DeceptInfect.prototype.EntityRemoved = function(self,ent) 
  if (ent:IsPlayer()) then 
    __deceptinfect_ecswip_ComponentManager.removeEntity(ent.id);
    do return end;
  end;
  local _g = ent.id;
  local _g = (function() 
    local _hx_1
    if (_g == nil) then 
    _hx_1 = __haxe_ds_Option.None; else 
    _hx_1 = __haxe_ds_Option.Some(_g); end
    return _hx_1
  end )();
  if (_g[1] == 0) then 
    __deceptinfect_ecswip_ComponentManager.removeEntity(_g[2]);
  end;
end

__deceptinfect_DeceptInfect.prototype.__class__ =  __deceptinfect_DeceptInfect
__deceptinfect_DeceptInfect.__super__ = {} or a
setmetatable(__deceptinfect_DeceptInfect.prototype,{__index={} or a.prototype})

__enumExtractor_EnumExtractor.new = {}
_hxClasses["enumExtractor.EnumExtractor"] = __enumExtractor_EnumExtractor
__enumExtractor_EnumExtractor.__name__ = "enumExtractor.EnumExtractor"
_hxClasses["deceptinfect.GAME_STATE"] = __deceptinfect_GAME_STATE;
_hxClasses["deceptinfect.GAME_STATE"] = { __ename__ = "deceptinfect.GAME_STATE", __constructs__ = _hx_tab_array({[0]="WAIT","SETTING_UP","PLAYING","ENDING"},4)}
__deceptinfect_GAME_STATE = _hxClasses["deceptinfect.GAME_STATE"];
__deceptinfect_GAME_STATE.WAIT = _hx_tab_array({[0]="WAIT",0,__enum__ = __deceptinfect_GAME_STATE},2)

__deceptinfect_GAME_STATE.SETTING_UP = _hx_tab_array({[0]="SETTING_UP",1,__enum__ = __deceptinfect_GAME_STATE},2)

__deceptinfect_GAME_STATE.PLAYING = _hx_tab_array({[0]="PLAYING",2,__enum__ = __deceptinfect_GAME_STATE},2)

__deceptinfect_GAME_STATE.ENDING = _hx_tab_array({[0]="ENDING",3,__enum__ = __deceptinfect_GAME_STATE},2)


__tink_core_SignalObject.new = {}
_hxClasses["tink.core.SignalObject"] = __tink_core_SignalObject
__tink_core_SignalObject.__name__ = "tink.core.SignalObject"
__tink_core_SignalObject.prototype = _hx_e();

__tink_core_SignalObject.prototype.__class__ =  __tink_core_SignalObject

__tink_core_SignalTrigger.new = function() 
  local self = _hx_new(__tink_core_SignalTrigger.prototype)
  __tink_core_SignalTrigger.super(self)
  return self
end
__tink_core_SignalTrigger.super = function(self) 
  self.handlers = __tink_core_CallbackList.new();
end
_hxClasses["tink.core.SignalTrigger"] = __tink_core_SignalTrigger
__tink_core_SignalTrigger.__name__ = "tink.core.SignalTrigger"
__tink_core_SignalTrigger.__interfaces__ = {__tink_core_SignalObject}
__tink_core_SignalTrigger.prototype = _hx_e();
__tink_core_SignalTrigger.prototype.listen = function(self,cb) 
  local _this = self.handlers;
  local node = __tink_core__Callback_ListCell.new(cb, _this);
  _this.cells:push(node);
  _this.used = _this.used + 1;
  do return node end
end

__tink_core_SignalTrigger.prototype.__class__ =  __tink_core_SignalTrigger

__deceptinfect_GameManager.new = {}
_hxClasses["deceptinfect.GameManager"] = __deceptinfect_GameManager
__deceptinfect_GameManager.__name__ = "deceptinfect.GameManager"
__deceptinfect_GameManager.__interfaces__ = {__enumExtractor_EnumExtractor}
__deceptinfect_GameManager.init = function() 
  __deceptinfect_GameManager.stateChange = __deceptinfect_GameManager.stateTrig;
  __deceptinfect_GameManager.net_gamestate.signal:listen(__deceptinfect_GameManager.gameStateChanged);
  __deceptinfect_GameManager.net_cleanup.signal:listen(__tink_core__Callback_Callback_Impl_.fromNiladic(__deceptinfect_GameManager.cleanup));
end
__deceptinfect_GameManager.cleanup = function() 
  local ent = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
  while (ent:hasNext()) do 
    local ent = ent:next();
    if (__deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_game_KeepRestart)[ent][1] ~= 1) then 
      __deceptinfect_ecswip_ComponentManager.removeEntity(ent);
    end;
  end;
  __deceptinfect_GameManager.stateTrig.handlers:clear();
  __deceptinfect_ecswip_SystemManager.initAllSystems();
end
__deceptinfect_GameManager.gameStateChanged = function(x) 
  __haxe_Log.trace(Std.string("game state changed ") .. Std.string(Std.string(x)), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/GameManager.hx",lineNumber=324,className="deceptinfect.GameManager",methodName="gameStateChanged"}));
  __deceptinfect_GameManager.state = __deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.toGAME_STATE(x.state);
  local _g = x.state;
  if (_g) == 0 then 
  elseif (_g) == 2 then else end;
  local _this = __deceptinfect_GameManager.stateTrig;
  local event = __deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.toGAME_STATE(x.state);
  _this.handlers:invoke(event);
end

__deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.new = {}
_hxClasses["deceptinfect._GameManager.Net_GAME_STATE_VAL_Impl_"] = __deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_
__deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.__name__ = "deceptinfect._GameManager.Net_GAME_STATE_VAL_Impl_"
__deceptinfect__GameManager_Net_GAME_STATE_VAL_Impl_.toGAME_STATE = function(this1) 
  if (this1) == 0 then 
    do return __deceptinfect_GAME_STATE.WAIT end;
  elseif (this1) == 1 then 
    do return __deceptinfect_GAME_STATE.SETTING_UP end;
  elseif (this1) == 2 then 
    do return __deceptinfect_GAME_STATE.PLAYING end;
  elseif (this1) == 3 then 
    do return __deceptinfect_GAME_STATE.ENDING end;else
  _G.error(__haxe_Exception.thrown("Unhandled net game state conversion"),0); end;
end

__deceptinfect_GameValues.new = {}
_hx_exports["GameValues"] = __deceptinfect_GameValues
_hxClasses["deceptinfect.GameValues"] = __deceptinfect_GameValues
__deceptinfect_GameValues.__name__ = "deceptinfect.GameValues"

__deceptinfect_MapStorage.new = {}
_hxClasses["deceptinfect.MapStorage"] = __deceptinfect_MapStorage
__deceptinfect_MapStorage.__name__ = "deceptinfect.MapStorage"

__deceptinfect_Misc.new = {}
_hxClasses["deceptinfect.Misc"] = __deceptinfect_Misc
__deceptinfect_Misc.__name__ = "deceptinfect.Misc"

__deceptinfect_PlayerManager.new = {}
_hxClasses["deceptinfect.PlayerManager"] = __deceptinfect_PlayerManager
__deceptinfect_PlayerManager.__name__ = "deceptinfect.PlayerManager"
__deceptinfect_PlayerManager.addID = function(ent,id) 
  local this1 = __deceptinfect_PlayerManager.indexLookup;
  local key = ent:EntIndex();
  local _this = this1;
  if (id == nil) then 
    _this.h[key] = __haxe_ds_IntMap.tnull;
  else
    _this.h[key] = id;
  end;
end
__deceptinfect_PlayerManager.getLocalPlayerID = function() 
  local _g = _G.LocalPlayer().id;
  local _g = (function() 
    local _hx_1
    if (_g == nil) then 
    _hx_1 = __haxe_ds_Option.None; else 
    _hx_1 = __haxe_ds_Option.Some(_g); end
    return _hx_1
  end )();
  local tmp = _g[1];
  if (tmp) == 0 then 
    do return _g[2] end;
  elseif (tmp) == 1 then 
    _G.error(__haxe_Exception.thrown("Local player has no id..."),0); end;
end

__hxbit_ProxyHost.new = {}
_hxClasses["hxbit.ProxyHost"] = __hxbit_ProxyHost
__hxbit_ProxyHost.__name__ = "hxbit.ProxyHost"

__hxbit_Serializable.new = {}
_hxClasses["hxbit.Serializable"] = __hxbit_Serializable
__hxbit_Serializable.__name__ = "hxbit.Serializable"
__hxbit_Serializable.prototype = _hx_e();

__hxbit_Serializable.prototype.__class__ =  __hxbit_Serializable

__hxbit_NetworkSerializable.new = {}
_hxClasses["hxbit.NetworkSerializable"] = __hxbit_NetworkSerializable
__hxbit_NetworkSerializable.__name__ = "hxbit.NetworkSerializable"
__hxbit_NetworkSerializable.__interfaces__ = {__hxbit_ProxyHost,__hxbit_Serializable}
__hxbit_NetworkSerializable.prototype = _hx_e();

__hxbit_NetworkSerializable.prototype.__class__ =  __hxbit_NetworkSerializable

__hxbit_Serializer.new = function() 
  local self = _hx_new(__hxbit_Serializer.prototype)
  __hxbit_Serializer.super(self)
  return self
end
__hxbit_Serializer.super = function(self) 
  self.usedClasses = _hx_tab_array({}, 0);
  if (__hxbit_Serializer.CLIDS == nil) then 
    __hxbit_Serializer.initClassIDS();
  end;
end
_hxClasses["hxbit.Serializer"] = __hxbit_Serializer
__hxbit_Serializer.__name__ = "hxbit.Serializer"
__hxbit_Serializer.resetCounters = function() 
  __hxbit_Serializer.UID = 0;
  __hxbit_Serializer.SEQ = 0;
end
__hxbit_Serializer.registerClass = function(c) 
  if (__hxbit_Serializer.CLIDS ~= nil) then 
    _G.error(__haxe_Exception.thrown("Too late to register class"),0);
  end;
  local idx = __hxbit_Serializer.CLASSES.length;
  __hxbit_Serializer.CLASSES:push(c);
  do return idx end;
end
__hxbit_Serializer.initClassIDS = function() 
  local cl = __hxbit_Serializer.CLASSES;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  while (_g1 < cl.length) do 
    _g1 = _g1 + 1;
    _g:push(_hx_tab_array({}, 0));
  end;
  local subClasses = _g;
  local isSub = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = cl.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local c = cl[i];
    while (true) do 
      c = Type.getSuperClass(c);
      if (c == nil) then 
        break;
      end;
      local idx = cl:indexOf(c);
      if (idx < 0) then 
        break;
      end;
      subClasses[idx]:push(i);
      isSub[i] = true;
    end;
  end;
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = __hxbit_Serializer.CLASSES.length;
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    local i = _g1 - 1;
    if ((subClasses[i].length == 0) and not isSub[i]) then 
      _g:push(0);
    else
      local name = cl[i].__name__;
      local v = 1;
      local _g1 = 0;
      local _g2 = #name;
      while (_g1 < _g2) do 
        _g1 = _g1 + 1;
        v = Std.int((v * 223) + _G.string.byte(name, (_g1 - 1) + 1));
      end;
      v = 1 + (_G.math.fmod((_hx_bit.band(v,1073741823)), 65423));
      _g:push(v);
    end;
  end;
  __hxbit_Serializer.CLIDS = _g;
  __hxbit_Serializer.CL_BYID = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = __hxbit_Serializer.CLIDS.length;
  local _hx_continue_1 = false;
  while (_g < _g1) do repeat 
    _g = _g + 1;
    local i = _g - 1;
    local cid = __hxbit_Serializer.CLIDS[i];
    if (cid == 0) then 
      break;
    end;
    if (__hxbit_Serializer.CL_BYID[cid] ~= nil) then 
      local c = __hxbit_Serializer.CL_BYID[cid];
      _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Conflicting CLID between ") .. Std.string(c.__name__)) .. Std.string(" and ")) .. Std.string(cl[i].__name__)),0);
    end;
    __hxbit_Serializer.CL_BYID[cid] = cl[i];until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
end
__hxbit_Serializer.getSignature = function() 
  if (__hxbit_Serializer.__SIGN ~= nil) then 
    do return __hxbit_Serializer.__SIGN end;
  end;
  local s = __hxbit_Serializer.new();
  s:begin();
  local v = __hxbit_Serializer.CLASSES.length;
  if ((v >= 0) and (v < 128)) then 
    s.out.b:push(v);
  else
    s.out.b:push(128);
    s.out:addInt32(v);
  end;
  local _g = 0;
  local _g1 = __hxbit_Serializer.CLASSES.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local v = __hxbit_Serializer.CLIDS[i];
    if ((v >= 0) and (v < 128)) then 
      s.out.b:push(v);
    else
      s.out.b:push(128);
      s.out:addInt32(v);
    end;
    local v = Type.createEmptyInstance(__hxbit_Serializer.CLASSES[i]):getSerializeSchema():get_checkSum();
    s.out:addInt32(v);
  end;
  __hxbit_Serializer.__SIGN = __haxe_crypto_Md5.make(_hx_apply_self(s,"end")) do return __hxbit_Serializer.__SIGN end;
end
__hxbit_Serializer.isClassFinal = function(index) 
  do return __hxbit_Serializer.CLIDS[index] == 0 end;
end
__hxbit_Serializer.prototype = _hx_e();
__hxbit_Serializer.prototype.remap = function(self,s) 
  if (self.remapObjs.k[s] ~= nil) then 
    do return end;
  end;
  local _this = self.remapObjs;
  _this.h[s] = s.__uid;
  _this.k[s] = true;
  s.__uid = _hx_bit.bor(_hx_bit.lshift(__hxbit_Serializer.SEQ,24),(function() 
  local _hx_obj = __hxbit_Serializer;
  local _hx_fld = 'UID';
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _hx_obj[_hx_fld];
   end)());
end
__hxbit_Serializer.prototype.begin = function(self) 
  self.out = __haxe_io_BytesBuffer.new();
  self.refs = __haxe_ds_IntMap.new();
  self.knownStructs = _hx_tab_array({}, 0);
end
__hxbit_Serializer.prototype["end"] = function(self) 
  local bytes = self.out:getBytes();
  self.out = nil;
  self.refs = nil;
  self.knownStructs = nil;
  do return bytes end
end
__hxbit_Serializer.prototype.setInput = function(self,data,pos) 
  self.input = data;
  self.inPos = pos;
  if (self.refs == nil) then 
    self.refs = __haxe_ds_IntMap.new();
  end;
  if (self.knownStructs == nil) then 
    self.knownStructs = _hx_tab_array({}, 0);
  end;
end
__hxbit_Serializer.prototype.getDynamic = function(self) 
  local pos = (function() 
  local _hx_obj = self;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local _g = self.input.b[pos];
  local _g1 = _g;
  if (_g1) == 0 then 
    do return nil end;
  elseif (_g1) == 1 then 
    do return false end;
  elseif (_g1) == 2 then 
    do return true end;
  elseif (_g1) == 3 then 
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_1
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_1 = _hx_bit.bor(v1,-2147483648); else 
        _hx_1 = v1; end
        return _hx_1
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    do return v end;
  elseif (_g1) == 4 then 
    local v = self.input:getFloat(self.inPos);
    local tmp = self;
    tmp.inPos = tmp.inPos + 4;
    do return v end;
  elseif (_g1) == 5 then 
    local o = _hx_e();
    local _g = 0;
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_2
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_2 = _hx_bit.bor(v1,-2147483648); else 
        _hx_2 = v1; end
        return _hx_2
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local _g1 = v;
    while (_g < _g1) do 
      _g = _g + 1;
      local pos = (function() 
      local _hx_obj = self;
      local _hx_fld = 'inPos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local v = self.input.b[pos];
      if (v == 128) then 
        local _this = self.input;
        local pos = self.inPos;
        local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
        v = _hx_bit_clamp((function() 
          local _hx_3
          if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
          _hx_3 = _hx_bit.bor(v1,-2147483648); else 
          _hx_3 = v1; end
          return _hx_3
        end )());
        local tmp = self;
        tmp.inPos = tmp.inPos + 4;
      end;
      local len = v;
      local field;
      if (len == 0) then 
        field = nil;
      else
        len = len - 1;
        local s = self.input:getString(self.inPos, len);
        local field1 = self;
        field1.inPos = field1.inPos + len;
        field = s;
      end;
      o[field] = self:getDynamic();
    end;
    do return o end;
  elseif (_g1) == 6 then 
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_4
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_4 = _hx_bit.bor(v1,-2147483648); else 
        _hx_4 = v1; end
        return _hx_4
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local len = v;
    if (len == 0) then 
      do return nil end;
    else
      len = len - 1;
      local s = self.input:getString(self.inPos, len);
      local tmp = self;
      tmp.inPos = tmp.inPos + len;
      do return s end;
    end;
  elseif (_g1) == 7 then 
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_5
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_5 = _hx_bit.bor(v1,-2147483648); else 
        _hx_5 = v1; end
        return _hx_5
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local _g2 = v;
    while (_g1 < _g2) do 
      _g1 = _g1 + 1;
      _g:push(self:getDynamic());
    end;
    do return _g end;
  elseif (_g1) == 8 then 
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_6
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_6 = _hx_bit.bor(v1,-2147483648); else 
        _hx_6 = v1; end
        return _hx_6
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local len = v;
    if (len == 0) then 
      do return nil end;
    else
      len = len - 1;
      local s = self.input:sub(self.inPos, len);
      local tmp = self;
      tmp.inPos = tmp.inPos + len;
      do return s end;
    end;else
  _G.error(__haxe_Exception.thrown(Std.string("Invalid dynamic prefix ") .. Std.string(_g)),0); end;
end
__hxbit_Serializer.prototype.addDynamic = function(self,v) 
  if (v == nil) then 
    self.out.b:push(0);
    do return end;
  end;
  local _g = Type.typeof(v);
  local tmp = _g[1];
  if (tmp) == 1 then 
    self.out.b:push(3);
    local v = v;
    if ((v >= 0) and (v < 128)) then 
      self.out.b:push(v);
    else
      self.out.b:push(128);
      self.out:addInt32(v);
    end;
  elseif (tmp) == 2 then 
    self.out.b:push(4);
    self.out:addInt32(__haxe_io_FPHelper.floatToI32(v));
  elseif (tmp) == 3 then 
    self.out.b:push((function() 
      local _hx_1
      if (v) then 
      _hx_1 = 2; else 
      _hx_1 = 1; end
      return _hx_1
    end )());
  elseif (tmp) == 4 then 
    local fields = Reflect.fields(v);
    self.out.b:push(5);
    local v1 = fields.length;
    if ((v1 >= 0) and (v1 < 128)) then 
      self.out.b:push(v1);
    else
      self.out.b:push(128);
      self.out:addInt32(v1);
    end;
    local _g = 0;
    while (_g < fields.length) do 
      local f = fields[_g];
      _g = _g + 1;
      if (f == nil) then 
        self.out.b:push(0);
      else
        local b = __haxe_io_Bytes.ofString(f);
        local v = b.length + 1;
        if ((v >= 0) and (v < 128)) then 
          self.out.b:push(v);
        else
          self.out.b:push(128);
          self.out:addInt32(v);
        end;
        local _this = self.out;
        local b2 = b.b;
        local _g = 0;
        local _g1 = b.length;
        while (_g < _g1) do 
          _g = _g + 1;
          _this.b:push(b2[_g - 1]);
        end;
      end;
      self:addDynamic(Reflect.field(v, f));
    end;
  elseif (tmp) == 6 then 
    local _g = _g[2];
    if (_g) == Array then 
      self.out.b:push(7);
      local a = v;
      local v = a.length;
      if ((v >= 0) and (v < 128)) then 
        self.out.b:push(v);
      else
        self.out.b:push(128);
        self.out:addInt32(v);
      end;
      local _g = 0;
      while (_g < a.length) do 
        local v = a[_g];
        _g = _g + 1;
        self:addDynamic(v);
      end;
    elseif (_g) == String then 
      self.out.b:push(6);
      local s = v;
      if (s == nil) then 
        self.out.b:push(0);
      else
        local b = __haxe_io_Bytes.ofString(s);
        local v = b.length + 1;
        if ((v >= 0) and (v < 128)) then 
          self.out.b:push(v);
        else
          self.out.b:push(128);
          self.out:addInt32(v);
        end;
        local _this = self.out;
        local b2 = b.b;
        local _g = 0;
        local _g1 = b.length;
        while (_g < _g1) do 
          _g = _g + 1;
          _this.b:push(b2[_g - 1]);
        end;
      end;
    elseif (_g) == __haxe_io_Bytes then 
      self.out.b:push(8);
      local b = v;
      if (b == nil) then 
        self.out.b:push(0);
      else
        local v = b.length + 1;
        if ((v >= 0) and (v < 128)) then 
          self.out.b:push(v);
        else
          self.out.b:push(128);
          self.out:addInt32(v);
        end;
        local _this = self.out;
        local b2 = b.b;
        local _g = 0;
        local _g1 = b.length;
        while (_g < _g1) do 
          _g = _g + 1;
          _this.b:push(b2[_g - 1]);
        end;
      end;else
    _G.error(__haxe_Exception.thrown(Std.string("Unsupported dynamic ") .. Std.string(Std.string(_g))),0); end;else
  _G.error(__haxe_Exception.thrown(Std.string("Unsupported dynamic ") .. Std.string(Std.string(_g))),0); end;
end
__hxbit_Serializer.prototype.addStruct = function(self,s) 
  if (s == nil) then 
    self.out.b:push(0);
    do return end;
  end;
  local c = (function() 
    local _hx_1
    if (__lua_Boot.__instanceof(s, __hxbit_Serializable)) then 
    _hx_1 = s; else 
    _hx_1 = nil; end
    return _hx_1
  end )();
  if (c ~= nil) then 
    self.out.b:push(1);
    self:addAnyRef(c);
    do return end;
  end;
  local index = self.knownStructs:indexOf(s);
  if (index >= 0) then 
    self.out.b:push(2);
    if ((index >= 0) and (index < 128)) then 
      self.out.b:push(index);
    else
      self.out.b:push(128);
      self.out:addInt32(index);
    end;
    do return end;
  end;
  self.knownStructs:push(s);
  self.out.b:push(3);
  local c = Type.getClass(s);
  if (c == nil) then 
    _G.error(__haxe_Exception.thrown(Std.string(Std.string(s)) .. Std.string(" does not have a class ?")),0);
  end;
  local s1 = c.__name__;
  if (s1 == nil) then 
    self.out.b:push(0);
  else
    local b = __haxe_io_Bytes.ofString(s1);
    local v = b.length + 1;
    if ((v >= 0) and (v < 128)) then 
      self.out.b:push(v);
    else
      self.out.b:push(128);
      self.out:addInt32(v);
    end;
    local _this = self.out;
    local b2 = b.b;
    local _g = 0;
    local _g1 = b.length;
    while (_g < _g1) do 
      _g = _g + 1;
      _this.b:push(b2[_g - 1]);
    end;
  end;
  s:customSerialize(self);
  self.out.b:push(255);
end
__hxbit_Serializer.prototype.getStruct = function(self) 
  local pos = (function() 
  local _hx_obj = self;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local _g = self.input.b[pos];
  if (_g) == 0 then 
    do return nil end;
  elseif (_g) == 1 then 
    do return self:getAnyRef() end;
  elseif (_g) == 2 then 
    local tmp = self.knownStructs;
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_1
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_1 = _hx_bit.bor(v1,-2147483648); else 
        _hx_1 = v1; end
        return _hx_1
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    do return tmp[v] end;
  elseif (_g) == 3 then 
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_2
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_2 = _hx_bit.bor(v1,-2147483648); else 
        _hx_2 = v1; end
        return _hx_2
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local len = v;
    local cname;
    if (len == 0) then 
      cname = nil;
    else
      len = len - 1;
      local s = self.input:getString(self.inPos, len);
      local cname1 = self;
      cname1.inPos = cname1.inPos + len;
      cname = s;
    end;
    local cl = Type.resolveClass(cname);
    if (cl == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string("Missing struct class ") .. Std.string(cname)),0);
    end;
    local s = Type.createEmptyInstance(cl);
    self.knownStructs:push(s);
    s:customUnserialize(self);
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    if (self.input.b[pos] ~= 255) then 
      _G.error(__haxe_Exception.thrown(Std.string("Invalid customUnserialize for ") .. Std.string(Std.string(s))),0);
    end;
    do return s end;else
  _G.error(__haxe_Exception.thrown("assert"),0); end;
end
__hxbit_Serializer.prototype.addObjRef = function(self,s) 
  local v = s.__uid;
  if ((v >= 0) and (v < 128)) then 
    self.out.b:push(v);
  else
    self.out.b:push(128);
    self.out:addInt32(v);
  end;
end
__hxbit_Serializer.prototype.getObjRef = function(self) 
  local pos = (function() 
  local _hx_obj = self;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local v = self.input.b[pos];
  if (v == 128) then 
    local _this = self.input;
    local pos = self.inPos;
    local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
    v = _hx_bit_clamp((function() 
      local _hx_1
      if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
      _hx_1 = _hx_bit.bor(v1,-2147483648); else 
      _hx_1 = v1; end
      return _hx_1
    end )());
    local tmp = self;
    tmp.inPos = tmp.inPos + 4;
  end;
  do return v end
end
__hxbit_Serializer.prototype.addAnyRef = function(self,s) 
  if (s == nil) then 
    self.out.b:push(0);
    do return end;
  end;
  if (self.remapObjs ~= nil) then 
    self:remap(s);
  end;
  self:addObjRef(s);
  local ret = self.refs.h[s.__uid];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  if (ret ~= nil) then 
    do return end;
  end;
  local k = s.__uid;
  local _this = self.refs;
  if (s == nil) then 
    _this.h[k] = __haxe_ds_IntMap.tnull;
  else
    _this.h[k] = s;
  end;
  local index = s:getCLID();
  self.usedClasses[index] = true;
  self.out.b:push(_hx_bit.arshift(index,8));
  self.out.b:push(_hx_bit.band(index,255));
  s:serialize(self);
end
__hxbit_Serializer.prototype.addKnownRef = function(self,s) 
  if (s == nil) then 
    self.out.b:push(0);
    do return end;
  end;
  if (self.remapObjs ~= nil) then 
    self:remap(s);
  end;
  self:addObjRef(s);
  local ret = self.refs.h[s.__uid];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  if (ret ~= nil) then 
    do return end;
  end;
  local k = s.__uid;
  local _this = self.refs;
  if (s == nil) then 
    _this.h[k] = __haxe_ds_IntMap.tnull;
  else
    _this.h[k] = s;
  end;
  local index = s:getCLID();
  self.usedClasses[index] = true;
  local clid = __hxbit_Serializer.CLIDS[index];
  if (clid ~= 0) then 
    self.out.b:push(_hx_bit.arshift(clid,8));
    self.out.b:push(_hx_bit.band(clid,255));
  end;
  s:serialize(self);
end
__hxbit_Serializer.prototype.getAnyRef = function(self) 
  local id = self:getObjRef();
  if (id == 0) then 
    do return nil end;
  end;
  local ret = self.refs.h[id];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  if (ret ~= nil) then 
    local ret = self.refs.h[id];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    do return ret end;
  end;
  local rid = _hx_bit.band(id,16777215);
  if (__hxbit_Serializer.UID < rid) then 
    __hxbit_Serializer.UID = rid;
  end;
  local pos = (function() 
  local _hx_obj = self;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local clidx = _hx_bit.lshift(self.input.b[pos],8);
  local pos = (function() 
  local _hx_obj = self;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local clidx = _hx_bit.bor(clidx,self.input.b[pos]);
  if (self.mapIndexes ~= nil) then 
    clidx = self.mapIndexes[clidx];
  end;
  local i = Type.createEmptyInstance(__hxbit_Serializer.CLASSES[clidx]);
  if (self.newObjects ~= nil) then 
    self.newObjects:push(i);
  end;
  i.__uid = id;
  i:unserializeInit();
  local _this = self.refs;
  if (i == nil) then 
    _this.h[id] = __haxe_ds_IntMap.tnull;
  else
    _this.h[id] = i;
  end;
  if ((self.convert ~= nil) and (self.convert[clidx] ~= nil)) then 
    self:convertRef(i, self.convert[clidx]);
  else
    i:unserialize(self);
  end;
  do return i end
end
__hxbit_Serializer.prototype.getRef = function(self,c,clidx) 
  local id = self:getObjRef();
  if (id == 0) then 
    do return nil end;
  end;
  local ret = self.refs.h[id];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  if (ret ~= nil) then 
    local ret = self.refs.h[id];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    do return ret end;
  end;
  local rid = _hx_bit.band(id,16777215);
  if (__hxbit_Serializer.UID < rid) then 
    __hxbit_Serializer.UID = rid;
  end;
  if ((self.convert ~= nil) and (self.convert[clidx] ~= nil)) then 
    local conv = self.convert[clidx];
    if (conv.hadCID) then 
      local pos = (function() 
      local _hx_obj = self;
      local _hx_fld = 'inPos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local realIdx = _hx_bit.lshift(self.input.b[pos],8);
      local pos = (function() 
      local _hx_obj = self;
      local _hx_fld = 'inPos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      if (conv.hasCID) then 
        c = __hxbit_Serializer.CL_BYID[_hx_bit.bor(realIdx,self.input.b[pos])];
        clidx = c.__clid;
      end;
    end;
  else
    if (__hxbit_Serializer.CLIDS[clidx] ~= 0) then 
      local pos = (function() 
      local _hx_obj = self;
      local _hx_fld = 'inPos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local realIdx = _hx_bit.lshift(self.input.b[pos],8);
      local pos = (function() 
      local _hx_obj = self;
      local _hx_fld = 'inPos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      c = __hxbit_Serializer.CL_BYID[_hx_bit.bor(realIdx,self.input.b[pos])];
      if (self.convert ~= nil) then 
        clidx = c.__clid;
      end;
    end;
  end;
  local i = Type.createEmptyInstance(c);
  if (self.newObjects ~= nil) then 
    self.newObjects:push(i);
  end;
  i.__uid = id;
  i:unserializeInit();
  local _this = self.refs;
  if (i == nil) then 
    _this.h[id] = __haxe_ds_IntMap.tnull;
  else
    _this.h[id] = i;
  end;
  if ((self.convert ~= nil) and (self.convert[clidx] ~= nil)) then 
    self:convertRef(i, self.convert[clidx]);
  else
    i:unserialize(self);
  end;
  do return i end
end
__hxbit_Serializer.prototype.convertRef = function(self,i,c) 
  local length = c.read.length;
  local values = ({length = length});
  local _g = 0;
  local _g1 = c.read;
  while (_g < _g1.length) do 
    local r = _g1[_g];
    _g = _g + 1;
    values[r.index] = self:readValue(r.from);
  end;
  local oldOut = self.out;
  self.out = __haxe_io_BytesBuffer.new();
  local _g = 0;
  local _g1 = c.write;
  while (_g < _g1.length) do 
    local w = _g1[_g];
    _g = _g + 1;
    local v;
    if (w.from == nil) then 
      v = w.defaultValue;
    else
      v = values[w.index];
      if (not w.same) then 
        if (v == nil) then 
          v = w.defaultValue;
        else
          if (w.conv ~= nil) then 
            v = w:conv(v);
          else
            v = self:convertValue(w.path, v, w.from, w.to);
          end;
        end;
      end;
    end;
    self:writeValue(v, w.to);
  end;
  local bytes = self.out:getBytes();
  self.out = oldOut;
  local oldIn = self.input;
  local oldPos = self.inPos;
  self:setInput(bytes, 0);
  i:unserialize(self);
  self:setInput(oldIn, oldPos);
end
__hxbit_Serializer.prototype.isNullable = function(self,t) 
  local tmp = t[1];
  if (tmp) == 0 or (tmp) == 1 or (tmp) == 2 then 
    do return false end;else
  do return true end; end;
end
__hxbit_Serializer.prototype.convertValue = function(self,path,v,from,to) 
  if (v == nil) then 
    do return __hxbit_Convert.getDefault(to) end;
  end;
  if (__hxbit_Convert.sameType(from, to)) then 
    do return v end;
  end;
  local ret = __hxbit_Convert.convFuns.h[path];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local conv = ret;
  if (conv ~= nil) then 
    do return conv(v) end;
  end;
  local tmp = from[1];
  if (tmp) == 0 then 
    local tmp = to[1];
    if (tmp) == 1 then 
      do return v * 1.0 end;
    elseif (tmp) == 10 then 
      do return self:convertValue(path, v, from, to[2]) end;
    elseif (tmp) == 12 then 
      do return self:convertValue(path, v, from, to[2]) end;else end;
  elseif (tmp) == 1 then 
    local tmp = to[1];
    if (tmp) == 0 then 
      do return Std.int(v) end;
    elseif (tmp) == 10 then 
      do return self:convertValue(path, v, from, to[2]) end;
    elseif (tmp) == 12 then 
      do return self:convertValue(path, v, from, to[2]) end;else end;
  elseif (tmp) == 2 then 
    local tmp = to[1];
    if (tmp) == 0 then 
      if (v) then 
        do return 1 end;
      else
        do return 0 end;
      end;
    elseif (tmp) == 1 then 
      if (v) then 
        do return 1. end;
      else
        do return 0. end;
      end;
    elseif (tmp) == 10 then 
      do return self:convertValue(path, v, from, to[2]) end;
    elseif (tmp) == 12 then 
      do return self:convertValue(path, v, from, to[2]) end;else end;
  elseif (tmp) == 5 then 
    local tmp = to[1];
    if (tmp) == 5 then 
      local v2 = (function() 
        local _hx_1
        if (__lua_Boot.__instanceof(v, Type.resolveClass(to[2]))) then 
        _hx_1 = v; else 
        _hx_1 = nil; end
        return _hx_1
      end )();
      if (v2 ~= nil) then 
        do return v2 end;
      end;
    elseif (tmp) == 10 then 
      do return self:convertValue(path, v, from, to[2]) end;
    elseif (tmp) == 12 then 
      do return self:convertValue(path, v, from, to[2]) end;else end;
  elseif (tmp) == 8 then 
    local _g = from[2];
    local tmp = to[1];
    if (tmp) == 8 then 
      local _g1 = to[2];
      local arr = v;
      local _g2 = _hx_tab_array({}, 0);
      local _g3 = 0;
      while (_g3 < arr.length) do 
        local v = arr[_g3];
        _g3 = _g3 + 1;
        _g2:push(self:convertValue(Std.string(path) .. Std.string("[]"), v, _g, _g1));
      end;
      do return _g2 end;
    elseif (tmp) == 10 then 
      do return self:convertValue(path, v, from, to[2]) end;
    elseif (tmp) == 12 then 
      do return self:convertValue(path, v, from, to[2]) end;else end;
  elseif (tmp) == 9 then 
    local _g = from[2];
    local tmp = to[1];
    if (tmp) == 9 then 
      local _g1 = to[2];
      local v2 = _hx_e();
      local _g2 = 0;
      local _hx_continue_1 = false;
      while (_g2 < _g1.length) do repeat 
        local f = _g1[_g2];
        _g2 = _g2 + 1;
        local found = false;
        local field = nil;
        local _g1 = 0;
        while (_g1 < _g.length) do 
          local f2 = _g[_g1];
          _g1 = _g1 + 1;
          if (f2.name == f.name) then 
            found = true;
            field = self:convertValue(Std.string(Std.string(path) .. Std.string(".")) .. Std.string(f2.name), Reflect.field(v, f2.name), f2.type, f.type);
            break;
          end;
        end;
        if (not found) then 
          if (f.opt) then 
            break;
          end;
          field = __hxbit_Convert.getDefault(f.type);
        else
          if ((field == nil) and f.opt) then 
            break;
          end;
        end;
        v2[f.name] = field;until true
        if _hx_continue_1 then 
        _hx_continue_1 = false;
        break;
        end;
        
      end;
      do return v2 end;
    elseif (tmp) == 10 then 
      do return self:convertValue(path, v, from, to[2]) end;
    elseif (tmp) == 12 then 
      do return self:convertValue(path, v, from, to[2]) end;else end;
  elseif (tmp) == 10 then 
    local _g = from[2];
    local tmp = to[1];
    if (tmp) == 10 then 
      do return self:convertValue(path, v, _g, to) end;
    elseif (tmp) == 12 then 
      do return self:convertValue(path, v, from, to[2]) end;else
    do return self:convertValue(path, v, _g, to) end; end;
  elseif (tmp) == 12 then 
    do return self:convertValue(path, v, from[2], to) end;else
  local tmp = to[1];
  if (tmp) == 10 then 
    do return self:convertValue(path, v, from, to[2]) end;
  elseif (tmp) == 12 then 
    do return self:convertValue(path, v, from, to[2]) end;else end; end;
  _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("Cannot convert ") .. Std.string(path)) .. Std.string("(")) .. Std.string(Std.string(v))) .. Std.string(") from ")) .. Std.string(Std.string(from))) .. Std.string(" to ")) .. Std.string(Std.string(to))),0);
end
__hxbit_Serializer.prototype.getEnumClass = function(self,name) 
  local ret = __hxbit_Serializer.ENUM_CLASSES.h[name];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local cl = ret;
  local cl1 = cl;
  if (cl ~= nil) then 
    do return cl end;
  end;
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do 
    local newidx = 0;
    if (#"." > 0) then 
      newidx = _G.string.find(name, ".", idx, true);
    else
      if (idx >= #name) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      ret:push(_G.string.sub(name, idx, newidx - 1));
      idx = newidx + #".";
    else
      ret:push(_G.string.sub(name, idx, #name));
      idx = nil;
    end;
  end;
  local path = ret:join("_");
  local path1 = _G.string.upper(_G.string.sub(path, 1, 1));
  local len = nil;
  len = #path;
  path = Std.string(path1) .. Std.string(_G.string.sub(path, 2, 1 + len));
  cl1 = Type.resolveClass(Std.string("hxbit.enumSer.") .. Std.string(path));
  if (cl1 ~= nil) then 
    local _this = __hxbit_Serializer.ENUM_CLASSES;
    if (cl1 == nil) then 
      _this.h[name] = __haxe_ds_StringMap.tnull;
    else
      _this.h[name] = cl1;
    end;
  end;
  do return cl1 end
end
__hxbit_Serializer.prototype.readValue = function(self,t) 
  local _gthis = self;
  local tmp = t[1];
  if (tmp) == 0 then 
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_1
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_1 = _hx_bit.bor(v1,-2147483648); else 
        _hx_1 = v1; end
        return _hx_1
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    do return v end;
  elseif (tmp) == 1 then 
    local v = self.input:getFloat(self.inPos);
    local tmp = self;
    tmp.inPos = tmp.inPos + 4;
    do return v end;
  elseif (tmp) == 2 then 
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    do return self.input.b[pos] ~= 0 end;
  elseif (tmp) == 3 then 
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_2
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_2 = _hx_bit.bor(v1,-2147483648); else 
        _hx_2 = v1; end
        return _hx_2
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local len = v;
    if (len == 0) then 
      do return nil end;
    else
      len = len - 1;
      local s = self.input:getString(self.inPos, len);
      local tmp = self;
      tmp.inPos = tmp.inPos + len;
      do return s end;
    end;
  elseif (tmp) == 4 then 
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_3
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_3 = _hx_bit.bor(v1,-2147483648); else 
        _hx_3 = v1; end
        return _hx_3
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local len = v;
    if (len == 0) then 
      do return nil end;
    else
      len = len - 1;
      local s = self.input:sub(self.inPos, len);
      local tmp = self;
      tmp.inPos = tmp.inPos + len;
      do return s end;
    end;
  elseif (tmp) == 5 then 
    local c = Type.resolveClass(t[2]);
    do return self:getRef(c, c.__clid) end;
  elseif (tmp) == 6 then 
    local name = t[2];
    local ser = self:getEnumClass(name);
    if (ser == nil) then 
      local e = Type.resolveEnum(name);
      local tmp;
      if (e ~= nil) then 
        local o = __haxe_rtti_Meta.getType(e);
        tmp = (function() 
          local _hx_4
          if ((_G.type(o) == "string") and (String.prototype.skipSerialize ~= nil)) then 
          _hx_4 = true; elseif (o.__fields__ ~= nil) then 
          _hx_4 = o.__fields__.skipSerialize ~= nil; else 
          _hx_4 = o.skipSerialize ~= nil; end
          return _hx_4
        end )();
      else
        tmp = false;
      end;
      if (tmp) then 
        local pos = (function() 
        local _hx_obj = self;
        local _hx_fld = 'inPos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        local v = self.input.b[pos];
        if (v == 128) then 
          local _this = self.input;
          local pos = self.inPos;
          local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
          v = _hx_bit_clamp((function() 
            local _hx_5
            if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
            _hx_5 = _hx_bit.bor(v1,-2147483648); else 
            _hx_5 = v1; end
            return _hx_5
          end )());
          local tmp = self;
          tmp.inPos = tmp.inPos + 4;
        end;
        do return nil end;
      end;
      _G.error(__haxe_Exception.thrown(Std.string("No enum unserializer found for ") .. Std.string(name)),0);
    end;
    do return ser:doUnserialize(self) end;
  elseif (tmp) == 7 then 
    local v = t[3];
    local k = t[2];
    local tmp = k[1];
    if (tmp) == 0 then 
      local pos = (function() 
      local _hx_obj = self;
      local _hx_fld = 'inPos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local v1 = self.input.b[pos];
      if (v1 == 128) then 
        local _this = self.input;
        local pos = self.inPos;
        local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
        v1 = _hx_bit_clamp((function() 
          local _hx_6
          if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
          _hx_6 = _hx_bit.bor(v,-2147483648); else 
          _hx_6 = v; end
          return _hx_6
        end )());
        local tmp = self;
        tmp.inPos = tmp.inPos + 4;
      end;
      local len = v1;
      local tmp;
      if (len == 0) then 
        tmp = nil;
      else
        local m = __haxe_ds_IntMap.new();
        while (true) do 
          len = len - 1;
          if (not (len > 0)) then 
            break;
          end;
          local k = _gthis:readValue(k);
          local v = _gthis:readValue(v);
          if (v == nil) then 
            m.h[k] = __haxe_ds_IntMap.tnull;
          else
            m.h[k] = v;
          end;
        end;
        tmp = m;
      end;
      do return tmp end;
    elseif (tmp) == 3 then 
      local pos = (function() 
      local _hx_obj = self;
      local _hx_fld = 'inPos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local v1 = self.input.b[pos];
      if (v1 == 128) then 
        local _this = self.input;
        local pos = self.inPos;
        local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
        v1 = _hx_bit_clamp((function() 
          local _hx_7
          if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
          _hx_7 = _hx_bit.bor(v,-2147483648); else 
          _hx_7 = v; end
          return _hx_7
        end )());
        local tmp = self;
        tmp.inPos = tmp.inPos + 4;
      end;
      local len = v1;
      local tmp;
      if (len == 0) then 
        tmp = nil;
      else
        local m = __haxe_ds_StringMap.new();
        while (true) do 
          len = len - 1;
          if (not (len > 0)) then 
            break;
          end;
          local k = _gthis:readValue(k);
          local v = _gthis:readValue(v);
          if (v == nil) then 
            m.h[k] = __haxe_ds_StringMap.tnull;
          else
            m.h[k] = v;
          end;
        end;
        tmp = m;
      end;
      do return tmp end;
    elseif (tmp) == 6 then 
      local pos = (function() 
      local _hx_obj = self;
      local _hx_fld = 'inPos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local v1 = self.input.b[pos];
      if (v1 == 128) then 
        local _this = self.input;
        local pos = self.inPos;
        local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
        v1 = _hx_bit_clamp((function() 
          local _hx_8
          if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
          _hx_8 = _hx_bit.bor(v,-2147483648); else 
          _hx_8 = v; end
          return _hx_8
        end )());
        local tmp = self;
        tmp.inPos = tmp.inPos + 4;
      end;
      local len = v1;
      if (len == 0) then 
        do return nil end;
      end;
      local m = __haxe_ds_EnumValueMap.new();
      while (true) do 
        len = len - 1;
        if (not (len > 0)) then 
          break;
        end;
        m:set(self:readValue(k), self:readValue(v));
      end;
      do return m end;else
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v1 = self.input.b[pos];
    if (v1 == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v1 = _hx_bit_clamp((function() 
        local _hx_9
        if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
        _hx_9 = _hx_bit.bor(v,-2147483648); else 
        _hx_9 = v; end
        return _hx_9
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local len = v1;
    local tmp;
    if (len == 0) then 
      tmp = nil;
    else
      local m = __haxe_ds_ObjectMap.new();
      while (true) do 
        len = len - 1;
        if (not (len > 0)) then 
          break;
        end;
        local k = _gthis:readValue(k);
        local v = _gthis:readValue(v);
        m.h[k] = v;
        m.k[k] = true;
      end;
      tmp = m;
    end;
    do return tmp end; end;
  elseif (tmp) == 8 then 
    local t = t[2];
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_10
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_10 = _hx_bit.bor(v1,-2147483648); else 
        _hx_10 = v1; end
        return _hx_10
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local len = v;
    if (len == 0) then 
      do return nil end;
    else
      len = len - 1;
      local a = _hx_tab_array({}, 0);
      local _g = 0;
      local _g1 = len;
      while (_g < _g1) do 
        _g = _g + 1;
        a[_g - 1] = _gthis:readValue(t);
      end;
      do return a end;
    end;
  elseif (tmp) == 9 then 
    local fields = t[2];
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_11
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_11 = _hx_bit.bor(v1,-2147483648); else 
        _hx_11 = v1; end
        return _hx_11
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local bits = v;
    if (bits == 0) then 
      do return nil end;
    end;
    local o = _hx_e();
    bits = bits - 1;
    local _g = _hx_tab_array({}, 0);
    local _g1 = 0;
    while (_g1 < fields.length) do 
      local f = fields[_g1];
      _g1 = _g1 + 1;
      if (self:isNullable(f.type)) then 
        _g:push(f);
      end;
    end;
    local nullables = _g;
    local _g = 0;
    local _hx_continue_1 = false;
    while (_g < fields.length) do repeat 
      local f = fields[_g];
      _g = _g + 1;
      local nidx = nullables:indexOf(f);
      if ((nidx >= 0) and ((_hx_bit.band(bits,_hx_bit.lshift(1,nidx))) == 0)) then 
        break;
      end;
      o[f.name] = self:readValue(f.type);until true
      if _hx_continue_1 then 
      _hx_continue_1 = false;
      break;
      end;
      
    end;
    do return o end;
  elseif (tmp) == 10 then 
    do return self:readValue(t[2]) end;
  elseif (tmp) == 11 then 
    local t = t[2];
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_12
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_12 = _hx_bit.bor(v1,-2147483648); else 
        _hx_12 = v1; end
        return _hx_12
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    local len = v;
    if (len == 0) then 
      do return nil end;
    else
      len = len - 1;
      local a = ({length = len});
      local _g = 0;
      local _g1 = len;
      while (_g < _g1) do 
        _g = _g + 1;
        a[_g - 1] = _gthis:readValue(t);
      end;
      do return a end;
    end;
  elseif (tmp) == 12 then 
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    if (self.input.b[pos] == 0) then 
      do return nil end;
    else
      do return self:readValue(t[2]) end;
    end;
  elseif (tmp) == 13 then 
    _G.error(__haxe_Exception.thrown("assert"),0);
  elseif (tmp) == 14 then 
    do return self:getDynamic() end;
  elseif (tmp) == 15 then 
    local _this = self.input;
    local pos = self.inPos;
    local pos1 = pos + 4;
    local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos1],_hx_bit.lshift(_this.b[pos1 + 1],8)),_hx_bit.lshift(_this.b[pos1 + 2],16)),_hx_bit.lshift(_this.b[pos1 + 3],24));
    local high = _hx_bit_clamp((function() 
      local _hx_13
      if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
      _hx_13 = _hx_bit.bor(v,-2147483648); else 
      _hx_13 = v; end
      return _hx_13
    end )());
    local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
    local this1 = __haxe__Int64____Int64.new(high, _hx_bit_clamp((function() 
      local _hx_14
      if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
      _hx_14 = _hx_bit.bor(v,-2147483648); else 
      _hx_14 = v; end
      return _hx_14
    end )()));
    local tmp = self;
    tmp.inPos = tmp.inPos + 8;
    do return this1 end;
  elseif (tmp) == 16 then 
    local pos = (function() 
    local _hx_obj = self;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = self.input.b[pos];
    if (v == 128) then 
      local _this = self.input;
      local pos = self.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_15
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_15 = _hx_bit.bor(v1,-2147483648); else 
        _hx_15 = v1; end
        return _hx_15
      end )());
      local tmp = self;
      tmp.inPos = tmp.inPos + 4;
    end;
    do return v end;
  elseif (tmp) == 17 then 
    do return self:getStruct() end; end;
end
__hxbit_Serializer.prototype.writeValue = function(self,v,t) 
  local _gthis = self;
  local tmp = t[1];
  if (tmp) == 0 then 
    local v = v;
    if ((v >= 0) and (v < 128)) then 
      self.out.b:push(v);
    else
      self.out.b:push(128);
      self.out:addInt32(v);
    end;
  elseif (tmp) == 1 then 
    self.out:addInt32(__haxe_io_FPHelper.floatToI32(v));
  elseif (tmp) == 2 then 
    self.out.b:push((function() 
      local _hx_1
      if (v) then 
      _hx_1 = 1; else 
      _hx_1 = 0; end
      return _hx_1
    end )());
  elseif (tmp) == 3 then 
    local s = v;
    if (s == nil) then 
      self.out.b:push(0);
    else
      local b = __haxe_io_Bytes.ofString(s);
      local v = b.length + 1;
      if ((v >= 0) and (v < 128)) then 
        self.out.b:push(v);
      else
        self.out.b:push(128);
        self.out:addInt32(v);
      end;
      local _this = self.out;
      local b2 = b.b;
      local _g = 0;
      local _g1 = b.length;
      while (_g < _g1) do 
        _g = _g + 1;
        _this.b:push(b2[_g - 1]);
      end;
    end;
  elseif (tmp) == 4 then 
    local b = v;
    if (b == nil) then 
      self.out.b:push(0);
    else
      local v = b.length + 1;
      if ((v >= 0) and (v < 128)) then 
        self.out.b:push(v);
      else
        self.out.b:push(128);
        self.out:addInt32(v);
      end;
      local _this = self.out;
      local b2 = b.b;
      local _g = 0;
      local _g1 = b.length;
      while (_g < _g1) do 
        _g = _g + 1;
        _this.b:push(b2[_g - 1]);
      end;
    end;
  elseif (tmp) == 5 then 
    self:addKnownRef(v);
  elseif (tmp) == 6 then 
    local _g = t[2];
    local ser = self:getEnumClass(_g);
    if (ser == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string("No enum unserializer found for ") .. Std.string(_g)),0);
    end;
    ser:doSerialize(self, v);
  elseif (tmp) == 7 then 
    local _g = t[3];
    local _g1 = t[2];
    local tmp = _g1[1];
    if (tmp) == 0 then 
      local v = v;
      if (v == nil) then 
        self.out.b:push(0);
      else
        local _g2 = _hx_tab_array({}, 0);
        local k = v:keys();
        while (k:hasNext()) do 
          _g2:push(k:next());
        end;
        local v1 = _g2.length + 1;
        if ((v1 >= 0) and (v1 < 128)) then 
          self.out.b:push(v1);
        else
          self.out.b:push(128);
          self.out:addInt32(v1);
        end;
        local _g3 = 0;
        while (_g3 < _g2.length) do 
          local k = _g2[_g3];
          _g3 = _g3 + 1;
          _gthis:writeValue(k, _g1);
          local ret = v.h[k];
          if (ret == __haxe_ds_IntMap.tnull) then 
            ret = nil;
          end;
          _gthis:writeValue(ret, _g);
        end;
      end;
    elseif (tmp) == 3 then 
      local v = v;
      if (v == nil) then 
        self.out.b:push(0);
      else
        local _g2 = _hx_tab_array({}, 0);
        local k = v:keys();
        while (k:hasNext()) do 
          _g2:push(k:next());
        end;
        local v1 = _g2.length + 1;
        if ((v1 >= 0) and (v1 < 128)) then 
          self.out.b:push(v1);
        else
          self.out.b:push(128);
          self.out:addInt32(v1);
        end;
        local _g3 = 0;
        while (_g3 < _g2.length) do 
          local k = _g2[_g3];
          _g3 = _g3 + 1;
          _gthis:writeValue(k, _g1);
          local ret = v.h[k];
          if (ret == __haxe_ds_StringMap.tnull) then 
            ret = nil;
          end;
          _gthis:writeValue(ret, _g);
        end;
      end;
    elseif (tmp) == 6 then 
      local v = v;
      if (v == nil) then 
        self.out.b:push(0);
        do return end;
      end;
      local _g2 = _hx_tab_array({}, 0);
      local k = v:keys();
      while (k:hasNext()) do 
        _g2:push(k:next());
      end;
      local v1 = _g2.length + 1;
      if ((v1 >= 0) and (v1 < 128)) then 
        self.out.b:push(v1);
      else
        self.out.b:push(128);
        self.out:addInt32(v1);
      end;
      local _g3 = 0;
      while (_g3 < _g2.length) do 
        local vk = _g2[_g3];
        _g3 = _g3 + 1;
        self:writeValue(vk, _g1);
        self:writeValue(v:get(vk), _g);
      end;else
    local v = v;
    if (v == nil) then 
      self.out.b:push(0);
    else
      local _g2 = _hx_tab_array({}, 0);
      local k = v:keys();
      while (k:hasNext()) do 
        _g2:push(k:next());
      end;
      local v1 = _g2.length + 1;
      if ((v1 >= 0) and (v1 < 128)) then 
        self.out.b:push(v1);
      else
        self.out.b:push(128);
        self.out:addInt32(v1);
      end;
      local _g3 = 0;
      while (_g3 < _g2.length) do 
        local k = _g2[_g3];
        _g3 = _g3 + 1;
        _gthis:writeValue(k, _g1);
        _gthis:writeValue(v.h[k], _g);
      end;
    end; end;
  elseif (tmp) == 8 then 
    local _g = t[2];
    local a = v;
    if (a == nil) then 
      self.out.b:push(0);
    else
      local v = a.length + 1;
      if ((v >= 0) and (v < 128)) then 
        self.out.b:push(v);
      else
        self.out.b:push(128);
        self.out:addInt32(v);
      end;
      local _g1 = 0;
      while (_g1 < a.length) do 
        local v = a[_g1];
        _g1 = _g1 + 1;
        _gthis:writeValue(v, _g);
      end;
    end;
  elseif (tmp) == 9 then 
    local _g = t[2];
    if (v == nil) then 
      self.out.b:push(0);
    else
      local fbits = 0;
      local _g1 = _hx_tab_array({}, 0);
      local _g2 = 0;
      while (_g2 < _g.length) do 
        local f = _g[_g2];
        _g2 = _g2 + 1;
        if (self:isNullable(f.type)) then 
          _g1:push(f);
        end;
      end;
      local _g2 = 0;
      local _g3 = _g1.length;
      while (_g2 < _g3) do 
        _g2 = _g2 + 1;
        local i = _g2 - 1;
        if (Reflect.field(v, _g1[i].name) ~= nil) then 
          fbits = _hx_bit.bor(fbits,_hx_bit.lshift(1,i));
        end;
      end;
      local v1 = fbits + 1;
      if ((v1 >= 0) and (v1 < 128)) then 
        self.out.b:push(v1);
      else
        self.out.b:push(128);
        self.out:addInt32(v1);
      end;
      local _g2 = 0;
      local _hx_continue_1 = false;
      while (_g2 < _g.length) do repeat 
        local f = _g[_g2];
        _g2 = _g2 + 1;
        local nidx = _g1:indexOf(f);
        if ((nidx >= 0) and ((_hx_bit.band(fbits,_hx_bit.lshift(1,nidx))) == 0)) then 
          break;
        end;
        self:writeValue(Reflect.field(v, f.name), f.type);until true
        if _hx_continue_1 then 
        _hx_continue_1 = false;
        break;
        end;
        
      end;
    end;
  elseif (tmp) == 10 then 
    self:writeValue(v, t[2]);
  elseif (tmp) == 11 then 
    local _g = t[2];
    local a = v;
    if (a == nil) then 
      self.out.b:push(0);
    else
      local v = a.length + 1;
      if ((v >= 0) and (v < 128)) then 
        self.out.b:push(v);
      else
        self.out.b:push(128);
        self.out:addInt32(v);
      end;
      local _g1 = 0;
      while (_g1 < a.length) do 
        local v = a[_g1];
        _g1 = _g1 + 1;
        _gthis:writeValue(v, _g);
      end;
    end;
  elseif (tmp) == 12 then 
    if (v == nil) then 
      self.out.b:push(0);
    else
      self.out.b:push(1);
      self:writeValue(v, t[2]);
    end;
  elseif (tmp) == 13 then 
    _G.error(__haxe_Exception.thrown("assert"),0);
  elseif (tmp) == 14 then 
    self:addDynamic(v);
  elseif (tmp) == 15 then 
    self.out:addInt64(v);
  elseif (tmp) == 16 then 
    local v = v;
    if ((v >= 0) and (v < 128)) then 
      self.out.b:push(v);
    else
      self.out.b:push(128);
      self.out:addInt32(v);
    end;
  elseif (tmp) == 17 then 
    self:addStruct(v); end;
end

__hxbit_Serializer.prototype.__class__ =  __hxbit_Serializer

__deceptinfect_TestObject.new = function() 
  local self = _hx_new(__deceptinfect_TestObject.prototype)
  __deceptinfect_TestObject.super(self)
  return self
end
__deceptinfect_TestObject.super = function(self) 
  self.__uid = _hx_bit.bor(_hx_bit.lshift(__hxbit_Serializer.SEQ,24),(function() 
  local _hx_obj = __hxbit_Serializer;
  local _hx_fld = 'UID';
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _hx_obj[_hx_fld];
   end)());
  self.__bits = 0;
  self:networkInitProxys();
  self:set_enableReplication(true);
end
_hx_exports["testobj"] = __deceptinfect_TestObject
_hxClasses["deceptinfect.TestObject"] = __deceptinfect_TestObject
__deceptinfect_TestObject.__name__ = "deceptinfect.TestObject"
__deceptinfect_TestObject.__interfaces__ = {__hxbit_NetworkSerializable}
__deceptinfect_TestObject.prototype = _hx_e();
__deceptinfect_TestObject.prototype.clientFunction__impl = function(self) 
  __haxe_Log.trace("Remote procedure call", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/TestObject.hx",lineNumber=18,className="deceptinfect.TestObject",methodName="clientFunction__impl"}));
end
__deceptinfect_TestObject.prototype.networkAllow = function(self,op,propId,client) 
  do return client == self end
end
__deceptinfect_TestObject.prototype.alive = function(self) 
  __deceptinfect_TestObject.inst = self;
  __haxe_Log.trace("I am... alive!", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/TestObject.hx",lineNumber=35,className="deceptinfect.TestObject",methodName="alive"}));
end
__deceptinfect_TestObject.prototype.networkSetBit = function(self,b) 
  if (((self.__host ~= nil) and (self.__host.isAuth or self.__host:checkWrite(self, b))) and ((self.__next ~= nil) or self.__host:mark(self))) then 
    local tmp = self;
    tmp.__bits = _hx_bit.bor(tmp.__bits,_hx_bit.lshift(1,b));
  end;
end
__deceptinfect_TestObject.prototype.get_enableReplication = function(self) 
  do return self.__host ~= nil end
end
__deceptinfect_TestObject.prototype.set_enableReplication = function(self,b) 
  __hxbit_NetworkHost.enableReplication(self, b);
  do return b end
end
__deceptinfect_TestObject.prototype.networkCancelProperty = function(self,props) 
  local tmp = self;
  tmp.__bits = _hx_bit.band(tmp.__bits,_hx_bit.bnot(props));
end
__deceptinfect_TestObject.prototype.networkLocalChange = function(self,f) 
  local old = self.__host;
  self.__host = nil;
  f();
  self.__host = old;
end
__deceptinfect_TestObject.prototype.__net_mark_testplayer = function(self,v) 
  if (self.testplayer ~= v) then 
    if (((self.__host ~= nil) and (self.__host.isAuth or self.__host:checkWrite(self, 0))) and ((self.__next ~= nil) or self.__host:mark(self))) then 
      local tmp = self;
      tmp.__bits = _hx_bit.bor(tmp.__bits,1);
    end;
  end;
  do return v end
end
__deceptinfect_TestObject.prototype.set_testplayer = function(self,v) 
  if (self.testplayer ~= v) then 
    if (((self.__host ~= nil) and (self.__host.isAuth or self.__host:checkWrite(self, 0))) and ((self.__next ~= nil) or self.__host:mark(self))) then 
      local tmp = self;
      tmp.__bits = _hx_bit.bor(tmp.__bits,1);
    end;
  end;
  self.testplayer = v do return self.testplayer end
end
__deceptinfect_TestObject.prototype.get_networkPropTestplayer = function(self) 
  do return 1 end
end
__deceptinfect_TestObject.prototype.__net_mark_testString = function(self,v) 
  if (self.testString ~= v) then 
    if (((self.__host ~= nil) and (self.__host.isAuth or self.__host:checkWrite(self, 1))) and ((self.__next ~= nil) or self.__host:mark(self))) then 
      local tmp = self;
      tmp.__bits = _hx_bit.bor(tmp.__bits,2);
    end;
  end;
  do return v end
end
__deceptinfect_TestObject.prototype.set_testString = function(self,v) 
  if (self.testString ~= v) then 
    if (((self.__host ~= nil) and (self.__host.isAuth or self.__host:checkWrite(self, 1))) and ((self.__next ~= nil) or self.__host:mark(self))) then 
      local tmp = self;
      tmp.__bits = _hx_bit.bor(tmp.__bits,2);
    end;
  end;
  self.testString = v do return self.testString end
end
__deceptinfect_TestObject.prototype.get_networkPropTestString = function(self) 
  do return 2 end
end
__deceptinfect_TestObject.prototype.clientFunction = function(self) 
  if ((self.__host ~= nil) and self.__host.isAuth) then 
    self.__host:beginRPC(self, 0, nil);
    self.__host:endRPC();
    do return end;
  end;
  self:clientFunction__impl();
end
__deceptinfect_TestObject.prototype.networkFlush = function(self,ctx) 
  local b = self.__bits;
  local v = self.__bits;
  if ((v >= 0) and (v < 128)) then 
    ctx.out.b:push(v);
  else
    ctx.out.b:push(128);
    ctx.out:addInt32(v);
  end;
  if ((_hx_bit.band(b,1)) ~= 0) then 
    local v = self.testplayer;
    if ((v >= 0) and (v < 128)) then 
      ctx.out.b:push(v);
    else
      ctx.out.b:push(128);
      ctx.out:addInt32(v);
    end;
  end;
  if ((_hx_bit.band(b,2)) ~= 0) then 
    local s = self.testString;
    if (s == nil) then 
      ctx.out.b:push(0);
    else
      local b = __haxe_io_Bytes.ofString(s);
      local v = b.length + 1;
      if ((v >= 0) and (v < 128)) then 
        ctx.out.b:push(v);
      else
        ctx.out.b:push(128);
        ctx.out:addInt32(v);
      end;
      local _this = ctx.out;
      local b2 = b.b;
      local _g = 0;
      local _g1 = b.length;
      while (_g < _g1) do 
        _g = _g + 1;
        _this.b:push(b2[_g - 1]);
      end;
    end;
  end;
  self.__bits = 0;
end
__deceptinfect_TestObject.prototype.networkSync = function(self,ctx) 
  if ((_hx_bit.band(self.__bits,1)) ~= 0) then 
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_1
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_1 = _hx_bit.bor(v1,-2147483648); else 
        _hx_1 = v1; end
        return _hx_1
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    self:set_testplayer(v);
  end;
  if ((_hx_bit.band(self.__bits,2)) ~= 0) then 
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_2
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_2 = _hx_bit.bor(v1,-2147483648); else 
        _hx_2 = v1; end
        return _hx_2
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local len = v;
    local tmp;
    if (len == 0) then 
      tmp = nil;
    else
      len = len - 1;
      local s = ctx.input:getString(ctx.inPos, len);
      local ctx = ctx;
      ctx.inPos = ctx.inPos + len;
      tmp = s;
    end;
    self:set_testString(tmp);
  end;
end
__deceptinfect_TestObject.prototype.networkInitProxys = function(self) 
end
__deceptinfect_TestObject.prototype.networkRPC = function(self,__ctx,__id,__clientResult) 
  if (__id == 0) then 
    if (__ctx:get_error()) then 
      do return false end;
    end;
    self:clientFunction__impl();
  else
    _G.error(__haxe_Exception.thrown(Std.string("Unknown RPC identifier ") .. Std.string(__id)),0);
  end;
  do return true end
end
__deceptinfect_TestObject.prototype.networkGetName = function(self,id,isRPC) 
  if (isRPC == nil) then 
    isRPC = false;
  end;
  local _g = (function() 
    local _hx_1
    if (isRPC) then 
    _hx_1 = id + 2; else 
    _hx_1 = id; end
    return _hx_1
  end )();
  if (_g) == 0 then 
    do return "testplayer" end;
  elseif (_g) == 1 then 
    do return "testString" end;
  elseif (_g) == 2 then 
    do return "clientFunction" end;else
  do return nil end; end;
end
__deceptinfect_TestObject.prototype.getCLID = function(self) 
  do return __deceptinfect_TestObject.__clid end
end
__deceptinfect_TestObject.prototype.serialize = function(self,__ctx) 
  local v = self.testplayer;
  if ((v >= 0) and (v < 128)) then 
    __ctx.out.b:push(v);
  else
    __ctx.out.b:push(128);
    __ctx.out:addInt32(v);
  end;
  local s = self.testString;
  if (s == nil) then 
    __ctx.out.b:push(0);
  else
    local b = __haxe_io_Bytes.ofString(s);
    local v = b.length + 1;
    if ((v >= 0) and (v < 128)) then 
      __ctx.out.b:push(v);
    else
      __ctx.out.b:push(128);
      __ctx.out:addInt32(v);
    end;
    local _this = __ctx.out;
    local b2 = b.b;
    local _g = 0;
    local _g1 = b.length;
    while (_g < _g1) do 
      _g = _g + 1;
      _this.b:push(b2[_g - 1]);
    end;
  end;
end
__deceptinfect_TestObject.prototype.getSerializeSchema = function(self) 
  local schema = __hxbit_Schema.new();
  schema.fieldsNames:push("testplayer");
  schema.fieldsTypes:push(__hxbit_PropTypeDesc.PInt);
  schema.fieldsNames:push("testString");
  schema.fieldsTypes:push(__hxbit_PropTypeDesc.PString);
  schema.isFinal = __hxbit_Serializer.isClassFinal(__deceptinfect_TestObject.__clid);
  do return schema end
end
__deceptinfect_TestObject.prototype.unserializeInit = function(self) 
  self.__bits = 0;
end
__deceptinfect_TestObject.prototype.unserialize = function(self,__ctx) 
  local pos = (function() 
  local _hx_obj = __ctx;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local v = __ctx.input.b[pos];
  if (v == 128) then 
    local _this = __ctx.input;
    local pos = __ctx.inPos;
    local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
    v = _hx_bit_clamp((function() 
      local _hx_1
      if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
      _hx_1 = _hx_bit.bor(v1,-2147483648); else 
      _hx_1 = v1; end
      return _hx_1
    end )());
    local __ctx = __ctx;
    __ctx.inPos = __ctx.inPos + 4;
  end;
  self:set_testplayer(v);
  local pos = (function() 
  local _hx_obj = __ctx;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local v = __ctx.input.b[pos];
  if (v == 128) then 
    local _this = __ctx.input;
    local pos = __ctx.inPos;
    local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
    v = _hx_bit_clamp((function() 
      local _hx_2
      if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
      _hx_2 = _hx_bit.bor(v1,-2147483648); else 
      _hx_2 = v1; end
      return _hx_2
    end )());
    local __ctx = __ctx;
    __ctx.inPos = __ctx.inPos + 4;
  end;
  local len = v;
  local tmp;
  if (len == 0) then 
    tmp = nil;
  else
    len = len - 1;
    local s = __ctx.input:getString(__ctx.inPos, len);
    local __ctx = __ctx;
    __ctx.inPos = __ctx.inPos + len;
    tmp = s;
  end;
  self:set_testString(tmp);
end

__deceptinfect_TestObject.prototype.__class__ =  __deceptinfect_TestObject

__deceptinfect_ecswip_Component.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_Component.prototype)
  __deceptinfect_ecswip_Component.super(self)
  return self
end
__deceptinfect_ecswip_Component.super = function(self) 
end
_hxClasses["deceptinfect.ecswip.Component"] = __deceptinfect_ecswip_Component
__deceptinfect_ecswip_Component.__name__ = "deceptinfect.ecswip.Component"
__deceptinfect_ecswip_Component.prototype = _hx_e();

__deceptinfect_ecswip_Component.prototype.__class__ =  __deceptinfect_ecswip_Component

__deceptinfect_ecswip_System.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_System.prototype)
  __deceptinfect_ecswip_System.super(self)
  return self
end
__deceptinfect_ecswip_System.super = function(self) 
end
_hxClasses["deceptinfect.ecswip.System"] = __deceptinfect_ecswip_System
__deceptinfect_ecswip_System.__name__ = "deceptinfect.ecswip.System"
__deceptinfect_ecswip_System.prototype = _hx_e();
__deceptinfect_ecswip_System.prototype.init_client = function(self) 
end
__deceptinfect_ecswip_System.prototype.run_client = function(self) 
end
__deceptinfect_ecswip_System.prototype.init_shared = function(self) 
end
__deceptinfect_ecswip_System.prototype.run_shared = function(self) 
end
__deceptinfect_ecswip_System.prototype.init = function(self) 
  self:init_client();
  self:init_shared();
end
__deceptinfect_ecswip_System.prototype.run = function(self) 
  self:run_client();
  self:run_shared();
end

__deceptinfect_ecswip_System.prototype.__class__ =  __deceptinfect_ecswip_System

__deceptinfect_client_ClientOverrides.new = function() 
  local self = _hx_new(__deceptinfect_client_ClientOverrides.prototype)
  __deceptinfect_client_ClientOverrides.super(self)
  return self
end
__deceptinfect_client_ClientOverrides.super = function(self) 
  GM.HUDPaint = function(GM,...) return self:HUDPaint(...) end;
  GM.NotifyShouldTransmit = function(GM,...) return self:NotifyShouldTransmit(...) end;
  GM.PlayerButtonDown = function(GM,...) return self:PlayerButtonDown(...) end;
  GM.PreDrawOpaqueRenderables = function(GM,...) return self:PreDrawOpaqueRenderables(...) end;
  GM.HUDDrawScoreBoard = function(GM,...) return self:HUDDrawScoreBoard(...) end;
  GM.HUDShouldDraw = function(GM,...) return self:HUDShouldDraw(...) end;
  self["self"] = GM;
  __deceptinfect_client_ClientOverrides.instance = self;
end
_hxClasses["deceptinfect.client.ClientOverrides"] = __deceptinfect_client_ClientOverrides
__deceptinfect_client_ClientOverrides.__name__ = "deceptinfect.client.ClientOverrides"
__deceptinfect_client_ClientOverrides.prototype = _hx_e();
__deceptinfect_client_ClientOverrides.prototype.HUDPaint = function(self) 
  __deceptinfect_client_Hud.paint();
end
__deceptinfect_client_ClientOverrides.prototype.NotifyShouldTransmit = function(self,ent,shouldtransmit) 
  local key = ent:EntIndex();
  local _this = __deceptinfect_client_PVS.pvs;
  if (shouldtransmit == nil) then 
    _this.h[key] = __haxe_ds_IntMap.tnull;
  else
    _this.h[key] = shouldtransmit;
  end;
  __deceptinfect_ecswip_SystemManager.getSystem(__deceptinfect_game_RagdollSystem):pvsChange(ent, shouldtransmit);
end
__deceptinfect_client_ClientOverrides.prototype.PlayerButtonDown = function(self,ply,button) 
  if (button == _G.KEY_L) then 
    local sab = __deceptinfect_client_SabotagePanel.get_inst();
    if (sab:IsVisible()) then 
      sab:SetVisible(false);
    else
      sab:SetVisible(true);
    end;
    sab:SetVisible(true);
  end;
end
__deceptinfect_client_ClientOverrides.prototype.PreDrawOpaqueRenderables = function(self,isDrawingDepth,isDrawSkybox) 
  __deceptinfect_ecswip_GrabSystem.drawCylinders();
  do return nil end
end
__deceptinfect_client_ClientOverrides.prototype.HUDDrawScoreBoard = function(self) 
  do return end
end
__deceptinfect_client_ClientOverrides.prototype.HUDShouldDraw = function(self,name) 
  if (name == "CHudDamageIndicator") then 
    do return false end;
  else
    do return true end;
  end;
end

__deceptinfect_client_ClientOverrides.prototype.__class__ =  __deceptinfect_client_ClientOverrides
__deceptinfect_client_ClientOverrides.__super__ = {} or a
setmetatable(__deceptinfect_client_ClientOverrides.prototype,{__index={} or a.prototype})

__deceptinfect_client_GeigerSystem.new = function() 
  local self = _hx_new(__deceptinfect_client_GeigerSystem.prototype)
  __deceptinfect_client_GeigerSystem.super(self)
  return self
end
__deceptinfect_client_GeigerSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hx_exports["geiger"] = __deceptinfect_client_GeigerSystem
_hxClasses["deceptinfect.client.GeigerSystem"] = __deceptinfect_client_GeigerSystem
__deceptinfect_client_GeigerSystem.__name__ = "deceptinfect.client.GeigerSystem"
__deceptinfect_client_GeigerSystem.geigerThink = function() 
  if ((_G.CurTime() > __deceptinfect_client_GeigerSystem.playTime) and (__deceptinfect_client_GeigerSystem.geiger > 0.016)) then 
    local x = __deceptinfect_client_GeigerSystem.geiger;
    local choice = (function() 
      local _hx_1
      if (x < 0.2) then 
      _hx_1 = __deceptinfect_client_GeigerSystem.sounds[0]; else 
      _hx_1 = __deceptinfect_client_GeigerSystem.sounds[_G.math.random(0, 2)]; end
      return _hx_1
    end )();
    local this1 = _G.Vector(0, 0, 0);
    _G.EmitSound(choice, this1, -2, _G.CHAN_STATIC, 0.5);
    local mintime = _G.SoundDuration(__deceptinfect_client_GeigerSystem.sounds[0]) * 0.75;
    local exponent = (0.5 * _G.math.pow(__deceptinfect_client_GeigerSystem.geiger, -0.5)) - 0.5;
    local random = math.random(0.5,1.1);
    local maxtime = 3;
    __deceptinfect_client_GeigerSystem.playTime = _G.math.min((_G.CurTime() + mintime) + (exponent * random), _G.CurTime() + maxtime);
  end;
end
__deceptinfect_client_GeigerSystem.prototype = _hx_e();
__deceptinfect_client_GeigerSystem.prototype.init_client = function(self) 
  __deceptinfect_client_GeigerSystem.net_geiger.signal:listen(function(data) 
    __deceptinfect_client_GeigerSystem.geiger = data.geiger;
  end);
  __deceptinfect_GameManager.stateChange:listen(function(x) 
    if (x[1] == 0) then 
      __deceptinfect_client_GeigerSystem.geiger = 0.0;
    end;
  end);
end
__deceptinfect_client_GeigerSystem.prototype.run_client = function(self) 
  __deceptinfect_client_GeigerSystem.geigerThink();
end

__deceptinfect_client_GeigerSystem.prototype.__class__ =  __deceptinfect_client_GeigerSystem
__deceptinfect_client_GeigerSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_client_GeigerSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})
_hxClasses["deceptinfect.client._Hud.Axis"] = __deceptinfect_client__Hud_Axis;
_hxClasses["deceptinfect.client._Hud.Axis"] = { __ename__ = "deceptinfect.client._Hud.Axis", __constructs__ = _hx_tab_array({[0]="X","Y"},2)}
__deceptinfect_client__Hud_Axis = _hxClasses["deceptinfect.client._Hud.Axis"];
__deceptinfect_client__Hud_Axis.X = _hx_tab_array({[0]="X",0,__enum__ = __deceptinfect_client__Hud_Axis},2)

__deceptinfect_client__Hud_Axis.Y = _hx_tab_array({[0]="Y",1,__enum__ = __deceptinfect_client__Hud_Axis},2)


__deceptinfect_client_Hud.new = {}
_hxClasses["deceptinfect.client.Hud"] = __deceptinfect_client_Hud
__deceptinfect_client_Hud.__name__ = "deceptinfect.client.Hud"
__deceptinfect_client_Hud.CSS = function(axis,req) 
  local map = __deceptinfect_client_Hud.cache:get(axis);
  if (not (map.h[req] ~= nil)) then 
    local multiplier = __deceptinfect_client_Hud.axisToMultiplier(axis);
    local result = _G.math.floor((req / __deceptinfect_client_Hud.baseReso:get(axis)) * multiplier);
    if (result == nil) then 
      map.h[req] = __haxe_ds_IntMap.tnull;
    else
      map.h[req] = result;
    end;
  end;
  local ret = map.h[req];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret end;
end
__deceptinfect_client_Hud.axisToMultiplier = function(axis) 
  local tmp = axis[1];
  if (tmp) == 0 then 
    do return _G.ScrW() end;
  elseif (tmp) == 1 then 
    do return _G.ScrH() end; end;
end
__deceptinfect_client_Hud.paint = function() 
  __deceptinfect_client_Hud.targetID();
  __deceptinfect_client_Hud.infectionMeter();
end
__deceptinfect_client_Hud.targetID = function() 
  local target = _G.LocalPlayer():GetEyeTrace().Entity;
  if (not _G.IsValid(target) or not target:IsPlayer()) then 
    do return end;
  end;
  _G.surface.SetTextPos(__deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.X, 0), __deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.Y, 250));
  _G.surface.SetFont("TargetID");
  _G.surface.DrawText(target:Name());
  local _g = target.id;
  local _g = (function() 
    local _hx_1
    if (_g == nil) then 
    _hx_1 = __haxe_ds_Option.None; else 
    _hx_1 = __haxe_ds_Option.Some(_g); end
    return _hx_1
  end )();
  if (_g[1] == 0) then 
    local _hx_tmp = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectionComponent)[_g[2]];
    if (_hx_tmp[1] == 1) then 
      _G.surface.SetTextPos(__deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.X, 0), __deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.Y, 300));
      _G.surface.SetFont("TargetID");
      _G.surface.DrawText(_G.string.format("Infection: %6.2f%%", _hx_tmp[2]:getInfValue()));
    end;
  end;
end
__deceptinfect_client_Hud.infectionMeter = function() 
  local inf;
  local _g = __deceptinfect_GameManager.state;
  local _g1 = _G.LocalPlayer().id;
  local _g1 = (function() 
    local _hx_1
    if (_g1 == nil) then 
    _hx_1 = __haxe_ds_Option.None; else 
    _hx_1 = __haxe_ds_Option.Some(_g1); end
    return _hx_1
  end )();
  if (_g1[1] == 0) then 
    local _hx_tmp = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectionComponent)[_g1[2]];
    if (_hx_tmp[1] == 1) then 
      if (_g[1] == 2) then 
        inf = _hx_tmp[2];
      else
        do return end;
      end;
    else
      do return end;
    end;
  else
    do return end;
  end;
  _G.surface.SetDrawColor(180, 180, 180, 255);
  _G.surface.DrawRect(__deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.X, 750), __deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.Y, 825), __deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.X, 300), __deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.Y, 30));
  if (inf:getInfValue() < 70) then 
    _G.surface.SetDrawColor(0, 0, 255, 255);
  else
    if (inf:getInfValue() < 90) then 
      _G.surface.SetDrawColor(255, 165, 0, 255);
    else
      if (inf:getInfValue() < 100) then 
        _G.surface.SetDrawColor(255, 0, 0, 255);
      else
        _G.surface.SetDrawColor(128, 0, 128, 255);
      end;
    end;
  end;
  _G.surface.DrawRect(__deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.X, 750), __deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.Y, 825), __deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.X, _G.math.floor(3 * inf:getInfValue())), __deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.Y, 30));
  _G.surface.SetFont("DermaLarge");
  _G.surface.SetTextColor(255, 255, 255);
  _G.surface.SetTextPos(0, __deceptinfect_client_Hud.CSS(__deceptinfect_client__Hud_Axis.Y, 600));
  _G.surface.DrawText(_G.string.format("Infection: %6.3f%% ", inf:getInfValue()));
end

__deceptinfect_client_PVS.new = {}
_hxClasses["deceptinfect.client.PVS"] = __deceptinfect_client_PVS
__deceptinfect_client_PVS.__name__ = "deceptinfect.client.PVS"

__deceptinfect_client_SabotagePanel.new = function(x) 
  local self = _hx_new(__deceptinfect_client_SabotagePanel.prototype)
  __deceptinfect_client_SabotagePanel.super(self,x)
  return self
end
__deceptinfect_client_SabotagePanel.super = function(self,x) 
  self["self"] = x;
end
_hx_exports["sabopanel"] = __deceptinfect_client_SabotagePanel
_hxClasses["deceptinfect.client.SabotagePanel"] = __deceptinfect_client_SabotagePanel
__deceptinfect_client_SabotagePanel.__name__ = "deceptinfect.client.SabotagePanel"
__deceptinfect_client_SabotagePanel.get_inst = function() 
  if (__deceptinfect_client_SabotagePanel.inst == nil) then 
    __deceptinfect_client_SabotagePanel.inst = _G.vgui.Create("SabotagePanel");
  end;
  do return __deceptinfect_client_SabotagePanel.inst end;
end
__deceptinfect_client_SabotagePanel.register = function() 
  local PANEL = ({});
  PANEL.Init = function(dis,...) dis._gHaxeBurrow = __deceptinfect_client_SabotagePanel.new(dis) dis._gHaxeBurrow:Init(...) end;
end
__deceptinfect_client_SabotagePanel.prototype = _hx_e();
__deceptinfect_client_SabotagePanel.prototype.Init = function(self) 
  __haxe_Log.trace("Panel created", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/client/SabotagePanel.hx",lineNumber=21,className="deceptinfect.client.SabotagePanel",methodName="Init"}));
  self["self"]:SetPos(0, 0);
  self["self"]:SetSize(600, 400);
  self["self"]:SetTitle("Sabotage");
  self["self"]:MouseCapture(true);
  self["self"]:SetVisible(true);
  self["self"]:SetDraggable(true);
  self["self"]:ShowCloseButton(true);
end

__deceptinfect_client_SabotagePanel.prototype.__class__ =  __deceptinfect_client_SabotagePanel
__deceptinfect_client_SabotagePanel.__super__ = {} or a
setmetatable(__deceptinfect_client_SabotagePanel.prototype,{__index={} or a.prototype})

__deceptinfect_client_SaboPanel3.new = function(x) 
  local self = _hx_new(__deceptinfect_client_SaboPanel3.prototype)
  __deceptinfect_client_SaboPanel3.super(self,x)
  return self
end
__deceptinfect_client_SaboPanel3.super = function(self,x) 
  self["self"] = x;
end
_hx_exports["s"] = __deceptinfect_client_SaboPanel3
_hxClasses["deceptinfect.client.SaboPanel3"] = __deceptinfect_client_SaboPanel3
__deceptinfect_client_SaboPanel3.__name__ = "deceptinfect.client.SaboPanel3"
__deceptinfect_client_SaboPanel3.register = function() 
  local PANEL = ({});
  PANEL.Init = function(dis,...) dis._gHaxeBurrow = __deceptinfect_client_SaboPanel3.new(dis) dis._gHaxeBurrow:Init(...) end;
end
__deceptinfect_client_SaboPanel3.prototype = _hx_e();
__deceptinfect_client_SaboPanel3.prototype.Init = function(self) 
end

__deceptinfect_client_SaboPanel3.prototype.__class__ =  __deceptinfect_client_SaboPanel3
__deceptinfect_client_SaboPanel3.__super__ = {} or a
setmetatable(__deceptinfect_client_SaboPanel3.prototype,{__index={} or a.prototype})

__deceptinfect_client_SaboPanel4.new = function(x) 
  local self = _hx_new(__deceptinfect_client_SaboPanel4.prototype)
  __deceptinfect_client_SaboPanel4.super(self,x)
  return self
end
__deceptinfect_client_SaboPanel4.super = function(self,x) 
  self["self"] = x;
end
_hx_exports["f"] = __deceptinfect_client_SaboPanel4
_hxClasses["deceptinfect.client.SaboPanel4"] = __deceptinfect_client_SaboPanel4
__deceptinfect_client_SaboPanel4.__name__ = "deceptinfect.client.SaboPanel4"
__deceptinfect_client_SaboPanel4.register = function() 
  local PANEL = ({});
  PANEL.Init = function(dis,...) dis._gHaxeBurrow = __deceptinfect_client_SaboPanel4.new(dis) dis._gHaxeBurrow:Init(...) end;
end
__deceptinfect_client_SaboPanel4.prototype = _hx_e();
__deceptinfect_client_SaboPanel4.prototype.Init = function(self) 
end

__deceptinfect_client_SaboPanel4.prototype.__class__ =  __deceptinfect_client_SaboPanel4
__deceptinfect_client_SaboPanel4.__super__ = {} or a
setmetatable(__deceptinfect_client_SaboPanel4.prototype,{__index={} or a.prototype})

__deceptinfect_client_SaboPanel2.new = function(x) 
  local self = _hx_new(__deceptinfect_client_SaboPanel2.prototype)
  __deceptinfect_client_SaboPanel2.super(self,x)
  return self
end
__deceptinfect_client_SaboPanel2.super = function(self,x) 
  __deceptinfect_client_SabotagePanel.super(self,x);
end
_hx_exports["sabopanel2"] = __deceptinfect_client_SaboPanel2
_hxClasses["deceptinfect.client.SaboPanel2"] = __deceptinfect_client_SaboPanel2
__deceptinfect_client_SaboPanel2.__name__ = "deceptinfect.client.SaboPanel2"
__deceptinfect_client_SaboPanel2.get_inst = function() 
  if (__deceptinfect_client_SaboPanel2.inst == nil) then 
    __deceptinfect_client_SaboPanel2.inst = _G.vgui.Create("SaboPanel2");
  end;
  do return __deceptinfect_client_SaboPanel2.inst end;
end
__deceptinfect_client_SaboPanel2.register = function() 
  local PANEL = ({});
  PANEL.Init = function(dis,...) dis._gHaxeBurrow = __deceptinfect_client_SaboPanel2.new(dis) dis._gHaxeBurrow:Init(...) end;
end
__deceptinfect_client_SaboPanel2.prototype = _hx_e();
__deceptinfect_client_SaboPanel2.prototype.Init = function(self) 
  __haxe_Log.trace("Panel2 created", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/client/SabotagePanel.hx",lineNumber=59,className="deceptinfect.client.SaboPanel2",methodName="Init"}));
  self["self"]:SetPos(0, 0);
  self["self"]:SetSize(600, 400);
  self["self"]:SetTitle("Sabotage");
  self["self"]:MouseCapture(true);
  self["self"]:SetVisible(true);
  self["self"]:SetDraggable(true);
  self["self"]:ShowCloseButton(true);
end

__deceptinfect_client_SaboPanel2.prototype.__class__ =  __deceptinfect_client_SaboPanel2
__deceptinfect_client_SaboPanel2.__super__ = __deceptinfect_client_SabotagePanel
setmetatable(__deceptinfect_client_SaboPanel2.prototype,{__index=__deceptinfect_client_SabotagePanel.prototype})

__haxe_ds_ObjectMap.new = function() 
  local self = _hx_new(__haxe_ds_ObjectMap.prototype)
  __haxe_ds_ObjectMap.super(self)
  return self
end
__haxe_ds_ObjectMap.super = function(self) 
  self.h = ({});
  self.k = ({});
end
_hxClasses["haxe.ds.ObjectMap"] = __haxe_ds_ObjectMap
__haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap"
__haxe_ds_ObjectMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_ObjectMap.prototype = _hx_e();
__haxe_ds_ObjectMap.prototype.get = function(self,key) 
  do return self.h[key] end
end
__haxe_ds_ObjectMap.prototype.keys = function(self) 
  local _gthis = self;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.k, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_ObjectMap.prototype.iterator = function(self) 
  local _gthis = self;
  local itr = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(_,...) return _hx_bind(itr,itr.hasNext)(...) end,next=function(self) 
    do return _gthis.h[itr:next()] end;
  end}) end
end

__haxe_ds_ObjectMap.prototype.__class__ =  __haxe_ds_ObjectMap

__deceptinfect_ecswip_ComponentManager.new = {}
_hxClasses["deceptinfect.ecswip.ComponentManager"] = __deceptinfect_ecswip_ComponentManager
__deceptinfect_ecswip_ComponentManager.__name__ = "deceptinfect.ecswip.ComponentManager"
__deceptinfect_ecswip_ComponentManager.addGEnt = function(x) 
  local id = __deceptinfect_ecswip_ComponentManager.addEntity();
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_ecswip_GEntityComponent.new(x), id);
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_ecswip_VirtualPosition.new(__deceptinfect_ecswip_ChooseVirPos.ENT(x)), id);
  do return id end;
end
__deceptinfect_ecswip_ComponentManager.getOrAdd = function(id,cls,args) 
  local _g = __deceptinfect_ecswip_ComponentManager.lazyInit(cls)[id];
  local tmp = _g[1];
  if (tmp) == 0 then 
    if (args == nil) then 
      args = _hx_tab_array({}, 0);
    end;
    local inst = Type.createInstance(cls, args);
    __deceptinfect_ecswip_ComponentManager.addComponent(inst, id);
    do return inst end;
  elseif (tmp) == 1 then 
    do return _g[2] end; end;
end
__deceptinfect_ecswip_ComponentManager.addPlayer = function(x) 
  local id = __deceptinfect_ecswip_ComponentManager.addGEnt(x);
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_ecswip_PlayerComponent.new(x), id);
  __deceptinfect_PlayerManager.addID(x, id);
  do return id end;
end
__deceptinfect_ecswip_ComponentManager.addComponent = function(x,to) 
  local cls = Type.getClass(x);
  local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(cls);
  if (__deceptinfect_ecswip_ComponentManager.componentSignals.k[cls] ~= nil) then 
    __deceptinfect_ecswip_ComponentManager.componentSignals.h[cls].handlers:invoke(_hx_o({__fields__={ent=true,comp=true},ent=to,comp=x}));
  end;
  comparray[to] = __deceptinfect_ecswip_ComponentState.Comp(x);
end
__deceptinfect_ecswip_ComponentManager.lazyInit = function(x) 
  local comparray = __deceptinfect_ecswip_ComponentManager.components.h[x];
  if (comparray == nil) then 
    comparray = _hx_tab_array({}, 0);
    local _this = __deceptinfect_ecswip_ComponentManager.components;
    _this.h[x] = comparray;
    _this.k[x] = true;
    local entity = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
    while (entity:hasNext()) do 
      comparray[entity:next()] = __deceptinfect_ecswip_ComponentState.NONE;
    end;
  end;
  do return comparray end;
end
__deceptinfect_ecswip_ComponentManager.removeEntity = function(x) 
  local component = __deceptinfect_ecswip_ComponentManager.components:iterator();
  while (component:hasNext()) do 
    component:next()[x] = __deceptinfect_ecswip_ComponentState.NONE;
  end;
  __deceptinfect_ecswip_ComponentManager.activeEntities = __deceptinfect_ecswip_ComponentManager.activeEntities - 1;
end
__deceptinfect_ecswip_ComponentManager.addToAllCompArrays = function() 
  local compArray = __deceptinfect_ecswip_ComponentManager.components:iterator();
  while (compArray:hasNext()) do 
    compArray:next():push(__deceptinfect_ecswip_ComponentState.NONE);
  end;
end
__deceptinfect_ecswip_ComponentManager.addEntity = function() 
  __deceptinfect_ecswip_ComponentManager.entities = __deceptinfect_ecswip_ComponentManager.entities + 1;
  __deceptinfect_ecswip_ComponentManager.activeEntities = __deceptinfect_ecswip_ComponentManager.activeEntities + 1;
  __deceptinfect_ecswip_ComponentManager.addToAllCompArrays();
  do return __deceptinfect_ecswip_ComponentManager.entities - 1 end;
end
_hxClasses["deceptinfect.ecswip.ComponentState"] = __deceptinfect_ecswip_ComponentState;
_hxClasses["deceptinfect.ecswip.ComponentState"] = { __ename__ = "deceptinfect.ecswip.ComponentState", __constructs__ = _hx_tab_array({[0]="NONE","Comp"},2)}
__deceptinfect_ecswip_ComponentState = _hxClasses["deceptinfect.ecswip.ComponentState"];
__deceptinfect_ecswip_ComponentState.NONE = _hx_tab_array({[0]="NONE",0,__enum__ = __deceptinfect_ecswip_ComponentState},2)

__deceptinfect_ecswip_ComponentState.Comp = function(comp) local _x = _hx_tab_array({[0]="Comp",1,comp,__enum__=__deceptinfect_ecswip_ComponentState}, 3); return _x; end 

__deceptinfect_ecswip_GEntityComponent.new = function(e) 
  local self = _hx_new(__deceptinfect_ecswip_GEntityComponent.prototype)
  __deceptinfect_ecswip_GEntityComponent.super(self,e)
  return self
end
__deceptinfect_ecswip_GEntityComponent.super = function(self,e) 
  __deceptinfect_ecswip_Component.super(self);
  self.entity = e;
end
_hxClasses["deceptinfect.ecswip.GEntityComponent"] = __deceptinfect_ecswip_GEntityComponent
__deceptinfect_ecswip_GEntityComponent.__name__ = "deceptinfect.ecswip.GEntityComponent"
__deceptinfect_ecswip_GEntityComponent.prototype = _hx_e();

__deceptinfect_ecswip_GEntityComponent.prototype.__class__ =  __deceptinfect_ecswip_GEntityComponent
__deceptinfect_ecswip_GEntityComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_GEntityComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_ecswip_GrabDraw.new = function(ent1,ent2) 
  local self = _hx_new(__deceptinfect_ecswip_GrabDraw.prototype)
  __deceptinfect_ecswip_GrabDraw.super(self,ent1,ent2)
  return self
end
__deceptinfect_ecswip_GrabDraw.super = function(self,ent1,ent2) 
  __deceptinfect_ecswip_Component.super(self);
  self.ent1 = ent1;
  self.ent2 = ent2;
end
_hxClasses["deceptinfect.ecswip.GrabDraw"] = __deceptinfect_ecswip_GrabDraw
__deceptinfect_ecswip_GrabDraw.__name__ = "deceptinfect.ecswip.GrabDraw"
__deceptinfect_ecswip_GrabDraw.prototype = _hx_e();

__deceptinfect_ecswip_GrabDraw.prototype.__class__ =  __deceptinfect_ecswip_GrabDraw
__deceptinfect_ecswip_GrabDraw.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_GrabDraw.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_ecswip_GrabSystem.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_GrabSystem.prototype)
  __deceptinfect_ecswip_GrabSystem.super(self)
  return self
end
__deceptinfect_ecswip_GrabSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.ecswip.GrabSystem"] = __deceptinfect_ecswip_GrabSystem
__deceptinfect_ecswip_GrabSystem.__name__ = "deceptinfect.ecswip.GrabSystem"
__deceptinfect_ecswip_GrabSystem.updateSig = function(data) 
  if (not (__deceptinfect_ecswip_GrabSystem.activeDraws.h[data.index] ~= nil)) then 
    __haxe_Log.trace(Std.string("activated grab ") .. Std.string(data.index), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/ecswip/GrabSystem.hx",lineNumber=39,className="deceptinfect.ecswip.GrabSystem",methodName="updateSig"}));
    local draw = __deceptinfect_ecswip_ComponentManager.addEntity();
    __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_ecswip_GrabDraw.new(data.ent, data.ent2), draw);
    local key = data.index;
    local _this = __deceptinfect_ecswip_GrabSystem.activeDraws;
    if (draw == nil) then 
      _this.h[key] = __haxe_ds_IntMap.tnull;
    else
      _this.h[key] = draw;
    end;
  end;
end
__deceptinfect_ecswip_GrabSystem.remove = function(data) 
  __haxe_Log.trace(Std.string("delete grab ") .. Std.string(data.index), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/ecswip/GrabSystem.hx",lineNumber=47,className="deceptinfect.ecswip.GrabSystem",methodName="remove"}));
  if (__deceptinfect_ecswip_GrabSystem.activeDraws.h[data.index] ~= nil) then 
    local ret = __deceptinfect_ecswip_GrabSystem.activeDraws.h[data.index];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    __deceptinfect_ecswip_ComponentManager.removeEntity(ret);
  else
    __deceptinfect_ecswip_GrabSystem.activeDraws.h[data.index] = __haxe_ds_IntMap.tnull;
  end;
end
__deceptinfect_ecswip_GrabSystem.drawCylinders = function() 
  local ent = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
  while (ent:hasNext()) do 
    local ent = ent:next();
    local _g = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GrabDraw)[ent];
    if (_g[1] == 1) then 
      local _g = _g[2];
      local tmp;
      local key = _g.ent1:EntIndex();
      local ret = __deceptinfect_client_PVS.pvs.h[key];
      if (ret == __haxe_ds_IntMap.tnull) then 
        ret = nil;
      end;
      if (not ret) then 
        local key = _g.ent2:EntIndex();
        local ret = __deceptinfect_client_PVS.pvs.h[key];
        if (ret == __haxe_ds_IntMap.tnull) then 
          ret = nil;
        end;
        tmp = ret;
      else
        tmp = true;
      end;
      if (tmp) then 
        local posProduce = _g.ent1:GetPos();
        local posVic = _g.ent2:GetPos();
        _G.render.SetMaterial(__deceptinfect_ecswip_GrabSystem.hycord);
        _G.render.DrawBeam(posProduce, posVic, 24, 0, 1, _hx_o({__fields__={r=true,g=true,b=true,a=true},r=128,g=0,b=255,a=255}));
      else
        __deceptinfect_ecswip_ComponentManager.removeEntity(ent);
      end;
    end;
  end;
  do return nil end;
end
__deceptinfect_ecswip_GrabSystem.prototype = _hx_e();
__deceptinfect_ecswip_GrabSystem.prototype.init_client = function(self) 
  __deceptinfect_ecswip_GrabSystem.net_grabupdate.signal:listen(__deceptinfect_ecswip_GrabSystem.updateSig);
  __deceptinfect_ecswip_GrabSystem.net_grabend.signal:listen(__deceptinfect_ecswip_GrabSystem.remove);
end

__deceptinfect_ecswip_GrabSystem.prototype.__class__ =  __deceptinfect_ecswip_GrabSystem
__deceptinfect_ecswip_GrabSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_ecswip_GrabSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_ecswip_HiddenHealthSystem.new = function() 
  local self = _hx_new(__deceptinfect_ecswip_HiddenHealthSystem.prototype)
  __deceptinfect_ecswip_HiddenHealthSystem.super(self)
  return self
end
__deceptinfect_ecswip_HiddenHealthSystem.super = function(self) 
  __deceptinfect_client_GeigerSystem.super(self);
end
_hxClasses["deceptinfect.ecswip.HiddenHealthSystem"] = __deceptinfect_ecswip_HiddenHealthSystem
__deceptinfect_ecswip_HiddenHealthSystem.__name__ = "deceptinfect.ecswip.HiddenHealthSystem"
__deceptinfect_ecswip_HiddenHealthSystem.prototype = _hx_e();

__deceptinfect_ecswip_HiddenHealthSystem.prototype.__class__ =  __deceptinfect_ecswip_HiddenHealthSystem
__deceptinfect_ecswip_HiddenHealthSystem.__super__ = __deceptinfect_client_GeigerSystem
setmetatable(__deceptinfect_ecswip_HiddenHealthSystem.prototype,{__index=__deceptinfect_client_GeigerSystem.prototype})

__deceptinfect_ecswip_PlayerComponent.new = function(x) 
  local self = _hx_new(__deceptinfect_ecswip_PlayerComponent.prototype)
  __deceptinfect_ecswip_PlayerComponent.super(self,x)
  return self
end
__deceptinfect_ecswip_PlayerComponent.super = function(self,x) 
  __deceptinfect_ecswip_Component.super(self);
  self.player = x;
end
_hxClasses["deceptinfect.ecswip.PlayerComponent"] = __deceptinfect_ecswip_PlayerComponent
__deceptinfect_ecswip_PlayerComponent.__name__ = "deceptinfect.ecswip.PlayerComponent"
__deceptinfect_ecswip_PlayerComponent.prototype = _hx_e();

__deceptinfect_ecswip_PlayerComponent.prototype.__class__ =  __deceptinfect_ecswip_PlayerComponent
__deceptinfect_ecswip_PlayerComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_PlayerComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_ecswip_SignalStorage.new = {}
_hxClasses["deceptinfect.ecswip.SignalStorage"] = __deceptinfect_ecswip_SignalStorage
__deceptinfect_ecswip_SignalStorage.__name__ = "deceptinfect.ecswip.SignalStorage"
__deceptinfect_ecswip_SignalStorage.initEvents = function() 
  __deceptinfect_ecswip_SignalStorage.entDamage = __deceptinfect_ecswip_SignalStorage.entDamageTrigger;
  __deceptinfect_ecswip_SignalStorage.onInfected = __deceptinfect_ecswip_SignalStorage.onInfectedTrigger;
end

__deceptinfect_infection_InfectionSystem.new = function() 
  local self = _hx_new(__deceptinfect_infection_InfectionSystem.prototype)
  __deceptinfect_infection_InfectionSystem.super(self)
  return self
end
__deceptinfect_infection_InfectionSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.infection.InfectionSystem"] = __deceptinfect_infection_InfectionSystem
__deceptinfect_infection_InfectionSystem.__name__ = "deceptinfect.infection.InfectionSystem"
__deceptinfect_infection_InfectionSystem.prototype = _hx_e();
__deceptinfect_infection_InfectionSystem.prototype.init_client = function(self) 
  __deceptinfect_infection_InfectionSystem.net_inf.signal:listen(_hx_bind(self,self.recvInfection));
  __deceptinfect_infection_InfectionSystem.net_infected.signal:listen(_hx_bind(self,self.onInfectedCl));
end
__deceptinfect_infection_InfectionSystem.prototype.onInfectedCl = function(self,data) 
  __haxe_Log.trace("Recieved infected data", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/infection/InfectionSystem.hx",lineNumber=29,className="deceptinfect.infection.InfectionSystem",methodName="onInfectedCl"}));
  local this1 = __deceptinfect_PlayerManager.getLocalPlayerID();
  local _g = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectionComponent)[this1];
  if (_g[1] == 1) then 
    local _g = _g[2];
    _g:set_infection(__deceptinfect_infection_INF_STATE.INFECTED);
    local this1 = __deceptinfect_PlayerManager.getLocalPlayerID();
    __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_infection_InfectedComponent.new(), this1);
    __haxe_Log.trace(_g, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/infection/InfectionSystem.hx",lineNumber=34,className="deceptinfect.infection.InfectionSystem",methodName="onInfectedCl"}));
  else
    __haxe_Log.trace("no...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/infection/InfectionSystem.hx",lineNumber=36,className="deceptinfect.infection.InfectionSystem",methodName="onInfectedCl"}));
    local c_inf = __deceptinfect_infection_InfectionComponent.new();
    __deceptinfect_ecswip_ComponentManager.addComponent(c_inf, __deceptinfect_PlayerManager.getLocalPlayerID());
    c_inf:set_infection(__deceptinfect_infection_INF_STATE.INFECTED);
  end;
end
__deceptinfect_infection_InfectionSystem.prototype.recvInfection = function(self,data) 
  local this1 = __deceptinfect_PlayerManager.getLocalPlayerID();
  local _g = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_infection_InfectionComponent)[this1];
  if (_g[1] == 1) then 
    local _g = _g[2].infection;
    if (_g[1] == 0) then 
      _g[2][0] = data.infection;
    end;
  else
    __haxe_Log.trace("nu shit", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/infection/InfectionSystem.hx",lineNumber=54,className="deceptinfect.infection.InfectionSystem",methodName="recvInfection"}));
    local c_inf = __deceptinfect_infection_InfectionComponent.new();
    __deceptinfect_ecswip_ComponentManager.addComponent(c_inf, __deceptinfect_PlayerManager.getLocalPlayerID());
    local v = data.infection;
    local ret = ({length = 1});
    ret[0] = v;
    c_inf:set_infection(__deceptinfect_infection_INF_STATE.NOT_INFECTED(ret));
  end;
end

__deceptinfect_infection_InfectionSystem.prototype.__class__ =  __deceptinfect_infection_InfectionSystem
__deceptinfect_infection_InfectionSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_infection_InfectionSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_ecswip_VirtualPosition.new = function(choice) 
  local self = _hx_new(__deceptinfect_ecswip_VirtualPosition.prototype)
  __deceptinfect_ecswip_VirtualPosition.super(self,choice)
  return self
end
__deceptinfect_ecswip_VirtualPosition.super = function(self,choice) 
  __deceptinfect_ecswip_Component.super(self);
  local tmp = choice[1];
  if (tmp) == 0 then 
    self.ent = choice[2];
  elseif (tmp) == 1 then 
    self:set_pos(choice[2]);
    self:set_ang(choice[3]); end;
end
_hxClasses["deceptinfect.ecswip.VirtualPosition"] = __deceptinfect_ecswip_VirtualPosition
__deceptinfect_ecswip_VirtualPosition.__name__ = "deceptinfect.ecswip.VirtualPosition"
__deceptinfect_ecswip_VirtualPosition.prototype = _hx_e();
__deceptinfect_ecswip_VirtualPosition.prototype.set_pos = function(self,set) 
  if (self.ent == nil) then 
    self.pos = set do return self.pos end;
  else
    self.ent:SetPos(set);
    do return set end;
  end;
end
__deceptinfect_ecswip_VirtualPosition.prototype.set_ang = function(self,set) 
  if (self.ent == nil) then 
    self.ang = set do return self.ang end;
  else
    self.ent:SetAngles(set);
    do return set end;
  end;
end

__deceptinfect_ecswip_VirtualPosition.prototype.__class__ =  __deceptinfect_ecswip_VirtualPosition
__deceptinfect_ecswip_VirtualPosition.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_ecswip_VirtualPosition.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_radiation_RadiationSystem.new = function() 
  local self = _hx_new(__deceptinfect_radiation_RadiationSystem.prototype)
  __deceptinfect_radiation_RadiationSystem.super(self)
  return self
end
__deceptinfect_radiation_RadiationSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.radiation.RadiationSystem"] = __deceptinfect_radiation_RadiationSystem
__deceptinfect_radiation_RadiationSystem.__name__ = "deceptinfect.radiation.RadiationSystem"
__deceptinfect_radiation_RadiationSystem.testRadiation = function(vec) 
  local ent = __deceptinfect_ecswip_ComponentManager.addEntity();
  __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_ecswip_VirtualPosition.new(__deceptinfect_ecswip_ChooseVirPos.REAL(vec, _G.Angle(0, 0, 0))), ent);
end
_hx_exports["testRadiation"] = __deceptinfect_radiation_RadiationSystem.testRadiation
__deceptinfect_radiation_RadiationSystem.prototype = _hx_e();

__deceptinfect_radiation_RadiationSystem.prototype.__class__ =  __deceptinfect_radiation_RadiationSystem
__deceptinfect_radiation_RadiationSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_radiation_RadiationSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_game_WinSystem.new = function() 
  local self = _hx_new(__deceptinfect_game_WinSystem.prototype)
  __deceptinfect_game_WinSystem.super(self)
  return self
end
__deceptinfect_game_WinSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.game.WinSystem"] = __deceptinfect_game_WinSystem
__deceptinfect_game_WinSystem.__name__ = "deceptinfect.game.WinSystem"
__deceptinfect_game_WinSystem.prototype = _hx_e();

__deceptinfect_game_WinSystem.prototype.__class__ =  __deceptinfect_game_WinSystem
__deceptinfect_game_WinSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_game_WinSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_game_BatterySystem.new = function() 
  local self = _hx_new(__deceptinfect_game_BatterySystem.prototype)
  __deceptinfect_game_BatterySystem.super(self)
  return self
end
__deceptinfect_game_BatterySystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.game.BatterySystem"] = __deceptinfect_game_BatterySystem
__deceptinfect_game_BatterySystem.__name__ = "deceptinfect.game.BatterySystem"
__deceptinfect_game_BatterySystem.prototype = _hx_e();

__deceptinfect_game_BatterySystem.prototype.__class__ =  __deceptinfect_game_BatterySystem
__deceptinfect_game_BatterySystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_game_BatterySystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_game_SpawnPointTable.new = function() 
  local self = _hx_new(__deceptinfect_game_SpawnPointTable.prototype)
  __deceptinfect_game_SpawnPointTable.super(self)
  return self
end
__deceptinfect_game_SpawnPointTable.super = function(self) 
  self.spawns = _hx_tab_array({}, 0);
end
_hxClasses["deceptinfect.game.SpawnPointTable"] = __deceptinfect_game_SpawnPointTable
__deceptinfect_game_SpawnPointTable.__name__ = "deceptinfect.game.SpawnPointTable"
__deceptinfect_game_SpawnPointTable.prototype = _hx_e();
__deceptinfect_game_SpawnPointTable.prototype.generateSpawns = function(self,points) 
  self.spawns = _hx_tab_array({}, 0);
  local _g = 0;
  while (_g < points.length) do 
    local point = points[_g];
    _g = _g + 1;
    self.spawns:push(__deceptinfect_game_Spawn.new(self, point));
  end;
  local _g = 0;
  local _g1 = self.spawns;
  while (_g < _g1.length) do 
    local spawn = _g1[_g];
    _g = _g + 1;
    local _g = 0;
    local _g1 = self.spawns;
    while (_g < _g1.length) do 
      local spawn2 = _g1[_g];
      _g = _g + 1;
      spawn:calculateDist(spawn2);
    end;
  end;
end
__deceptinfect_game_SpawnPointTable.prototype.generateBoundSpawns = function(self,points) 
  self.spawns = _hx_tab_array({}, 0);
  local _g = 0;
  while (_g < points.length) do 
    local minmax = points[_g];
    _g = _g + 1;
    self.spawns:push(__deceptinfect_game_BoundsSpawn.new(self, __deceptinfect_util_MinMaxTools.getCenter(minmax), minmax));
  end;
  local _g = 0;
  local _g1 = self.spawns;
  while (_g < _g1.length) do 
    local spawn = _g1[_g];
    _g = _g + 1;
    local _g = 0;
    local _g1 = self.spawns;
    while (_g < _g1.length) do 
      local spawn2 = _g1[_g];
      _g = _g + 1;
      spawn:calculateDist(spawn2);
    end;
  end;
end

__deceptinfect_game_SpawnPointTable.prototype.__class__ =  __deceptinfect_game_SpawnPointTable

__deceptinfect_game_SpawnSystem.new = function() 
  local self = _hx_new(__deceptinfect_game_SpawnSystem.prototype)
  __deceptinfect_game_SpawnSystem.super(self)
  return self
end
__deceptinfect_game_SpawnSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.game.SpawnSystem"] = __deceptinfect_game_SpawnSystem
__deceptinfect_game_SpawnSystem.__name__ = "deceptinfect.game.SpawnSystem"
__deceptinfect_game_SpawnSystem.generateSpawns = function() 
  local this1 = __deceptinfect_MapStorage.spawns;
  local key = _G.game.GetMap();
  local ret = this1.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  __deceptinfect_game_SpawnSystem.obj:generateSpawns(ret.objectives);
  local this1 = __deceptinfect_MapStorage.spawns;
  local key = _G.game.GetMap();
  local ret = this1.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  __deceptinfect_game_SpawnSystem.item:generateSpawns(ret.items);
  local this1 = __deceptinfect_MapStorage.spawns;
  local key = _G.game.GetMap();
  local ret = this1.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  __deceptinfect_game_SpawnSystem.nest:generateSpawns(ret.nests);
  local this1 = __deceptinfect_MapStorage.spawns;
  local key = _G.game.GetMap();
  local ret = this1.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  __deceptinfect_game_SpawnSystem.evac:generateBoundSpawns(ret.evacs);
end
__deceptinfect_game_SpawnSystem.prototype = _hx_e();

__deceptinfect_game_SpawnSystem.prototype.__class__ =  __deceptinfect_game_SpawnSystem
__deceptinfect_game_SpawnSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_game_SpawnSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_statuses_WalkthroughSystem.new = function() 
  local self = _hx_new(__deceptinfect_statuses_WalkthroughSystem.prototype)
  __deceptinfect_statuses_WalkthroughSystem.super(self)
  return self
end
__deceptinfect_statuses_WalkthroughSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.statuses.WalkthroughSystem"] = __deceptinfect_statuses_WalkthroughSystem
__deceptinfect_statuses_WalkthroughSystem.__name__ = "deceptinfect.statuses.WalkthroughSystem"
__deceptinfect_statuses_WalkthroughSystem.prototype = _hx_e();

__deceptinfect_statuses_WalkthroughSystem.prototype.__class__ =  __deceptinfect_statuses_WalkthroughSystem
__deceptinfect_statuses_WalkthroughSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_statuses_WalkthroughSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_game_NestSystem.new = function() 
  local self = _hx_new(__deceptinfect_game_NestSystem.prototype)
  __deceptinfect_game_NestSystem.super(self)
  return self
end
__deceptinfect_game_NestSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.game.NestSystem"] = __deceptinfect_game_NestSystem
__deceptinfect_game_NestSystem.__name__ = "deceptinfect.game.NestSystem"
__deceptinfect_game_NestSystem.prototype = _hx_e();

__deceptinfect_game_NestSystem.prototype.__class__ =  __deceptinfect_game_NestSystem
__deceptinfect_game_NestSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_game_NestSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_game_EvacSystem.new = function() 
  local self = _hx_new(__deceptinfect_game_EvacSystem.prototype)
  __deceptinfect_game_EvacSystem.super(self)
  return self
end
__deceptinfect_game_EvacSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.game.EvacSystem"] = __deceptinfect_game_EvacSystem
__deceptinfect_game_EvacSystem.__name__ = "deceptinfect.game.EvacSystem"
__deceptinfect_game_EvacSystem.prototype = _hx_e();
__deceptinfect_game_EvacSystem.prototype.init_client = function(self) 
  __deceptinfect_game_EvacSystem.evac_state.signal:listen(_hx_bind(self,self.changeEvacState));
end
__deceptinfect_game_EvacSystem.prototype.changeEvacState = function(self,x) 
  local _g = x.time;
  local _g1 = x.state;
  if (_g1) == 0 then 
  elseif (_g1) == 1 then 
  elseif (_g1) == 2 then 
    local t = _g;
    __deceptinfect_util_Util.printTimer_2(0, 3, function() 
      __haxe_Log.trace(Std.string("leaving!!.. ") .. Std.string(t), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/game/EvacSystem.hx",lineNumber=36,className="deceptinfect.game.EvacSystem",methodName="changeEvacState"}));
    end);else
  __deceptinfect_util_Util.printTimer_2(1, 5, function() 
    __haxe_Log.trace("Invalid state for hud....", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/game/EvacSystem.hx",lineNumber=39,className="deceptinfect.game.EvacSystem",methodName="changeEvacState"}));
  end); end;
end

__deceptinfect_game_EvacSystem.prototype.__class__ =  __deceptinfect_game_EvacSystem
__deceptinfect_game_EvacSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_game_EvacSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_game_RagdollSystem.new = function() 
  local self = _hx_new(__deceptinfect_game_RagdollSystem.prototype)
  __deceptinfect_game_RagdollSystem.super(self)
  return self
end
__deceptinfect_game_RagdollSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.game.RagdollSystem"] = __deceptinfect_game_RagdollSystem
__deceptinfect_game_RagdollSystem.__name__ = "deceptinfect.game.RagdollSystem"
__deceptinfect_game_RagdollSystem.prototype = _hx_e();
__deceptinfect_game_RagdollSystem.prototype.init_client = function(self) 
  __deceptinfect_game_RagdollSystem.statue.signal:listen(_hx_bind(self,self.newStatue));
  __deceptinfect_game_RagdollSystem.raginfo.signal:listen(_hx_bind(self,self.recvraginfo));
  __deceptinfect_game_RagdollSystem.statueinfo.signal:listen(_hx_bind(self,self.recvstatinfo));
end
__deceptinfect_game_RagdollSystem.prototype.recvraginfo = function(self,x) 
  local c_raginfo;
  local x1 = x.rag;
  local _g;
  if (_G.IsValid(x1)) then 
    local _g1 = x1.id;
    _g = (function() 
      local _hx_1
      if (_g1 == nil) then 
      _hx_1 = __haxe_ds_Option.None; else 
      _hx_1 = __haxe_ds_Option.Some(_g1); end
      return _hx_1
    end )();
  else
    _g = __haxe_ds_Option.None;
  end;
  if (_g[1] == 0) then 
    local args = nil;
    c_raginfo = __deceptinfect_ecswip_ComponentManager.getOrAdd(_g[2], __deceptinfect_game_RagInfo, args);
  else
    if (_G.IsValid(x.rag)) then 
      local x = x.rag;
      x.id = __deceptinfect_ecswip_ComponentManager.addGEnt(x);
      local c_rag = __deceptinfect_game_RagInfo.new();
      __deceptinfect_ecswip_ComponentManager.addComponent(c_rag, x.id);
      c_raginfo = c_rag;
    else
      do return end;
    end;
  end;
  c_raginfo.inf = _hx_funcToField(x.inf);
  c_raginfo.name = _hx_funcToField(x.name);
  c_raginfo.attacker = _hx_funcToField(x.attacker);
end
__deceptinfect_game_RagdollSystem.prototype.recvstatinfo = function(self,x) 
  local c_statinfo;
  local _g = __deceptinfect_util_EntityExt.validID2(x.stat);
  local c_statinfo1 = _g[1];
  if (c_statinfo1) == 0 then 
    local args = nil;
    c_statinfo = __deceptinfect_ecswip_ComponentManager.getOrAdd(_g[2], __deceptinfect_game_StatInfo, args);
  elseif (c_statinfo1) == 1 then 
    local x = x.stat;
    x.id = __deceptinfect_ecswip_ComponentManager.addGEnt(x);
    local c_stat = __deceptinfect_game_StatInfo.new();
    __deceptinfect_ecswip_ComponentManager.addComponent(c_stat, x.id);
    c_statinfo = c_stat;
  elseif (c_statinfo1) == 2 then 
    do return end; end;
  c_statinfo.health = _hx_funcToField(x.health);
  c_statinfo.inf = _hx_funcToField(x.inf);
  c_statinfo.name = _hx_funcToField(x.name);
end
__deceptinfect_game_RagdollSystem.prototype.pvsChange = function(self,ent,shouldTransmit) 
  local _g = ent.id;
  local _g = (function() 
    local _hx_1
    if (_g == nil) then 
    _hx_1 = __haxe_ds_Option.None; else 
    _hx_1 = __haxe_ds_Option.Some(_g); end
    return _hx_1
  end )();
  if (_g[1] == 0) then 
    local _g = _g[2];
    local _g1 = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_game_Statue)[_g];
    local _g = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GEntityComponent)[_g];
    if (_g[1] == 1) then 
      if (_g1[1] == 1) then 
        local _g1 = _g1[2];
        local _hx_tmp;
        _hx_tmp = _g[2].entity;
        __haxe_Log.trace("THing changed", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/game/RagdollSystem.hx",lineNumber=117,className="deceptinfect.game.RagdollSystem",methodName="pvsChange"}));
        if (shouldTransmit) then 
          _g1.weapon:SetParent();
          _g1.weapon:SetParent(_hx_tmp);
        end;
      end;
    end;
  end;
end
__deceptinfect_game_RagdollSystem.prototype.newStatue = function(self,x) 
  local rag = _G.ClientsideModel(x.playermodel);
  local wep = _G.ClientsideModel(x.weaponmodel);
  rag:SetPos(x.playerpos);
  rag:AddCallback("BuildBonePositions", function(rag,numbones) 
    local _g = 0;
    local _g1 = numbones;
    while (_g < _g1) do 
      _g = _g + 1;
      local boneid = _g - 1;
      if (x.playerbones[boneid] == nil) then 
        local this1 = rag:GetBonePosition(boneid);
        local otherVec = rag:GetBonePosition(0);
        local offset = this1 - otherVec;
        local this1 = x.playerbones[0];
        rag:SetBonePosition(boneid, this1 + offset, _G.Angle(0, 0, 0));
      end;
    end;
    local done_h = ({});
    local _g = __gmod_PairTools.keyValueIterator(x.playerbones);
    while (_g:hasNext()) do 
      local _g = _g:next();
      local boneid = _g.key;
      local ang = x.playerangle[boneid];
      done_h[boneid] = true;
      rag:SetBonePosition(boneid, _g.value, ang);
    end;
  end);
  wep:SetupBones();
  wep:AddEffects(_G.EF_BONEMERGE);
  wep:AddEffects(_G.EF_BONEMERGE_FASTCULL);
  wep:SetParent(rag);
end
__deceptinfect_game_RagdollSystem.prototype.run_client = function(self) 
  local rag = __gmod_PairTools.iterator(_G.ents.GetAll());
  while (rag:hasNext()) do 
    local rag = rag:next();
    local mdl = rag:GetNWString("showwep");
    if (((mdl ~= nil) and (mdl ~= "")) and (rag.showwep == nil)) then 
      local this1 = rag;
      rag.id = __deceptinfect_ecswip_ComponentManager.addGEnt(this1);
      local _rag = this1;
      local c_stat = __deceptinfect_game_Statue.new();
      __deceptinfect_ecswip_ComponentManager.addComponent(c_stat, _rag.id);
      __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_game_KeepRestart.new(), _rag.id);
      __haxe_Log.trace(mdl, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/deceptinfect/game/RagdollSystem.hx",lineNumber=179,className="deceptinfect.game.RagdollSystem",methodName="run_client"}));
      rag.showwep = true;
      local x = _G.ClientsideModel(mdl);
      local this1 = x;
      x.id = __deceptinfect_ecswip_ComponentManager.addGEnt(this1);
      local ent = this1;
      local c_wep = __deceptinfect_game_ClientWeaponStatue.new();
      c_wep.parent = rag;
      __deceptinfect_ecswip_ComponentManager.addComponent(c_wep, ent.id);
      __deceptinfect_ecswip_ComponentManager.addComponent(__deceptinfect_game_KeepRestart.new(), ent.id);
      ent:SetupBones();
      ent:AddEffects(_G.EF_BONEMERGE);
      ent:AddEffects(_G.EF_BONEMERGE_FASTCULL);
      ent:SetParent(rag);
      c_stat.weapon = ent;
    end;
  end;
  local ent = IntIterator.new(0, __deceptinfect_ecswip_ComponentManager.entities);
  while (ent:hasNext()) do 
    local ent = ent:next();
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_game_ClientWeaponStatue);
    local _g = comparray[ent];
    local comparray = __deceptinfect_ecswip_ComponentManager.lazyInit(__deceptinfect_ecswip_GEntityComponent);
    local _g1 = comparray[ent];
    if (_g1[1] == 1) then 
      if (_g[1] == 1) then 
        local _hx_tmp;
        _hx_tmp = _g1[2].entity;
        local gent = _hx_tmp;
        local c_stat = _g[2];
        if (not _G.IsValid(c_stat.parent)) then 
          gent:Remove();
        end;
      end;
    end;
  end;
end

__deceptinfect_game_RagdollSystem.prototype.__class__ =  __deceptinfect_game_RagdollSystem
__deceptinfect_game_RagdollSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_game_RagdollSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_game_SlowMotionSystem.new = function() 
  local self = _hx_new(__deceptinfect_game_SlowMotionSystem.prototype)
  __deceptinfect_game_SlowMotionSystem.super(self)
  return self
end
__deceptinfect_game_SlowMotionSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.game.SlowMotionSystem"] = __deceptinfect_game_SlowMotionSystem
__deceptinfect_game_SlowMotionSystem.__name__ = "deceptinfect.game.SlowMotionSystem"
__deceptinfect_game_SlowMotionSystem.prototype = _hx_e();

__deceptinfect_game_SlowMotionSystem.prototype.__class__ =  __deceptinfect_game_SlowMotionSystem
__deceptinfect_game_SlowMotionSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_game_SlowMotionSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_infection_InfectionLookSystem.new = function() 
  local self = _hx_new(__deceptinfect_infection_InfectionLookSystem.prototype)
  __deceptinfect_infection_InfectionLookSystem.super(self)
  return self
end
__deceptinfect_infection_InfectionLookSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.infection.InfectionLookSystem"] = __deceptinfect_infection_InfectionLookSystem
__deceptinfect_infection_InfectionLookSystem.__name__ = "deceptinfect.infection.InfectionLookSystem"
__deceptinfect_infection_InfectionLookSystem.prototype = _hx_e();
__deceptinfect_infection_InfectionLookSystem.prototype.init_client = function(self) 
  __deceptinfect_infection_InfectionLookSystem.infectioninfo.signal:listen(_hx_bind(self,self.recvInfectionInfo));
end
__deceptinfect_infection_InfectionLookSystem.prototype.recvInfectionInfo = function(self,x) 
  local args = nil;
  local c_inf = __deceptinfect_ecswip_ComponentManager.getOrAdd(x.target.id, __deceptinfect_infection_InfectionComponent, args);
  if (x.isinfected) then 
    c_inf:set_infection(__deceptinfect_infection_INF_STATE.INFECTED);
  else
    local v = x.inf;
    local ret = ({length = 1});
    ret[0] = v;
    c_inf:set_infection(__deceptinfect_infection_INF_STATE.NOT_INFECTED(ret));
  end;
end

__deceptinfect_infection_InfectionLookSystem.prototype.__class__ =  __deceptinfect_infection_InfectionLookSystem
__deceptinfect_infection_InfectionLookSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_infection_InfectionLookSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_radiation_ContaminationSystem.new = function() 
  local self = _hx_new(__deceptinfect_radiation_ContaminationSystem.prototype)
  __deceptinfect_radiation_ContaminationSystem.super(self)
  return self
end
__deceptinfect_radiation_ContaminationSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.radiation.ContaminationSystem"] = __deceptinfect_radiation_ContaminationSystem
__deceptinfect_radiation_ContaminationSystem.__name__ = "deceptinfect.radiation.ContaminationSystem"
__deceptinfect_radiation_ContaminationSystem.__interfaces__ = {__enumExtractor_EnumExtractor}
__deceptinfect_radiation_ContaminationSystem.prototype = _hx_e();

__deceptinfect_radiation_ContaminationSystem.prototype.__class__ =  __deceptinfect_radiation_ContaminationSystem
__deceptinfect_radiation_ContaminationSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_radiation_ContaminationSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_radiation_RadSourceSystem.new = function() 
  local self = _hx_new(__deceptinfect_radiation_RadSourceSystem.prototype)
  __deceptinfect_radiation_RadSourceSystem.super(self)
  return self
end
__deceptinfect_radiation_RadSourceSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.radiation.RadSourceSystem"] = __deceptinfect_radiation_RadSourceSystem
__deceptinfect_radiation_RadSourceSystem.__name__ = "deceptinfect.radiation.RadSourceSystem"
__deceptinfect_radiation_RadSourceSystem.__interfaces__ = {__enumExtractor_EnumExtractor}
__deceptinfect_radiation_RadSourceSystem.prototype = _hx_e();

__deceptinfect_radiation_RadSourceSystem.prototype.__class__ =  __deceptinfect_radiation_RadSourceSystem
__deceptinfect_radiation_RadSourceSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_radiation_RadSourceSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_game_LowHealthSystem.new = function() 
  local self = _hx_new(__deceptinfect_game_LowHealthSystem.prototype)
  __deceptinfect_game_LowHealthSystem.super(self)
  return self
end
__deceptinfect_game_LowHealthSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.game.LowHealthSystem"] = __deceptinfect_game_LowHealthSystem
__deceptinfect_game_LowHealthSystem.__name__ = "deceptinfect.game.LowHealthSystem"
__deceptinfect_game_LowHealthSystem.__interfaces__ = {__enumExtractor_EnumExtractor}
__deceptinfect_game_LowHealthSystem.prototype = _hx_e();

__deceptinfect_game_LowHealthSystem.prototype.__class__ =  __deceptinfect_game_LowHealthSystem
__deceptinfect_game_LowHealthSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_game_LowHealthSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_items_ScannerSystem.new = function() 
  local self = _hx_new(__deceptinfect_items_ScannerSystem.prototype)
  __deceptinfect_items_ScannerSystem.super(self)
  return self
end
__deceptinfect_items_ScannerSystem.super = function(self) 
  __deceptinfect_ecswip_System.super(self);
end
_hxClasses["deceptinfect.items.ScannerSystem"] = __deceptinfect_items_ScannerSystem
__deceptinfect_items_ScannerSystem.__name__ = "deceptinfect.items.ScannerSystem"
__deceptinfect_items_ScannerSystem.prototype = _hx_e();

__deceptinfect_items_ScannerSystem.prototype.__class__ =  __deceptinfect_items_ScannerSystem
__deceptinfect_items_ScannerSystem.__super__ = __deceptinfect_ecswip_System
setmetatable(__deceptinfect_items_ScannerSystem.prototype,{__index=__deceptinfect_ecswip_System.prototype})

__deceptinfect_ecswip_SystemManager.new = {}
_hxClasses["deceptinfect.ecswip.SystemManager"] = __deceptinfect_ecswip_SystemManager
__deceptinfect_ecswip_SystemManager.__name__ = "deceptinfect.ecswip.SystemManager"
__deceptinfect_ecswip_SystemManager.make = function() 
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_infection_InfectionSystem;
  _this.h[key] = __deceptinfect_infection_InfectionSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_client_GeigerSystem;
  _this.h[key] = __deceptinfect_client_GeigerSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_radiation_RadiationSystem;
  _this.h[key] = __deceptinfect_radiation_RadiationSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_ecswip_GrabSystem;
  _this.h[key] = __deceptinfect_ecswip_GrabSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_ecswip_HiddenHealthSystem;
  _this.h[key] = __deceptinfect_ecswip_HiddenHealthSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_game_WinSystem;
  _this.h[key] = __deceptinfect_game_WinSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_game_BatterySystem;
  _this.h[key] = __deceptinfect_game_BatterySystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_game_SpawnSystem;
  _this.h[key] = __deceptinfect_game_SpawnSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_statuses_WalkthroughSystem;
  _this.h[key] = __deceptinfect_statuses_WalkthroughSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_game_NestSystem;
  _this.h[key] = __deceptinfect_game_NestSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_game_EvacSystem;
  _this.h[key] = __deceptinfect_game_EvacSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_game_RagdollSystem;
  _this.h[key] = __deceptinfect_game_RagdollSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_game_SlowMotionSystem;
  _this.h[key] = __deceptinfect_game_SlowMotionSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_infection_InfectionLookSystem;
  _this.h[key] = __deceptinfect_infection_InfectionLookSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_radiation_ContaminationSystem;
  _this.h[key] = __deceptinfect_radiation_ContaminationSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_radiation_RadSourceSystem;
  _this.h[key] = __deceptinfect_radiation_RadSourceSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_game_LowHealthSystem;
  _this.h[key] = __deceptinfect_game_LowHealthSystem.new();
  _this.k[key] = true;
  local _this = __deceptinfect_ecswip_SystemManager.getSystems;
  local key = __deceptinfect_items_ScannerSystem;
  _this.h[key] = __deceptinfect_items_ScannerSystem.new();
  _this.k[key] = true;
end
__deceptinfect_ecswip_SystemManager.getSystem = function(cls) 
  do return __deceptinfect_ecswip_SystemManager.getSystems.h[cls] end;
end
__deceptinfect_ecswip_SystemManager.getSystemExp = function(name) 
  local key = Type.resolveClass(name);
  do return __deceptinfect_ecswip_SystemManager.getSystems.h[key] end;
end
_hx_exports["getSystem"] = __deceptinfect_ecswip_SystemManager.getSystemExp
__deceptinfect_ecswip_SystemManager.runAllSystems = function() 
  local _g = 0;
  local _g1 = __deceptinfect_ecswip_SystemManager.runSystems;
  while (_g < _g1.length) do 
    local clsSystem = _g1[_g];
    _g = _g + 1;
    __deceptinfect_ecswip_SystemManager.getSystems.h[clsSystem]:run();
  end;
end
__deceptinfect_ecswip_SystemManager.initAllSystems = function() 
  __deceptinfect_ecswip_SystemManager.make();
  local _g = 0;
  local _g1 = __deceptinfect_ecswip_SystemManager.runSystems;
  while (_g < _g1.length) do 
    local clsSystem = _g1[_g];
    _g = _g + 1;
    __deceptinfect_ecswip_SystemManager.getSystems.h[clsSystem]:init();
  end;
end
_hxClasses["deceptinfect.ecswip.ChooseVirPos"] = __deceptinfect_ecswip_ChooseVirPos;
_hxClasses["deceptinfect.ecswip.ChooseVirPos"] = { __ename__ = "deceptinfect.ecswip.ChooseVirPos", __constructs__ = _hx_tab_array({[0]="ENT","REAL"},2)}
__deceptinfect_ecswip_ChooseVirPos = _hxClasses["deceptinfect.ecswip.ChooseVirPos"];
__deceptinfect_ecswip_ChooseVirPos.ENT = function(x) local _x = _hx_tab_array({[0]="ENT",0,x,__enum__=__deceptinfect_ecswip_ChooseVirPos}, 3); return _x; end 
__deceptinfect_ecswip_ChooseVirPos.REAL = function(vec,ang) local _x = _hx_tab_array({[0]="REAL",1,vec,ang,__enum__=__deceptinfect_ecswip_ChooseVirPos}, 4); return _x; end 

__deceptinfect_ents_Di_battery.new = function(x) 
  local self = _hx_new(__deceptinfect_ents_Di_battery.prototype)
  __deceptinfect_ents_Di_battery.super(self,x)
  return self
end
__deceptinfect_ents_Di_battery.super = function(self,x) 
  self.properties = _hx_o({__fields__={Base=true},Base="base_anim"});
  self["self"] = x;
end
_hx_exports["di_battery"] = __deceptinfect_ents_Di_battery
_hxClasses["deceptinfect.ents.Di_battery"] = __deceptinfect_ents_Di_battery
__deceptinfect_ents_Di_battery.__name__ = "deceptinfect.ents.Di_battery"
__deceptinfect_ents_Di_battery.prototype = _hx_e();
__deceptinfect_ents_Di_battery.prototype.Draw = function(self,flags) 
  self["self"]:DrawModel();
end

__deceptinfect_ents_Di_battery.prototype.__class__ =  __deceptinfect_ents_Di_battery
__deceptinfect_ents_Di_battery.__super__ = {} or a
setmetatable(__deceptinfect_ents_Di_battery.prototype,{__index={} or a.prototype})

__deceptinfect_ents_Di_charger.new = function(x) 
  local self = _hx_new(__deceptinfect_ents_Di_charger.prototype)
  __deceptinfect_ents_Di_charger.super(self,x)
  return self
end
__deceptinfect_ents_Di_charger.super = function(self,x) 
  self.properties = _hx_o({__fields__={Base=true},Base="base_anim"});
  self["self"] = x;
end
_hx_exports["di_charger"] = __deceptinfect_ents_Di_charger
_hxClasses["deceptinfect.ents.Di_charger"] = __deceptinfect_ents_Di_charger
__deceptinfect_ents_Di_charger.__name__ = "deceptinfect.ents.Di_charger"
__deceptinfect_ents_Di_charger.prototype = _hx_e();
__deceptinfect_ents_Di_charger.prototype.Draw = function(self,flags) 
  self["self"]:DrawModel();
end

__deceptinfect_ents_Di_charger.prototype.__class__ =  __deceptinfect_ents_Di_charger
__deceptinfect_ents_Di_charger.__super__ = {} or a
setmetatable(__deceptinfect_ents_Di_charger.prototype,{__index={} or a.prototype})

__deceptinfect_game_ClientWeaponStatue.new = function() 
  local self = _hx_new(__deceptinfect_game_ClientWeaponStatue.prototype)
  __deceptinfect_game_ClientWeaponStatue.super(self)
  return self
end
__deceptinfect_game_ClientWeaponStatue.super = function(self) 
  __deceptinfect_ecswip_Component.super(self);
end
_hxClasses["deceptinfect.game.ClientWeaponStatue"] = __deceptinfect_game_ClientWeaponStatue
__deceptinfect_game_ClientWeaponStatue.__name__ = "deceptinfect.game.ClientWeaponStatue"
__deceptinfect_game_ClientWeaponStatue.prototype = _hx_e();

__deceptinfect_game_ClientWeaponStatue.prototype.__class__ =  __deceptinfect_game_ClientWeaponStatue
__deceptinfect_game_ClientWeaponStatue.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_game_ClientWeaponStatue.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_game_KeepRestart.new = function() 
  local self = _hx_new(__deceptinfect_game_KeepRestart.prototype)
  __deceptinfect_game_KeepRestart.super(self)
  return self
end
__deceptinfect_game_KeepRestart.super = function(self) 
  __deceptinfect_ecswip_Component.super(self);
end
_hxClasses["deceptinfect.game.KeepRestart"] = __deceptinfect_game_KeepRestart
__deceptinfect_game_KeepRestart.__name__ = "deceptinfect.game.KeepRestart"
__deceptinfect_game_KeepRestart.prototype = _hx_e();

__deceptinfect_game_KeepRestart.prototype.__class__ =  __deceptinfect_game_KeepRestart
__deceptinfect_game_KeepRestart.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_game_KeepRestart.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_game_RagInfo.new = function() 
  local self = _hx_new(__deceptinfect_game_RagInfo.prototype)
  __deceptinfect_game_RagInfo.super(self)
  return self
end
__deceptinfect_game_RagInfo.super = function(self) 
  __deceptinfect_ecswip_Component.super(self);
end
_hxClasses["deceptinfect.game.RagInfo"] = __deceptinfect_game_RagInfo
__deceptinfect_game_RagInfo.__name__ = "deceptinfect.game.RagInfo"
__deceptinfect_game_RagInfo.prototype = _hx_e();

__deceptinfect_game_RagInfo.prototype.__class__ =  __deceptinfect_game_RagInfo
__deceptinfect_game_RagInfo.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_game_RagInfo.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_game_Spawn.new = function(parent,vec) 
  local self = _hx_new(__deceptinfect_game_Spawn.prototype)
  __deceptinfect_game_Spawn.super(self,parent,vec)
  return self
end
__deceptinfect_game_Spawn.super = function(self,parent,vec) 
  self.distOrder = _hx_tab_array({}, 0);
  self.distStore = __haxe_ds_IntMap.new();
  self.vec = vec;
  self.parent = parent;
  self.id = parent.spawns.length;
end
_hxClasses["deceptinfect.game.Spawn"] = __deceptinfect_game_Spawn
__deceptinfect_game_Spawn.__name__ = "deceptinfect.game.Spawn"
__deceptinfect_game_Spawn.prototype = _hx_e();
__deceptinfect_game_Spawn.prototype.calculateDist = function(self,other) 
  local dist = self.vec:DistToSqr(other.vec);
  local key = other.id;
  local _this = self.distStore;
  if (dist == nil) then 
    _this.h[key] = __haxe_ds_IntMap.tnull;
  else
    _this.h[key] = dist;
  end;
  local tmp;
  if (self.maxdistID ~= nil) then 
    local ret = self.distStore.h[self.maxdistID];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    tmp = dist > ret;
  else
    tmp = true;
  end;
  if (tmp) then 
    self.maxdistID = other.id;
  end;
  local tmp;
  if (self.mindistID ~= nil) then 
    local ret = self.distStore.h[self.mindistID];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    tmp = dist < ret;
  else
    tmp = true;
  end;
  if (tmp) then 
    self.mindistID = other.id;
  end;
  self:insertNewSortedDist(other);
end
__deceptinfect_game_Spawn.prototype.insertNewSortedDist = function(self,other) 
  local i = 0;
  local insert = self.distOrder.length - 1;
  local _g = 0;
  local _g1 = self.distOrder;
  while (_g < _g1.length) do 
    local spawnid = _g1[_g];
    _g = _g + 1;
    local ret = self.distStore.h[spawnid];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local ret1 = self.distStore.h[other.id];
    if (ret1 == __haxe_ds_IntMap.tnull) then 
      ret1 = nil;
    end;
    if (ret > ret1) then 
      insert = i;
      break;
    end;
    i = i + 1;
  end;
  self.distOrder[insert] = other.id;
end

__deceptinfect_game_Spawn.prototype.__class__ =  __deceptinfect_game_Spawn

__deceptinfect_game_BoundsSpawn.new = function(parent,vec,bounds) 
  local self = _hx_new(__deceptinfect_game_BoundsSpawn.prototype)
  __deceptinfect_game_BoundsSpawn.super(self,parent,vec,bounds)
  return self
end
__deceptinfect_game_BoundsSpawn.super = function(self,parent,vec,bounds) 
  __deceptinfect_game_Spawn.super(self,parent,vec);
  self.bounds = bounds;
end
_hxClasses["deceptinfect.game.BoundsSpawn"] = __deceptinfect_game_BoundsSpawn
__deceptinfect_game_BoundsSpawn.__name__ = "deceptinfect.game.BoundsSpawn"
__deceptinfect_game_BoundsSpawn.prototype = _hx_e();

__deceptinfect_game_BoundsSpawn.prototype.__class__ =  __deceptinfect_game_BoundsSpawn
__deceptinfect_game_BoundsSpawn.__super__ = __deceptinfect_game_Spawn
setmetatable(__deceptinfect_game_BoundsSpawn.prototype,{__index=__deceptinfect_game_Spawn.prototype})

__deceptinfect_game_StatInfo.new = function() 
  local self = _hx_new(__deceptinfect_game_StatInfo.prototype)
  __deceptinfect_game_StatInfo.super(self)
  return self
end
__deceptinfect_game_StatInfo.super = function(self) 
  __deceptinfect_ecswip_Component.super(self);
end
_hxClasses["deceptinfect.game.StatInfo"] = __deceptinfect_game_StatInfo
__deceptinfect_game_StatInfo.__name__ = "deceptinfect.game.StatInfo"
__deceptinfect_game_StatInfo.prototype = _hx_e();

__deceptinfect_game_StatInfo.prototype.__class__ =  __deceptinfect_game_StatInfo
__deceptinfect_game_StatInfo.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_game_StatInfo.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_game_Statue.new = function() 
  local self = _hx_new(__deceptinfect_game_Statue.prototype)
  __deceptinfect_game_Statue.super(self)
  return self
end
__deceptinfect_game_Statue.super = function(self) 
  __deceptinfect_ecswip_Component.super(self);
end
_hxClasses["deceptinfect.game.Statue"] = __deceptinfect_game_Statue
__deceptinfect_game_Statue.__name__ = "deceptinfect.game.Statue"
__deceptinfect_game_Statue.prototype = _hx_e();

__deceptinfect_game_Statue.prototype.__class__ =  __deceptinfect_game_Statue
__deceptinfect_game_Statue.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_game_Statue.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_infection_InfectedComponent.new = function() 
  local self = _hx_new(__deceptinfect_infection_InfectedComponent.prototype)
  __deceptinfect_infection_InfectedComponent.super(self)
  return self
end
__deceptinfect_infection_InfectedComponent.super = function(self) 
  __deceptinfect_ecswip_Component.super(self);
end
_hxClasses["deceptinfect.infection.InfectedComponent"] = __deceptinfect_infection_InfectedComponent
__deceptinfect_infection_InfectedComponent.__name__ = "deceptinfect.infection.InfectedComponent"
__deceptinfect_infection_InfectedComponent.prototype = _hx_e();

__deceptinfect_infection_InfectedComponent.prototype.__class__ =  __deceptinfect_infection_InfectedComponent
__deceptinfect_infection_InfectedComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_infection_InfectedComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})

__deceptinfect_infection_InfectionComponent.new = function() 
  local self = _hx_new(__deceptinfect_infection_InfectionComponent.prototype)
  __deceptinfect_infection_InfectionComponent.super(self)
  return self
end
__deceptinfect_infection_InfectionComponent.super = function(self) 
  self.__uid = _hx_bit.bor(_hx_bit.lshift(__hxbit_Serializer.SEQ,24),(function() 
  local _hx_obj = __hxbit_Serializer;
  local _hx_fld = 'UID';
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _hx_obj[_hx_fld];
   end)());
  self.__bits = 0;
  self.acceptingInfection = __deceptinfect_infection_AcceptingInfection.ACCEPTING;
  self.baseInfection = __deceptinfect_infection_BaseInfection.USING_GLOBAL;
  self.rate = 1;
  local ret = ({length = 1});
  ret[0] = 0.0;
  self.infection = __deceptinfect_infection_INF_STATE.NOT_INFECTED(ret);
  self:networkInitProxys();
  __deceptinfect_ecswip_Component.super(self);
end
_hxClasses["deceptinfect.infection.InfectionComponent"] = __deceptinfect_infection_InfectionComponent
__deceptinfect_infection_InfectionComponent.__name__ = "deceptinfect.infection.InfectionComponent"
__deceptinfect_infection_InfectionComponent.__interfaces__ = {__hxbit_NetworkSerializable}
__deceptinfect_infection_InfectionComponent.prototype = _hx_e();
__deceptinfect_infection_InfectionComponent.prototype.getInfValue = function(self) 
  local _g = self.infection;
  local tmp = _g[1];
  if (tmp) == 0 then 
    do return _g[2][0] end;
  elseif (tmp) == 1 then 
    do return 100 end; end;
end
__deceptinfect_infection_InfectionComponent.prototype.set_infection = function(self,x) 
  if (not Type.enumEq(self.infection, x)) then 
    if (((self.__host ~= nil) and (self.__host.isAuth or self.__host:checkWrite(self, 0))) and ((self.__next ~= nil) or self.__host:mark(self))) then 
      local tmp = self;
      tmp.__bits = _hx_bit.bor(tmp.__bits,1);
    end;
  end;
  self.infection = x do return self.infection end
end
__deceptinfect_infection_InfectionComponent.prototype.set_enableReplication = function(self,b) 
  __hxbit_NetworkHost.enableReplication(self, b);
  do return b end
end
__deceptinfect_infection_InfectionComponent.prototype.networkAllow = function(self,mode,prop,client) 
  do return false end
end
__deceptinfect_infection_InfectionComponent.prototype.alive = function(self) 
  self:set_enableReplication(true);
end
__deceptinfect_infection_InfectionComponent.prototype.networkFlush = function(self,ctx) 
  local b = self.__bits;
  local v = self.__bits;
  if ((v >= 0) and (v < 128)) then 
    ctx.out.b:push(v);
  else
    ctx.out.b:push(128);
    ctx.out:addInt32(v);
  end;
  if ((_hx_bit.band(b,1)) ~= 0) then 
    __hxbit_enumSer_Deceptinfect_infection_INF_STATE.doSerialize(ctx, self.infection);
  end;
  self.__bits = 0;
end
__deceptinfect_infection_InfectionComponent.prototype.networkSync = function(self,ctx) 
  if ((_hx_bit.band(self.__bits,1)) ~= 0) then 
    self:set_infection(__hxbit_enumSer_Deceptinfect_infection_INF_STATE.doUnserialize(ctx));
  end;
end
__deceptinfect_infection_InfectionComponent.prototype.networkInitProxys = function(self) 
end
__deceptinfect_infection_InfectionComponent.prototype.networkRPC = function(self,__ctx,__id,__clientResult) 
  _G.error(__haxe_Exception.thrown(Std.string("Unknown RPC identifier ") .. Std.string(__id)),0);
end
__deceptinfect_infection_InfectionComponent.prototype.networkGetName = function(self,id,isRPC) 
  if (isRPC == nil) then 
    isRPC = false;
  end;
  if ((function() 
    local _hx_1
    if (isRPC) then 
    _hx_1 = id + 1; else 
    _hx_1 = id; end
    return _hx_1
  end )() == 0) then 
    do return "infection" end;
  else
    do return nil end;
  end;
end
__deceptinfect_infection_InfectionComponent.prototype.getCLID = function(self) 
  do return __deceptinfect_infection_InfectionComponent.__clid end
end
__deceptinfect_infection_InfectionComponent.prototype.serialize = function(self,__ctx) 
  __hxbit_enumSer_Deceptinfect_infection_INF_STATE.doSerialize(__ctx, self.infection);
end
__deceptinfect_infection_InfectionComponent.prototype.getSerializeSchema = function(self) 
  local schema = __hxbit_Schema.new();
  schema.fieldsNames:push("infection");
  schema.fieldsTypes:push(__hxbit_PropTypeDesc.PEnum("deceptinfect.infection.INF_STATE"));
  schema.isFinal = __hxbit_Serializer.isClassFinal(__deceptinfect_infection_InfectionComponent.__clid);
  do return schema end
end
__deceptinfect_infection_InfectionComponent.prototype.unserializeInit = function(self) 
  local ret = ({length = 1});
  ret[0] = 0.0;
  self:set_infection(__deceptinfect_infection_INF_STATE.NOT_INFECTED(ret));
  self.rate = 1;
  self.baseInfection = __deceptinfect_infection_BaseInfection.USING_GLOBAL;
  self.acceptingInfection = __deceptinfect_infection_AcceptingInfection.ACCEPTING;
  self.__bits = 0;
end
__deceptinfect_infection_InfectionComponent.prototype.unserialize = function(self,__ctx) 
  self:set_infection(__hxbit_enumSer_Deceptinfect_infection_INF_STATE.doUnserialize(__ctx));
end

__deceptinfect_infection_InfectionComponent.prototype.__class__ =  __deceptinfect_infection_InfectionComponent
__deceptinfect_infection_InfectionComponent.__super__ = __deceptinfect_ecswip_Component
setmetatable(__deceptinfect_infection_InfectionComponent.prototype,{__index=__deceptinfect_ecswip_Component.prototype})
_hxClasses["deceptinfect.infection.AcceptingInfection"] = __deceptinfect_infection_AcceptingInfection;
_hxClasses["deceptinfect.infection.AcceptingInfection"] = { __ename__ = "deceptinfect.infection.AcceptingInfection", __constructs__ = _hx_tab_array({[0]="ACCEPTING","REJECTING"},2)}
__deceptinfect_infection_AcceptingInfection = _hxClasses["deceptinfect.infection.AcceptingInfection"];
__deceptinfect_infection_AcceptingInfection.ACCEPTING = _hx_tab_array({[0]="ACCEPTING",0,__enum__ = __deceptinfect_infection_AcceptingInfection},2)

__deceptinfect_infection_AcceptingInfection.REJECTING = _hx_tab_array({[0]="REJECTING",1,__enum__ = __deceptinfect_infection_AcceptingInfection},2)

_hxClasses["deceptinfect.infection.BaseInfection"] = __deceptinfect_infection_BaseInfection;
_hxClasses["deceptinfect.infection.BaseInfection"] = { __ename__ = "deceptinfect.infection.BaseInfection", __constructs__ = _hx_tab_array({[0]="NOT_USING","USING_GLOBAL","USING_STATIC"},3)}
__deceptinfect_infection_BaseInfection = _hxClasses["deceptinfect.infection.BaseInfection"];
__deceptinfect_infection_BaseInfection.NOT_USING = _hx_tab_array({[0]="NOT_USING",0,__enum__ = __deceptinfect_infection_BaseInfection},2)

__deceptinfect_infection_BaseInfection.USING_GLOBAL = _hx_tab_array({[0]="USING_GLOBAL",1,__enum__ = __deceptinfect_infection_BaseInfection},2)

__deceptinfect_infection_BaseInfection.USING_STATIC = function(rate) local _x = _hx_tab_array({[0]="USING_STATIC",2,rate,__enum__=__deceptinfect_infection_BaseInfection}, 3); return _x; end 
_hxClasses["deceptinfect.infection.INF_STATE"] = __deceptinfect_infection_INF_STATE;
_hxClasses["deceptinfect.infection.INF_STATE"] = { __ename__ = "deceptinfect.infection.INF_STATE", __constructs__ = _hx_tab_array({[0]="NOT_INFECTED","INFECTED"},2)}
__deceptinfect_infection_INF_STATE = _hxClasses["deceptinfect.infection.INF_STATE"];
__deceptinfect_infection_INF_STATE.NOT_INFECTED = function(inf) local _x = _hx_tab_array({[0]="NOT_INFECTED",0,inf,__enum__=__deceptinfect_infection_INF_STATE}, 3); return _x; end 
__deceptinfect_infection_INF_STATE.INFECTED = _hx_tab_array({[0]="INFECTED",1,__enum__ = __deceptinfect_infection_INF_STATE},2)


__deceptinfect_items_Di_cure.new = function(x) 
  local self = _hx_new(__deceptinfect_items_Di_cure.prototype)
  __deceptinfect_items_Di_cure.super(self,x)
  return self
end
__deceptinfect_items_Di_cure.super = function(self,x) 
  self.properties = _hx_o({__fields__={Primary=true},Primary=_hx_o({__fields__={Ammo=true,ClipSize=true,DefaultClip=true,Automatic=true},Ammo="None",ClipSize=-1,DefaultClip=-1,Automatic=true})});
  self["self"] = x;
end
_hx_exports["di_cure"] = __deceptinfect_items_Di_cure
_hxClasses["deceptinfect.items.Di_cure"] = __deceptinfect_items_Di_cure
__deceptinfect_items_Di_cure.__name__ = "deceptinfect.items.Di_cure"
__deceptinfect_items_Di_cure.prototype = _hx_e();

__deceptinfect_items_Di_cure.prototype.__class__ =  __deceptinfect_items_Di_cure
__deceptinfect_items_Di_cure.__super__ = {} or a
setmetatable(__deceptinfect_items_Di_cure.prototype,{__index={} or a.prototype})

__deceptinfect_items_Weapon_Di_Scan.new = function(x) 
  local self = _hx_new(__deceptinfect_items_Weapon_Di_Scan.prototype)
  __deceptinfect_items_Weapon_Di_Scan.super(self,x)
  return self
end
__deceptinfect_items_Weapon_Di_Scan.super = function(self,x) 
  self.properties = _hx_o({__fields__={Primary=true},Primary=_hx_o({__fields__={Ammo=true,ClipSize=true,DefaultClip=true,Automatic=true},Ammo="Smg1",ClipSize=-1,DefaultClip=-1,Automatic=true})});
  self["self"] = x;
end
_hx_exports["weapon_di_scan"] = __deceptinfect_items_Weapon_Di_Scan
_hxClasses["deceptinfect.items.Weapon_Di_Scan"] = __deceptinfect_items_Weapon_Di_Scan
__deceptinfect_items_Weapon_Di_Scan.__name__ = "deceptinfect.items.Weapon_Di_Scan"
__deceptinfect_items_Weapon_Di_Scan.prototype = _hx_e();

__deceptinfect_items_Weapon_Di_Scan.prototype.__class__ =  __deceptinfect_items_Weapon_Di_Scan
__deceptinfect_items_Weapon_Di_Scan.__super__ = {} or a
setmetatable(__deceptinfect_items_Weapon_Di_Scan.prototype,{__index={} or a.prototype})

__deceptinfect_util_EntityExt.new = {}
_hxClasses["deceptinfect.util.EntityExt"] = __deceptinfect_util_EntityExt
__deceptinfect_util_EntityExt.__name__ = "deceptinfect.util.EntityExt"
__deceptinfect_util_EntityExt.validID2 = function(x) 
  if (_G.IsValid(x)) then 
    local _g = x.id;
    if (_g == nil) then 
      do return __deceptinfect_util_ValidID.NO_ID end;
    else
      do return __deceptinfect_util_ValidID.HAS_ID(_g) end;
    end;
  else
    do return __deceptinfect_util_ValidID.INVALID end;
  end;
end
_hxClasses["deceptinfect.util.ValidID"] = __deceptinfect_util_ValidID;
_hxClasses["deceptinfect.util.ValidID"] = { __ename__ = "deceptinfect.util.ValidID", __constructs__ = _hx_tab_array({[0]="HAS_ID","NO_ID","INVALID"},3)}
__deceptinfect_util_ValidID = _hxClasses["deceptinfect.util.ValidID"];
__deceptinfect_util_ValidID.HAS_ID = function(id) local _x = _hx_tab_array({[0]="HAS_ID",0,id,__enum__=__deceptinfect_util_ValidID}, 3); return _x; end 
__deceptinfect_util_ValidID.NO_ID = _hx_tab_array({[0]="NO_ID",1,__enum__ = __deceptinfect_util_ValidID},2)

__deceptinfect_util_ValidID.INVALID = _hx_tab_array({[0]="INVALID",2,__enum__ = __deceptinfect_util_ValidID},2)


__deceptinfect_util_MinMaxTools.new = {}
_hxClasses["deceptinfect.util.MinMaxTools"] = __deceptinfect_util_MinMaxTools
__deceptinfect_util_MinMaxTools.__name__ = "deceptinfect.util.MinMaxTools"
__deceptinfect_util_MinMaxTools.getCenter = function(x) 
  local this1 = x.maxs;
  local otherVec = x.mins;
  local this1 = this1 - otherVec;
  local this1 = this1 / 2;
  local otherVec = x.mins;
  do return this1 + otherVec end;
end

__deceptinfect_util_Util.new = {}
_hxClasses["deceptinfect.util.Util"] = __deceptinfect_util_Util
__deceptinfect_util_Util.__name__ = "deceptinfect.util.Util"
__deceptinfect_util_Util.printTimer_2 = function(ident,time,run) 
  if (__deceptinfect_util_Util.mappy_2.h[ident] ~= nil) then 
    local ret = __deceptinfect_util_Util.mappy_2.h[ident];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    if (_G.CurTime() > ret) then 
      run();
      local this1 = __deceptinfect_util_Util.mappy_2;
      local value = _G.CurTime() + time;
      local _this = this1;
      if (value == nil) then 
        _this.h[ident] = __haxe_ds_IntMap.tnull;
      else
        _this.h[ident] = value;
      end;
    end;
  else
    run();
    local this1 = __deceptinfect_util_Util.mappy_2;
    local value = _G.CurTime() + time;
    local _this = this1;
    if (value == nil) then 
      _this.h[ident] = __haxe_ds_IntMap.tnull;
    else
      _this.h[ident] = value;
    end;
  end;
end

__gmod_PairTools.new = {}
_hxClasses["gmod.PairTools"] = __gmod_PairTools
__gmod_PairTools.__name__ = "gmod.PairTools"
__gmod_PairTools.keyValueIterator = function(table) 
  local _hx_1_p_next, _hx_1_p_table, _hx_1_p_index = _G.pairs(table);
  local next = _hx_1_p_next;
  local i = _hx_1_p_index;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local _hx_2_res_index, _hx_2_res_value = next(table, i);
    i = _hx_2_res_index;
    do return _hx_o({__fields__={key=true,value=true},key=_hx_2_res_index,value=_hx_2_res_value}) end;
  end,hasNext=function(self) 
    do return _G.select(2, _G.next(table, i)) ~= nil end;
  end}) end;
end
__gmod_PairTools.iterator = function(table) 
  local _hx_1_p_next, _hx_1_p_table, _hx_1_p_index = _G.pairs(table);
  local next = _hx_1_p_next;
  local i = _hx_1_p_index;
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local _hx_2_res_index, _hx_2_res_value = next(table, i);
    i = _hx_2_res_index;
    do return _hx_2_res_value end;
  end,hasNext=function(self) 
    do return _G.select(2, _G.next(table, i)) ~= nil end;
  end}) end;
end

__gmod_cpanel_PanelBuild.new = {}
_hxClasses["gmod.cpanel.PanelBuild"] = __gmod_cpanel_PanelBuild
__gmod_cpanel_PanelBuild.__name__ = "gmod.cpanel.PanelBuild"

__hxbit_NetworkHost.new = function() 
  local self = _hx_new(__hxbit_NetworkHost.prototype)
  __hxbit_NetworkHost.super(self)
  return self
end
__hxbit_NetworkHost.super = function(self) 
  self.rpcWaits = __haxe_ds_IntMap.new();
  self.rpcUID = Std.random(16777216);
  self.lastSentBytes = 0;
  self.lastSentTime = 0.;
  self.perPacketBytes = 20;
  self.syncingProperties = false;
  self.totalSentBytes = 0;
  self.sendRate = 0.;
  __hxbit_NetworkHost.current = self;
  self.isAuth = true;
  self["self"] = __hxbit_NetworkClient.new(self);
  self.clients = _hx_tab_array({}, 0);
  self.aliveEvents = _hx_tab_array({}, 0);
  self.pendingClients = _hx_tab_array({}, 0);
  self:resetState();
end
_hxClasses["hxbit.NetworkHost"] = __hxbit_NetworkHost
__hxbit_NetworkHost.__name__ = "hxbit.NetworkHost"
__hxbit_NetworkHost.sortByUID = function(o1,o2) 
  do return o1.__uid - o2.__uid end;
end
__hxbit_NetworkHost.sortByUIDDesc = function(o1,o2) 
  do return o2.__uid - o1.__uid end;
end
__hxbit_NetworkHost.enableReplication = function(o,b) 
  if (b) then 
    if (o.__host ~= nil) then 
      do return end;
    end;
    if (__hxbit_NetworkHost.current == nil) then 
      _G.error(__haxe_Exception.thrown("No NetworkHost defined"),0);
    end;
    __hxbit_NetworkHost.current:register(o);
  else
    if (o.__host == nil) then 
      do return end;
    end;
    o.__host:unregister(o);
  end;
end
__hxbit_NetworkHost.prototype = _hx_e();
__hxbit_NetworkHost.prototype.resetState = function(self) 
  __hxbit_Serializer.resetCounters();
  self.ctx = __hxbit_NetworkSerializer.new();
  self.ctx.newObjects = _hx_tab_array({}, 0);
  self.ctx:begin();
end
__hxbit_NetworkHost.prototype.checkWrite = function(self,o,vid) 
  if (not self.isAuth and not o:networkAllow(3, vid, self["self"].ownerObject)) then 
    self:logError("Setting a property on a not allowed object", o.__uid);
    do return false end;
  end;
  do return true end
end
__hxbit_NetworkHost.prototype.mark = function(self,o) 
  o.__next = self.markHead;
  self.markHead = o;
  do return true end
end
__hxbit_NetworkHost.prototype.logError = function(self,msg,objectId) 
  _G.error(__haxe_Exception.thrown(Std.string(msg) .. Std.string(((function() 
    local _hx_1
    if (objectId == nil) then 
    _hx_1 = ""; else 
    _hx_1 = Std.string(Std.string("(") .. Std.string(objectId)) .. Std.string(")"); end
    return _hx_1
  end )()))),0);
end
__hxbit_NetworkHost.prototype.onMessage = function(self,from,msg) 
end
__hxbit_NetworkHost.prototype.onUnregister = function(self,o) 
end
__hxbit_NetworkHost.prototype.onCustom = function(self,from,id,data) 
end
__hxbit_NetworkHost.prototype.sendMessage = function(self,msg,to) 
  self:flush();
  local prev = self.targetClient;
  self.targetClient = to;
  if (__lua_Boot.__instanceof(msg, __haxe_io_Bytes)) then 
    self.ctx.out.b:push(9);
    local _this = self.ctx;
    local b = msg;
    if (b == nil) then 
      _this.out.b:push(0);
    else
      local v = b.length + 1;
      if ((v >= 0) and (v < 128)) then 
        _this.out.b:push(v);
      else
        _this.out.b:push(128);
        _this.out:addInt32(v);
      end;
      local _this = _this.out;
      local b2 = b.b;
      local _g = 0;
      local _g1 = b.length;
      while (_g < _g1) do 
        _g = _g + 1;
        _this.b:push(b2[_g - 1]);
      end;
    end;
  else
    self.ctx.out.b:push(8);
    local _this = self.ctx;
    local s = __haxe_Serializer.run(msg);
    if (s == nil) then 
      _this.out.b:push(0);
    else
      local b = __haxe_io_Bytes.ofString(s);
      local v = b.length + 1;
      if ((v >= 0) and (v < 128)) then 
        _this.out.b:push(v);
      else
        _this.out.b:push(128);
        _this.out:addInt32(v);
      end;
      local _this = _this.out;
      local b2 = b.b;
      local _g = 0;
      local _g1 = b.length;
      while (_g < _g1) do 
        _g = _g + 1;
        _this.b:push(b2[_g - 1]);
      end;
    end;
  end;
  self.ctx.out.b:push(255);
  self:doSend();
  self.targetClient = prev;
end
__hxbit_NetworkHost.prototype.beginRPC = function(self,o,id,onResult) 
  self:flushProps();
  local ret = self.ctx.refs.h[o.__uid];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  if (ret == nil) then 
    _G.error(__haxe_Exception.thrown("Can't call RPC on an object not previously transferred"),0);
  end;
  if (onResult ~= nil) then 
    local id = (function() 
    local _hx_obj = self;
    local _hx_fld = 'rpcUID';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    self.ctx.out.b:push(6);
    local _this = self.ctx;
    if ((id >= 0) and (id < 128)) then 
      _this.out.b:push(id);
    else
      _this.out.b:push(128);
      _this.out:addInt32(id);
    end;
    local _this = self.rpcWaits;
    if (onResult == nil) then 
      _this.h[id] = __haxe_ds_IntMap.tnull;
    else
      _this.h[id] = onResult;
    end;
  else
    self.ctx.out.b:push(5);
  end;
  local _this = self.ctx;
  local v = o.__uid;
  if ((v >= 0) and (v < 128)) then 
    _this.out.b:push(v);
  else
    _this.out.b:push(128);
    _this.out:addInt32(v);
  end;
  self.ctx.out:addInt32(-1);
  self.ctx.out.b:push(id);
  if (self.logger ~= nil) then 
    self:logger(Std.string(Std.string(Std.string(Std.string(Std.string("RPC > ") .. Std.string(Std.string(o))) .. Std.string("#")) .. Std.string(o.__uid)) .. Std.string(" ")) .. Std.string(o:networkGetName(id, true)));
  end;
  if (self.stats ~= nil) then 
    self.stats:beginRPC(o, id);
  end;
  do return self.ctx end
end
__hxbit_NetworkHost.prototype.endRPC = function(self) 
  self.ctx.out.b:push(255);
end
__hxbit_NetworkHost.prototype.fullSync = function(self,c) 
  if (not self.pendingClients:remove(c)) then 
    do return end;
  end;
  self:flush();
  local seq = self.clients.length + 1;
  while (true) do 
    local found = false;
    local _g = 0;
    local _g1 = self.clients;
    while (_g < _g1.length) do 
      local c = _g1[_g];
      _g = _g + 1;
      if (c.seqID == seq) then 
        found = true;
        break;
      end;
    end;
    if (not found) then 
      break;
    end;
    seq = seq + 1;
  end;
  if (seq > 255) then 
    _G.error(__haxe_Exception.thrown("Out of sequence number"),0);
  end;
  self.ctx.out.b:push(seq);
  c.seqID = seq;
  self.clients:push(c);
  local refs = self.ctx.refs;
  self.ctx.enableChecks = false;
  self.ctx:begin();
  self.ctx.out.b:push(4);
  self.ctx.out.b:push(c.seqID);
  local _this = self.ctx;
  local b = __hxbit_Serializer.getSignature();
  if (b == nil) then 
    _this.out.b:push(0);
  else
    local v = b.length + 1;
    if ((v >= 0) and (v < 128)) then 
      _this.out.b:push(v);
    else
      _this.out.b:push(128);
      _this.out:addInt32(v);
    end;
    local _this = _this.out;
    local b2 = b.b;
    local _g = 0;
    local _g1 = b.length;
    while (_g < _g1) do 
      _g = _g + 1;
      _this.b:push(b2[_g - 1]);
    end;
  end;
  local _g = _hx_tab_array({}, 0);
  local o = refs:iterator();
  while (o:hasNext()) do 
    local o = o:next();
    if (o ~= nil) then 
      _g:push(o);
    end;
  end;
  _g:sort(__hxbit_NetworkHost.sortByUID);
  local _g1 = 0;
  while (_g1 < _g.length) do 
    local o = _g[_g1];
    _g1 = _g1 + 1;
    self.ctx:addAnyRef(o);
  end;
  self.ctx:addAnyRef(nil);
  self.ctx.out.b:push(255);
  self.ctx.enableChecks = true;
  self.targetClient = c;
  self:doSend();
  self.targetClient = nil;
end
__hxbit_NetworkHost.prototype.defaultLogger = function(self,filter) 
  local _gthis = self;
  local t0 = Sys.time();
  self:setLogger(function(str) 
    if ((filter ~= nil) and not filter(str)) then 
      do return end;
    end;
    str = Std.string(((function() 
      local _hx_1
      if (_gthis.isAuth) then 
      _hx_1 = "[S] "; else 
      _hx_1 = "[C] "; end
      return _hx_1
    end )())) .. Std.string(str);
    str = Std.string(Std.string(Std.int((Sys.time() - t0) * 100) / 100) .. Std.string(" ")) .. Std.string(str);
    _G.print(Std.string(str));
  end);
end
__hxbit_NetworkHost.prototype.makeAlive = function(self) 
  local objs = self.ctx.newObjects;
  if (objs.length == 0) then 
    do return end;
  end;
  objs:sort(__hxbit_NetworkHost.sortByUIDDesc);
  local _hx_continue_1 = false;
  while (true) do repeat 
    local o = objs:pop();
    if (o == nil) then 
      _hx_continue_1 = true;break;
    end;
    local n = (function() 
      local _hx_1
      if (__lua_Boot.__instanceof(o, __hxbit_NetworkSerializable)) then 
      _hx_1 = o; else 
      _hx_1 = nil; end
      return _hx_1
    end )();
    if (n == nil) then 
      break;
    end;
    if (self.logger ~= nil) then 
      self:logger(Std.string(Std.string(Std.string("Alive ") .. Std.string(Std.string(n))) .. Std.string("#")) .. Std.string(n.__uid));
    end;
    n.__host = self;
    n:alive();until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  while (self.aliveEvents.length > 0) do 
    (self.aliveEvents:shift())();
  end;
end
__hxbit_NetworkHost.prototype.setLogger = function(self,log) 
  self.logger = _hx_funcToField(log);
end
__hxbit_NetworkHost.prototype.register = function(self,o) 
  o.__host = self;
  local ret = self.ctx.refs.h[o.__uid];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  local o2 = ret;
  if (o2 ~= nil) then 
    if (o2 ~= o) then 
      self:logError("Register conflict between objects", o.__uid);
    end;
    do return end;
  end;
  if (not self.isAuth and not o:networkAllow(4, 0, self["self"].ownerObject)) then 
    _G.error(__haxe_Exception.thrown(Std.string(Std.string("Can't register ") .. Std.string(Std.string(o))) .. Std.string(" without ownership")),0);
  end;
  if (self.logger ~= nil) then 
    self:logger(Std.string(Std.string(Std.string("Register ") .. Std.string(Std.string(o))) .. Std.string("#")) .. Std.string(o.__uid));
  end;
  self.ctx.out.b:push(2);
  self.ctx:addAnyRef(o);
  self.ctx.out.b:push(255);
end
__hxbit_NetworkHost.prototype.unmark = function(self,o) 
  if (o.__next == nil) then 
    do return end;
  end;
  local prev = nil;
  local h = self.markHead;
  while (h ~= o) do 
    prev = h;
    h = h.__next;
  end;
  if (prev == nil) then 
    self.markHead = o.__next;
  else
    prev.__next = o.__next;
  end;
  o.__next = nil;
end
__hxbit_NetworkHost.prototype.unregister = function(self,o) 
  if (o.__host == nil) then 
    do return end;
  end;
  if (not self.isAuth and not o:networkAllow(5, 0, self["self"].ownerObject)) then 
    _G.error(__haxe_Exception.thrown(Std.string(Std.string("Can't unregister ") .. Std.string(Std.string(o))) .. Std.string(" without ownership")),0);
  end;
  self:flushProps();
  o.__host = nil;
  o.__bits = 0;
  self:unmark(o);
  if (self.logger ~= nil) then 
    self:logger(Std.string(Std.string(Std.string("Unregister ") .. Std.string(Std.string(o))) .. Std.string("#")) .. Std.string(o.__uid));
  end;
  self.ctx.out.b:push(3);
  local _this = self.ctx;
  local v = o.__uid;
  if ((v >= 0) and (v < 128)) then 
    _this.out.b:push(v);
  else
    _this.out.b:push(128);
    _this.out:addInt32(v);
  end;
  self.ctx.out.b:push(255);
  self.ctx.refs:remove(o.__uid);
end
__hxbit_NetworkHost.prototype.doSend = function(self) 
  local bytes;
  bytes = self.ctx.out:getBytes();
  self.ctx.out = __haxe_io_BytesBuffer.new();
  self:send(bytes);
end
__hxbit_NetworkHost.prototype.send = function(self,bytes) 
  if (self.targetClient ~= nil) then 
    local tmp = self;
    tmp.totalSentBytes = tmp.totalSentBytes + (bytes.length + self.perPacketBytes);
    self.targetClient:send(bytes);
  else
    local tmp = self;
    tmp.totalSentBytes = tmp.totalSentBytes + ((bytes.length + self.perPacketBytes) * self.clients.length);
    if (self.clients.length == 0) then 
      local tmp = self;
      tmp.totalSentBytes = tmp.totalSentBytes + (bytes.length + self.perPacketBytes);
    end;
    local _g = 0;
    local _g1 = self.clients;
    while (_g < _g1.length) do 
      local c = _g1[_g];
      _g = _g + 1;
      c:send(bytes);
    end;
  end;
end
__hxbit_NetworkHost.prototype.flushProps = function(self) 
  local o = self.markHead;
  while (o ~= nil) do 
    if (o.__bits ~= 0) then 
      if (self.logger ~= nil) then 
        local props = _hx_tab_array({}, 0);
        local i = 0;
        while ((_hx_bit.lshift(1,i)) <= o.__bits) do 
          if ((_hx_bit.band(o.__bits,_hx_bit.lshift(1,i))) ~= 0) then 
            props:push(o:networkGetName(i));
          end;
          i = i + 1;
        end;
        self:logger(Std.string(Std.string(Std.string(Std.string(Std.string("SYNC > ") .. Std.string(Std.string(o))) .. Std.string("#")) .. Std.string(o.__uid)) .. Std.string(" ")) .. Std.string(props:join("|")));
      end;
      if (self.stats ~= nil) then 
        self.stats:sync(o);
      end;
      self.ctx.out.b:push(1);
      local _this = self.ctx;
      local v = o.__uid;
      if ((v >= 0) and (v < 128)) then 
        _this.out.b:push(v);
      else
        _this.out.b:push(128);
        _this.out:addInt32(v);
      end;
      o:networkFlush(self.ctx);
      self.ctx.out.b:push(255);
    end;
    local n = o.__next;
    o.__next = nil;
    o = n;
  end;
  self.markHead = nil;
end
__hxbit_NetworkHost.prototype.flush = function(self) 
  self:flushProps();
  if (self.ctx.out.b.length > 0) then 
    self:doSend();
  end;
  local now = Sys.time();
  local dt = now - self.lastSentTime;
  if (dt < 1) then 
    do return end;
  end;
  local rate = (self.totalSentBytes - self.lastSentBytes) / dt;
  if ((((self.sendRate == 0) or (rate == 0)) or ((rate / self.sendRate) > 3)) or ((self.sendRate / rate) > 3)) then 
    self.sendRate = rate;
  else
    self.sendRate = (self.sendRate * 0.8) + (rate * 0.2);
  end;
  self.lastSentTime = now;
  self.lastSentBytes = self.totalSentBytes;
  local _g = 0;
  local _g1 = self.clients;
  while (_g < _g1.length) do 
    local c = _g1[_g];
    _g = _g + 1;
    if ((now - c.lastMessage) > __hxbit_NetworkHost.CLIENT_TIMEOUT) then 
      c:stop();
    end;
  end;
end

__hxbit_NetworkHost.prototype.__class__ =  __hxbit_NetworkHost

__haxe_ds_IntMap.new = function() 
  local self = _hx_new(__haxe_ds_IntMap.prototype)
  __haxe_ds_IntMap.super(self)
  return self
end
__haxe_ds_IntMap.super = function(self) 
  self.h = ({});
end
_hxClasses["haxe.ds.IntMap"] = __haxe_ds_IntMap
__haxe_ds_IntMap.__name__ = "haxe.ds.IntMap"
__haxe_ds_IntMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_IntMap.prototype = _hx_e();
__haxe_ds_IntMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  do return ret end
end
__haxe_ds_IntMap.prototype.remove = function(self,key) 
  if (self.h[key] == nil) then 
    do return false end;
  else
    self.h[key] = nil;
    do return true end;
  end;
end
__haxe_ds_IntMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end
__haxe_ds_IntMap.prototype.iterator = function(self) 
  local _gthis = self;
  local it = self:keys();
  do return _hx_o({__fields__={hasNext=true,next=true},hasNext=function(self) 
    do return it:hasNext() end;
  end,next=function(self) 
    do return _gthis.h[it:next()] end;
  end}) end
end

__haxe_ds_IntMap.prototype.__class__ =  __haxe_ds_IntMap

__gmod_hxbit_GmodNetHost.new = function(onConnect,_onMessage) 
  local self = _hx_new(__gmod_hxbit_GmodNetHost.prototype)
  __gmod_hxbit_GmodNetHost.super(self,onConnect,_onMessage)
  return self
end
__gmod_hxbit_GmodNetHost.super = function(self,onConnect,_onMessage) 
  __hxbit_NetworkHost.super(self);
  if (onConnect == nil) then 
    onConnect = function(a) 
    end;
  end;
  if (_onMessage == nil) then 
    _onMessage = function(a,b) 
    end;
  end;
  self.onMessage = _hx_funcToField(_onMessage);
  self:connect(onConnect);
  self:defaultLogger();
end
_hxClasses["gmod.hxbit.GmodNetHost"] = __gmod_hxbit_GmodNetHost
__gmod_hxbit_GmodNetHost.__name__ = "gmod.hxbit.GmodNetHost"
__gmod_hxbit_GmodNetHost.prototype = _hx_e();
__gmod_hxbit_GmodNetHost.prototype.connect = function(self,onConnect) 
  self.isAuth = false;
  self["self"] = __gmod_hxbit_Client.new(self, nil);
  self.clients = _hx_tab_array({[0]=self["self"]}, 1);
  self["self"]:sync();
  self["self"]:sendMessage(1024);
  self:makeAlive();
  onConnect(self["self"]);
end

__gmod_hxbit_GmodNetHost.prototype.__class__ =  __gmod_hxbit_GmodNetHost
__gmod_hxbit_GmodNetHost.__super__ = __hxbit_NetworkHost
setmetatable(__gmod_hxbit_GmodNetHost.prototype,{__index=__hxbit_NetworkHost.prototype})

__haxe_io_Input.new = {}
_hxClasses["haxe.io.Input"] = __haxe_io_Input
__haxe_io_Input.__name__ = "haxe.io.Input"
__haxe_io_Input.prototype = _hx_e();
__haxe_io_Input.prototype.readByte = function(self) 
  _G.error(__haxe_Exception.thrown("Not implemented"),0);
end
__haxe_io_Input.prototype.readBytes = function(self,s,pos,len) 
  local k = len;
  local b = s.b;
  if (((pos < 0) or (len < 0)) or ((pos + len) > s.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  local _hx_status, _hx_result = pcall(function() 
  
      while (k > 0) do 
        b[pos] = self:readByte();
        pos = pos + 1;
        k = k - 1;
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    if (not __lua_Boot.__instanceof(__haxe_Exception.caught(_g):unwrap(), __haxe_io_Eof)) then 
      _G.error(_g,0);
    end;
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  do return len - k end
end
__haxe_io_Input.prototype.readInt32 = function(self) 
  local ch1 = self:readByte();
  local ch2 = self:readByte();
  local ch3 = self:readByte();
  local ch4 = self:readByte();
  local n = (function() 
    local _hx_1
    if (self.bigEndian) then 
    _hx_1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(ch4,_hx_bit.lshift(ch3,8)),_hx_bit.lshift(ch2,16)),_hx_bit.lshift(ch1,24)); else 
    _hx_1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(ch1,_hx_bit.lshift(ch2,8)),_hx_bit.lshift(ch3,16)),_hx_bit.lshift(ch4,24)); end
    return _hx_1
  end )();
  do return _hx_bit_clamp(n) end
end

__haxe_io_Input.prototype.__class__ =  __haxe_io_Input

__gmod_hxbit_GmodNetworkInput.new = function() 
  local self = _hx_new(__gmod_hxbit_GmodNetworkInput.prototype)
  __gmod_hxbit_GmodNetworkInput.super(self)
  return self
end
__gmod_hxbit_GmodNetworkInput.super = function(self) 
end
_hxClasses["gmod.hxbit.GmodNetworkInput"] = __gmod_hxbit_GmodNetworkInput
__gmod_hxbit_GmodNetworkInput.__name__ = "gmod.hxbit.GmodNetworkInput"
__gmod_hxbit_GmodNetworkInput.prototype = _hx_e();
__gmod_hxbit_GmodNetworkInput.prototype.readInt32 = function(self) 
  do return _G.net.ReadUInt(32) end
end
__gmod_hxbit_GmodNetworkInput.prototype.readByte = function(self) 
  do return _G.net.ReadUInt(8) end
end

__gmod_hxbit_GmodNetworkInput.prototype.__class__ =  __gmod_hxbit_GmodNetworkInput
__gmod_hxbit_GmodNetworkInput.__super__ = __haxe_io_Input
setmetatable(__gmod_hxbit_GmodNetworkInput.prototype,{__index=__haxe_io_Input.prototype})

__hxbit_NetworkClient.new = function(h) 
  local self = _hx_new(__hxbit_NetworkClient.prototype)
  __hxbit_NetworkClient.super(self,h)
  return self
end
__hxbit_NetworkClient.super = function(self,h) 
  self.messageLength = -1;
  self.host = h;
  self.lastMessage = Sys.time();
end
_hxClasses["hxbit.NetworkClient"] = __hxbit_NetworkClient
__hxbit_NetworkClient.__name__ = "hxbit.NetworkClient"
__hxbit_NetworkClient.prototype = _hx_e();
__hxbit_NetworkClient.prototype.sync = function(self) 
  self.host:fullSync(self);
end
__hxbit_NetworkClient.prototype.send = function(self,bytes) 
end
__hxbit_NetworkClient.prototype.sendMessage = function(self,msg) 
  if (self.host ~= nil) then 
    self.host:sendMessage(msg, self);
  end;
end
__hxbit_NetworkClient.prototype.error = function(self,msg) 
  _G.error(__haxe_Exception.thrown(msg),0);
end
__hxbit_NetworkClient.prototype.processMessage = function(self,bytes,pos) 
  local ctx = self.host.ctx;
  ctx:setInput(bytes, pos);
  if (ctx:get_error()) then 
    self.host:logError("Unhandled previous error");
  end;
  local pos1 = (function() 
  local _hx_obj = ctx;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local mid = ctx.input.b[pos1];
  if (self.needAlive and (mid ~= 2)) then 
    self.needAlive = false;
    self.host:makeAlive();
  end;
  if (not self.wasSync and not self.host.isAuth) then 
    local mid1 = mid;
    if (mid1) == 4 or (mid1) == 8 or (mid1) == 9 or (mid1) == 10 or (mid1) == 11 then else
    self.host:logError(Std.string(Std.string("Message ") .. Std.string(mid)) .. Std.string(" was received before sync")); end;
  end;
  local mid1 = mid;
  if (mid1) == 1 then 
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_1
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_1 = _hx_bit.bor(v1,-2147483648); else 
        _hx_1 = v1; end
        return _hx_1
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local oid = v;
    local ret = ctx.refs.h[oid];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local o = ret;
    if (o == nil) then 
      self.host:logError("Could not sync object", oid);
      do return -1 end;
    end;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_2
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_2 = _hx_bit.bor(v1,-2147483648); else 
        _hx_2 = v1; end
        return _hx_2
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local bits = v;
    if (self.host.isAuth) then 
      local _g = 0;
      while (_g < 32) do 
        _g = _g + 1;
        local i = _g - 1;
        if (((_hx_bit.band(bits,_hx_bit.lshift(1,i))) ~= 0) and not o:networkAllow(3, i, self.ownerObject)) then 
          self.host:logError(Std.string(Std.string(Std.string("Client setting unallowed property ") .. Std.string(o:networkGetName(i))) .. Std.string(" on ")) .. Std.string(Std.string(o)), o.__uid);
          do return -1 end;
        end;
      end;
    end;
    if (self.host.logger ~= nil) then 
      local props = _hx_tab_array({}, 0);
      local i = 0;
      while ((_hx_bit.lshift(1,i)) <= bits) do 
        if ((_hx_bit.band(bits,_hx_bit.lshift(1,i))) ~= 0) then 
          props:push(o:networkGetName(i));
        end;
        i = i + 1;
      end;
      self.host:logger(Std.string(Std.string(Std.string(Std.string(Std.string("SYNC < ") .. Std.string(Std.string(o))) .. Std.string("#")) .. Std.string(o.__uid)) .. Std.string(" ")) .. Std.string(props:join("|")));
    end;
    local old = o.__bits;
    local oldH = o.__host;
    o.__host = nil;
    o.__bits = bits;
    self.host.syncingProperties = true;
    o:networkSync(ctx);
    self.host.syncingProperties = false;
    o.__host = oldH;
    o.__bits = old;
    if (self.host.isAuth and ((o.__next ~= nil) or self.host:mark(o))) then 
      local o = o;
      o.__bits = _hx_bit.bor(o.__bits,bits);
    end;
    if (ctx:get_error()) then 
      self.host:logError(Std.string("Found unreferenced object while syncing ") .. Std.string(Std.string(o)));
    end;
  elseif (mid1) == 2 then 
    local o = ctx:getAnyRef();
    if (ctx:get_error()) then 
      self.host:logError(Std.string("Found unreferenced object while registering ") .. Std.string(Std.string(o)));
    end;
    self.needAlive = true;
  elseif (mid1) == 3 then 
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_3
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_3 = _hx_bit.bor(v1,-2147483648); else 
        _hx_3 = v1; end
        return _hx_3
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local oid = v;
    local ret = ctx.refs.h[oid];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local o = ret;
    if (o == nil) then 
      self.host:logError("Could not unregister object", oid);
    else
      o.__host = nil;
      ctx.refs:remove(o.__uid);
      self.host:onUnregister(o);
    end;
  elseif (mid1) == 4 then 
    self.wasSync = true;
    ctx.refs = __haxe_ds_IntMap.new();
    __hxbit_Serializer.UID = 0;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    __hxbit_Serializer.SEQ = ctx.input.b[pos];
    ctx.newObjects = _hx_tab_array({}, 0);
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_4
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_4 = _hx_bit.bor(v1,-2147483648); else 
        _hx_4 = v1; end
        return _hx_4
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local len = v;
    local sign;
    if (len == 0) then 
      sign = nil;
    else
      len = len - 1;
      local s = ctx.input:sub(ctx.inPos, len);
      local ctx = ctx;
      ctx.inPos = ctx.inPos + len;
      sign = s;
    end;
    if (sign:compare(__hxbit_Serializer.getSignature()) ~= 0) then 
      self.host:logError("Network signature mismatch");
    end;
    ctx.enableChecks = false;
    while (ctx:getAnyRef() ~= nil) do 
    end;
    ctx.enableChecks = true;
    self.host:makeAlive();
  elseif (mid1) == 5 then 
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_5
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_5 = _hx_bit.bor(v1,-2147483648); else 
        _hx_5 = v1; end
        return _hx_5
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local oid = v;
    local ret = ctx.refs.h[oid];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local o = ret;
    local _this = ctx.input;
    local pos = ctx.inPos;
    local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
    local v = _hx_bit_clamp((function() 
      local _hx_6
      if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
      _hx_6 = _hx_bit.bor(v,-2147483648); else 
      _hx_6 = v; end
      return _hx_6
    end )());
    local ctx1 = ctx;
    ctx1.inPos = ctx1.inPos + 4;
    local size = v;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local fid = ctx.input.b[pos];
    if (o == nil) then 
      if (size < 0) then 
        _G.error(__haxe_Exception.thrown("RPC on unreferenced object cannot be skip on this platform"),0);
      end;
      if (not self.host.isAuth) then 
        self.host:logError(Std.string(Std.string("RPC @") .. Std.string(fid)) .. Std.string(" on unreferenced object"), oid);
      end;
      local ctx = ctx;
      ctx.inPos = ctx.inPos + size;
    else
      if (not self.host.isAuth) then 
        if (not o:networkRPC(ctx, fid, self)) then 
          self.host:logError(Std.string(Std.string(Std.string(Std.string("RPC @") .. Std.string(fid)) .. Std.string(" on ")) .. Std.string(Std.string(o))) .. Std.string(" has unreferenced object parameter"));
        end;
      else
        self.host.rpcClientValue = self;
        o:networkRPC(ctx, fid, self);
        self.host.rpcClientValue = nil;
      end;
    end;
    if (self.host.logger ~= nil) then 
      self.host:logger(Std.string(Std.string(Std.string(Std.string(Std.string("RPC < ") .. Std.string(Std.string(o))) .. Std.string("#")) .. Std.string(o.__uid)) .. Std.string(" ")) .. Std.string(o:networkGetName(fid, true)));
    end;
  elseif (mid1) == 6 then 
    local old = self.resultID;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_7
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_7 = _hx_bit.bor(v1,-2147483648); else 
        _hx_7 = v1; end
        return _hx_7
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    self.resultID = v;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_8
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_8 = _hx_bit.bor(v1,-2147483648); else 
        _hx_8 = v1; end
        return _hx_8
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local oid = v;
    local ret = ctx.refs.h[oid];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    local o = ret;
    local _this = ctx.input;
    local pos = ctx.inPos;
    local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
    local v = _hx_bit_clamp((function() 
      local _hx_9
      if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
      _hx_9 = _hx_bit.bor(v,-2147483648); else 
      _hx_9 = v; end
      return _hx_9
    end )());
    local ctx1 = ctx;
    ctx1.inPos = ctx1.inPos + 4;
    local size = v;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local fid = ctx.input.b[pos];
    if (o == nil) then 
      if (size < 0) then 
        _G.error(__haxe_Exception.thrown("RPC on unreferenced object cannot be skip on this platform"),0);
      end;
      if (not self.host.isAuth) then 
        self.host:logError(Std.string(Std.string("RPC @") .. Std.string(fid)) .. Std.string(" on unreferenced object"), oid);
      end;
      local ctx1 = ctx;
      ctx1.inPos = ctx1.inPos + size;
      ctx.out.b:push(12);
      local v = self.resultID;
      if ((v >= 0) and (v < 128)) then 
        ctx.out.b:push(v);
      else
        ctx.out.b:push(128);
        ctx.out:addInt32(v);
      end;
    else
      if (not self.host.isAuth) then 
        local old = o.__host;
        o.__host = nil;
        if (not o:networkRPC(ctx, fid, self)) then 
          self.host:logError(Std.string(Std.string(Std.string(Std.string("RPC @") .. Std.string(fid)) .. Std.string(" on ")) .. Std.string(Std.string(o))) .. Std.string(" has unreferenced object parameter"));
          ctx.out.b:push(12);
          local v = self.resultID;
          if ((v >= 0) and (v < 128)) then 
            ctx.out.b:push(v);
          else
            ctx.out.b:push(128);
            ctx.out:addInt32(v);
          end;
        end;
        o.__host = old;
      else
        self.host.rpcClientValue = self;
        if (not o:networkRPC(ctx, fid, self)) then 
          ctx.out.b:push(12);
          local v = self.resultID;
          if ((v >= 0) and (v < 128)) then 
            ctx.out.b:push(v);
          else
            ctx.out.b:push(128);
            ctx.out:addInt32(v);
          end;
        end;
        self.host.rpcClientValue = nil;
      end;
    end;
    ctx.out.b:push(255);
    self.host:doSend();
    self.host.targetClient = nil;
    self.resultID = old;
  elseif (mid1) == 7 then 
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_10
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_10 = _hx_bit.bor(v1,-2147483648); else 
        _hx_10 = v1; end
        return _hx_10
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local resultID = v;
    local ret = self.host.rpcWaits.h[resultID];
    if (ret == __haxe_ds_IntMap.tnull) then 
      ret = nil;
    end;
    self.host.rpcWaits:remove(resultID);
    ret(ctx);
  elseif (mid1) == 8 then 
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_11
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_11 = _hx_bit.bor(v1,-2147483648); else 
        _hx_11 = v1; end
        return _hx_11
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local len = v;
    local msg;
    if (len == 0) then 
      msg = nil;
    else
      len = len - 1;
      local s = ctx.input:getString(ctx.inPos, len);
      local ctx = ctx;
      ctx.inPos = ctx.inPos + len;
      msg = s;
    end;
    local msg = __haxe_Unserializer.run(msg);
    self.host:onMessage(self, msg);
  elseif (mid1) == 9 then 
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_12
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_12 = _hx_bit.bor(v1,-2147483648); else 
        _hx_12 = v1; end
        return _hx_12
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local len = v;
    local msg;
    if (len == 0) then 
      msg = nil;
    else
      len = len - 1;
      local s = ctx.input:sub(ctx.inPos, len);
      local ctx = ctx;
      ctx.inPos = ctx.inPos + len;
      msg = s;
    end;
    self.host:onMessage(self, msg);
  elseif (mid1) == 10 then 
    local tmp = self.host;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_13
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_13 = _hx_bit.bor(v1,-2147483648); else 
        _hx_13 = v1; end
        return _hx_13
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    tmp:onCustom(self, v, nil);
  elseif (mid1) == 11 then 
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_14
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_14 = _hx_bit.bor(v1,-2147483648); else 
        _hx_14 = v1; end
        return _hx_14
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local tmp = self.host;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v1 = ctx.input.b[pos];
    if (v1 == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v1 = _hx_bit_clamp((function() 
        local _hx_15
        if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
        _hx_15 = _hx_bit.bor(v,-2147483648); else 
        _hx_15 = v; end
        return _hx_15
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local len = v1;
    local tmp1;
    if (len == 0) then 
      tmp1 = nil;
    else
      len = len - 1;
      local s = ctx.input:sub(ctx.inPos, len);
      local ctx = ctx;
      ctx.inPos = ctx.inPos + len;
      tmp1 = s;
    end;
    tmp:onCustom(self, v, tmp1);
  elseif (mid1) == 12 then 
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_16
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_16 = _hx_bit.bor(v1,-2147483648); else 
        _hx_16 = v1; end
        return _hx_16
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    self.host.rpcWaits:remove(v);else
  self:error(Std.string(Std.string(Std.string(Std.string(Std.string("Unknown message code ") .. Std.string(mid)) .. Std.string(" @")) .. Std.string(pos)) .. Std.string(":")) .. Std.string(bytes:toHex())); end;
  do return ctx.inPos end
end
__hxbit_NetworkClient.prototype.readData = function(self,input,available) 
  if (self.messageLength < 0) then 
    if (available < 4) then 
      do return false end;
    end;
    self.messageLength = input:readInt32();
    if ((self.pendingBuffer == nil) or (self.pendingBuffer.length < self.messageLength)) then 
      self.pendingBuffer = __haxe_io_Bytes.alloc(self.messageLength);
    end;
    self.pendingPos = 0;
  end;
  local len = input:readBytes(self.pendingBuffer, self.pendingPos, self.messageLength - self.pendingPos);
  local tmp = self;
  tmp.pendingPos = tmp.pendingPos + len;
  if (self.pendingPos == self.messageLength) then 
    self:processMessagesData(self.pendingBuffer, 0, self.messageLength);
    self.messageLength = -1;
    do return true end;
  end;
  do return false end
end
__hxbit_NetworkClient.prototype.processMessagesData = function(self,data,pos,length) 
  if (length > 0) then 
    self.lastMessage = Sys.time();
  end;
  local _end = pos + length;
  while (pos < _end) do 
    local oldPos = pos;
    pos = self:processMessage(data, pos);
    if (pos < 0) then 
      break;
    end;
    if (data.b[pos] ~= 255) then 
      local len = _end - oldPos;
      if (len > 128) then 
        len = 128;
      end;
      _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Message missing EOM @") .. Std.string((pos - oldPos))) .. Std.string(":")) .. Std.string(data:sub(oldPos, len):toHex())),0);
    end;
    pos = pos + 1;
  end;
  if (self.needAlive) then 
    self.needAlive = false;
    self.host:makeAlive();
  end;
end
__hxbit_NetworkClient.prototype.stop = function(self) 
  if (self.host == nil) then 
    do return end;
  end;
  self.host.clients:remove(self);
  self.host.pendingClients:remove(self);
  self.host = nil;
end

__hxbit_NetworkClient.prototype.__class__ =  __hxbit_NetworkClient

__gmod_hxbit_Client.new = function(host,ply) 
  local self = _hx_new(__gmod_hxbit_Client.prototype)
  __gmod_hxbit_Client.super(self,host,ply)
  return self
end
__gmod_hxbit_Client.super = function(self,host,ply) 
  __hxbit_NetworkClient.super(self,host);
  _G.net.Receive("hxbit", _hx_bind(self,self.recieve));
end
_hxClasses["gmod.hxbit.Client"] = __gmod_hxbit_Client
__gmod_hxbit_Client.__name__ = "gmod.hxbit.Client"
__gmod_hxbit_Client.prototype = _hx_e();
__gmod_hxbit_Client.prototype.recieve = function(self,len) 
  self:readData(__gmod_hxbit_GmodNetworkInput.new(), _G.net.BytesLeft());
end
__gmod_hxbit_Client.prototype.send = function(self,bytes) 
  _G.net.Start("hxbit", true);
  _G.net.WriteUInt(bytes.length, 32);
  local _g = 0;
  local _g1 = bytes.b;
  while (_g < _g1.length) do 
    local byt = _g1[_g];
    _g = _g + 1;
    _G.net.WriteUInt(byt, 8);
  end;
  _G.net.SendToServer();
end

__gmod_hxbit_Client.prototype.__class__ =  __gmod_hxbit_Client
__gmod_hxbit_Client.__super__ = __hxbit_NetworkClient
setmetatable(__gmod_hxbit_Client.prototype,{__index=__hxbit_NetworkClient.prototype})

__haxe_EntryPoint.new = {}
_hxClasses["haxe.EntryPoint"] = __haxe_EntryPoint
__haxe_EntryPoint.__name__ = "haxe.EntryPoint"
__haxe_EntryPoint.processEvents = function() 
  while (true) do 
    local f = __haxe_EntryPoint.pending:shift();
    if (f == nil) then 
      break;
    end;
    f();
  end;
  local time = __haxe_MainLoop.tick();
  if (not __haxe_MainLoop.hasEvents() and (__haxe_EntryPoint.threadCount == 0)) then 
    do return -1 end;
  end;
  do return time end;
end
__haxe_EntryPoint.run = function() 
  while (not (__haxe_EntryPoint.processEvents() < 0)) do 
  end;
end

__haxe__Int64____Int64.new = function(high,low) 
  local self = _hx_new(__haxe__Int64____Int64.prototype)
  __haxe__Int64____Int64.super(self,high,low)
  return self
end
__haxe__Int64____Int64.super = function(self,high,low) 
  self.high = high;
  self.low = low;
end
_hxClasses["haxe._Int64.___Int64"] = __haxe__Int64____Int64
__haxe__Int64____Int64.__name__ = "haxe._Int64.___Int64"
__haxe__Int64____Int64.prototype = _hx_e();

__haxe__Int64____Int64.prototype.__class__ =  __haxe__Int64____Int64

__haxe_Log.new = {}
_hxClasses["haxe.Log"] = __haxe_Log
__haxe_Log.__name__ = "haxe.Log"
__haxe_Log.formatOutput = function(v,infos) 
  local str = Std.string(v);
  if (infos == nil) then 
    do return str end;
  end;
  local pstr = Std.string(Std.string(infos.fileName) .. Std.string(":")) .. Std.string(infos.lineNumber);
  if (infos.customParams ~= nil) then 
    local _g = 0;
    local _g1 = infos.customParams;
    while (_g < _g1.length) do 
      local v = _g1[_g];
      _g = _g + 1;
      str = Std.string(str) .. Std.string((Std.string(", ") .. Std.string(Std.string(v))));
    end;
  end;
  do return Std.string(Std.string(pstr) .. Std.string(": ")) .. Std.string(str) end;
end
__haxe_Log.trace = function(v,infos) 
  local str = __haxe_Log.formatOutput(v, infos);
  _hx_print(str);
end

__haxe_MainEvent.new = function(f,p) 
  local self = _hx_new(__haxe_MainEvent.prototype)
  __haxe_MainEvent.super(self,f,p)
  return self
end
__haxe_MainEvent.super = function(self,f,p) 
  self.isBlocking = true;
  self.f = _hx_funcToField(f);
  self.priority = p;
  self.nextRun = -_G.math.huge;
end
_hxClasses["haxe.MainEvent"] = __haxe_MainEvent
__haxe_MainEvent.__name__ = "haxe.MainEvent"
__haxe_MainEvent.prototype = _hx_e();
__haxe_MainEvent.prototype.delay = function(self,t) 
  self.nextRun = (function() 
    local _hx_1
    if (t == nil) then 
    _hx_1 = -_G.math.huge; else 
    _hx_1 = Sys.time() + t; end
    return _hx_1
  end )();
end
__haxe_MainEvent.prototype.stop = function(self) 
  if (self.f == nil) then 
    do return end;
  end;
  self.f = nil;
  self.nextRun = -_G.math.huge;
  if (self.prev == nil) then 
    __haxe_MainLoop.pending = self.next;
  else
    self.prev.next = self.next;
  end;
  if (self.next ~= nil) then 
    self.next.prev = self.prev;
  end;
end

__haxe_MainEvent.prototype.__class__ =  __haxe_MainEvent

__haxe_MainLoop.new = {}
_hxClasses["haxe.MainLoop"] = __haxe_MainLoop
__haxe_MainLoop.__name__ = "haxe.MainLoop"
__haxe_MainLoop.hasEvents = function() 
  local p = __haxe_MainLoop.pending;
  while (p ~= nil) do 
    if (p.isBlocking) then 
      do return true end;
    end;
    p = p.next;
  end;
  do return false end;
end
__haxe_MainLoop.add = function(f,priority) 
  if (priority == nil) then 
    priority = 0;
  end;
  if (f == nil) then 
    _G.error(__haxe_Exception.thrown("Event function is null"),0);
  end;
  local e = __haxe_MainEvent.new(f, priority);
  local head = __haxe_MainLoop.pending;
  if (head ~= nil) then 
    head.prev = e;
  end;
  e.next = head;
  __haxe_MainLoop.pending = e;
  do return e end;
end
__haxe_MainLoop.sortEvents = function() 
  local list = __haxe_MainLoop.pending;
  if (list == nil) then 
    do return end;
  end;
  local insize = 1;
  local nmerges;
  local psize = 0;
  local qsize = 0;
  local p;
  local q;
  local e;
  local tail;
  while (true) do 
    p = list;
    list = nil;
    tail = nil;
    nmerges = 0;
    while (p ~= nil) do 
      nmerges = nmerges + 1;
      q = p;
      psize = 0;
      local _g = 0;
      local _g1 = insize;
      while (_g < _g1) do 
        _g = _g + 1;
        psize = psize + 1;
        q = q.next;
        if (q == nil) then 
          break;
        end;
      end;
      qsize = insize;
      while ((psize > 0) or ((qsize > 0) and (q ~= nil))) do 
        if (psize == 0) then 
          e = q;
          q = q.next;
          qsize = qsize - 1;
        else
          if (((qsize == 0) or (q == nil)) or ((p.priority > q.priority) or ((p.priority == q.priority) and (p.nextRun <= q.nextRun)))) then 
            e = p;
            p = p.next;
            psize = psize - 1;
          else
            e = q;
            q = q.next;
            qsize = qsize - 1;
          end;
        end;
        if (tail ~= nil) then 
          tail.next = e;
        else
          list = e;
        end;
        e.prev = tail;
        tail = e;
      end;
      p = q;
    end;
    tail.next = nil;
    if (nmerges <= 1) then 
      break;
    end;
    insize = insize * 2;
  end;
  list.prev = nil;
  __haxe_MainLoop.pending = list;
end
__haxe_MainLoop.tick = function() 
  __haxe_MainLoop.sortEvents();
  local e = __haxe_MainLoop.pending;
  local now = Sys.time();
  local wait = 1e9;
  while (e ~= nil) do 
    local next = e.next;
    local wt = e.nextRun - now;
    if (wt <= 0) then 
      wait = 0;
      if (e.f ~= nil) then 
        e:f();
      end;
    else
      if (wait > wt) then 
        wait = wt;
      end;
    end;
    e = next;
  end;
  do return wait end;
end

__haxe_Serializer.new = function() 
  local self = _hx_new(__haxe_Serializer.prototype)
  __haxe_Serializer.super(self)
  return self
end
__haxe_Serializer.super = function(self) 
  self.buf = StringBuf.new();
  self.cache = Array.new();
  self.useCache = _hx_funcToField(__haxe_Serializer.USE_CACHE);
  self.useEnumIndex = _hx_funcToField(__haxe_Serializer.USE_ENUM_INDEX);
  self.shash = __haxe_ds_StringMap.new();
  self.scount = 0;
end
_hxClasses["haxe.Serializer"] = __haxe_Serializer
__haxe_Serializer.__name__ = "haxe.Serializer"
__haxe_Serializer.run = function(v) 
  local s = __haxe_Serializer.new();
  s:serialize(v);
  do return s:toString() end;
end
__haxe_Serializer.prototype = _hx_e();
__haxe_Serializer.prototype.toString = function(self) 
  do return _G.table.concat(self.buf.b) end
end
__haxe_Serializer.prototype.serializeString = function(self,s) 
  local ret = self.shash.h[s];
  if (ret == __haxe_ds_StringMap.tnull) then 
    ret = nil;
  end;
  local x = ret;
  if (x ~= nil) then 
    local _this = self.buf;
    _G.table.insert(_this.b, "R");
    _this.length = _this.length + #"R";
    local _this = self.buf;
    local str = Std.string(x);
    _G.table.insert(_this.b, str);
    _this.length = _this.length + #str;
    do return end;
  end;
  local _this = self.shash;
  local value = (function() 
  local _hx_obj = self;
  local _hx_fld = 'scount';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  if (value == nil) then 
    _this.h[s] = __haxe_ds_StringMap.tnull;
  else
    _this.h[s] = value;
  end;
  local _this = self.buf;
  _G.table.insert(_this.b, "y");
  _this.length = _this.length + #"y";
  s = StringTools.urlEncode(s);
  local _this = self.buf;
  local str = Std.string(#s);
  _G.table.insert(_this.b, str);
  _this.length = _this.length + #str;
  local _this = self.buf;
  _G.table.insert(_this.b, ":");
  _this.length = _this.length + #":";
  local _this = self.buf;
  local str = Std.string(s);
  _G.table.insert(_this.b, str);
  _this.length = _this.length + #str;
end
__haxe_Serializer.prototype.serializeRef = function(self,v) 
  local _g = 0;
  local _g1 = self.cache.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (self.cache[i] == v) then 
      local _this = self.buf;
      _G.table.insert(_this.b, "r");
      _this.length = _this.length + #"r";
      local _this = self.buf;
      local str = Std.string(i);
      _G.table.insert(_this.b, str);
      _this.length = _this.length + #str;
      do return true end;
    end;
  end;
  self.cache:push(v);
  do return false end
end
__haxe_Serializer.prototype.serializeFields = function(self,v) 
  local _g = 0;
  local _g1 = Reflect.fields(v);
  while (_g < _g1.length) do 
    local f = _g1[_g];
    _g = _g + 1;
    self:serializeString(f);
    self:serialize(Reflect.field(v, f));
  end;
  local _this = self.buf;
  _G.table.insert(_this.b, "g");
  _this.length = _this.length + #"g";
end
__haxe_Serializer.prototype.serialize = function(self,v) 
  local _g = Type.typeof(v);
  local tmp = _g[1];
  if (tmp) == 0 then 
    local _this = self.buf;
    local str = "n";
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
  elseif (tmp) == 1 then 
    local v = v;
    if (v == 0) then 
      local _this = self.buf;
      local str = "z";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      do return end;
    end;
    local _this = self.buf;
    local str = "i";
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
    local _this = self.buf;
    local str = Std.string(v);
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
  elseif (tmp) == 2 then 
    local v = v;
    if (Math.isNaN(v)) then 
      local _this = self.buf;
      local str = "k";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    else
      if (not Math.isFinite(v)) then 
        local _this = self.buf;
        local str = (function() 
          local _hx_1
          if (v < 0) then 
          _hx_1 = "m"; else 
          _hx_1 = "p"; end
          return _hx_1
        end )();
        _G.table.insert(_this.b, str);
        local _this = _this;
        _this.length = _this.length + #str;
      else
        local _this = self.buf;
        local str = "d";
        _G.table.insert(_this.b, str);
        local _this = _this;
        _this.length = _this.length + #str;
        local _this = self.buf;
        local str = Std.string(v);
        _G.table.insert(_this.b, str);
        local _this = _this;
        _this.length = _this.length + #str;
      end;
    end;
  elseif (tmp) == 3 then 
    local _this = self.buf;
    local str = (function() 
      local _hx_2
      if (v) then 
      _hx_2 = "t"; else 
      _hx_2 = "f"; end
      return _hx_2
    end )();
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
  elseif (tmp) == 4 then 
    if (__lua_Boot.__instanceof(v, Class)) then 
      local className = v.__name__;
      local _this = self.buf;
      local str = "A";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      self:serializeString(className);
    else
      if (__lua_Boot.__instanceof(v, Enum)) then 
        local _this = self.buf;
        local str = "B";
        _G.table.insert(_this.b, str);
        local _this = _this;
        _this.length = _this.length + #str;
        self:serializeString(Type.getEnumName(v));
      else
        if (self.useCache and self:serializeRef(v)) then 
          do return end;
        end;
        local _this = self.buf;
        local str = "o";
        _G.table.insert(_this.b, str);
        local _this = _this;
        _this.length = _this.length + #str;
        self:serializeFields(v);
      end;
    end;
  elseif (tmp) == 5 then 
    _G.error(__haxe_Exception.thrown("Cannot serialize function"),0);
  elseif (tmp) == 6 then 
    local c = _g[2];
    if (c == String) then 
      self:serializeString(v);
      do return end;
    end;
    if (self.useCache and self:serializeRef(v)) then 
      do return end;
    end;
    local c1 = c;
    if (c1) == Array then 
      local ucount = 0;
      local _this = self.buf;
      local str = "a";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      local _g = 0;
      local _g1 = _hx_wrap_if_string_field(v,'length');
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        if (v[i] == nil) then 
          ucount = ucount + 1;
        else
          if (ucount > 0) then 
            if (ucount == 1) then 
              local _this = self.buf;
              local str = "n";
              _G.table.insert(_this.b, str);
              local _this = _this;
              _this.length = _this.length + #str;
            else
              local _this = self.buf;
              local str = "u";
              _G.table.insert(_this.b, str);
              local _this = _this;
              _this.length = _this.length + #str;
              local _this = self.buf;
              local str = Std.string(ucount);
              _G.table.insert(_this.b, str);
              local _this = _this;
              _this.length = _this.length + #str;
            end;
            ucount = 0;
          end;
          self:serialize(v[i]);
        end;
      end;
      if (ucount > 0) then 
        if (ucount == 1) then 
          local _this = self.buf;
          local str = "n";
          _G.table.insert(_this.b, str);
          local _this = _this;
          _this.length = _this.length + #str;
        else
          local _this = self.buf;
          local str = "u";
          _G.table.insert(_this.b, str);
          local _this = _this;
          _this.length = _this.length + #str;
          local _this = self.buf;
          local str = Std.string(ucount);
          _G.table.insert(_this.b, str);
          local _this = _this;
          _this.length = _this.length + #str;
        end;
      end;
      local _this = self.buf;
      local str = "h";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == Date then 
      local _this = self.buf;
      local str = "v";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      local _this = self.buf;
      local str = Std.string(v:getTime());
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == __haxe_ds_IntMap then 
      local _this = self.buf;
      local str = "q";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      local v = v;
      local k = v:keys();
      while (k:hasNext()) do 
        local k = k:next();
        local _this = self.buf;
        local str = ":";
        _G.table.insert(_this.b, str);
        local _this = _this;
        _this.length = _this.length + #str;
        local _this = self.buf;
        local str = Std.string(k);
        _G.table.insert(_this.b, str);
        local _this = _this;
        _this.length = _this.length + #str;
        local ret = v.h[k];
        if (ret == __haxe_ds_IntMap.tnull) then 
          ret = nil;
        end;
        self:serialize(ret);
      end;
      local _this = self.buf;
      local str = "h";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == __haxe_ds_List then 
      local _this = self.buf;
      local str = "l";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      local _g_head = v.h;
      while (_g_head ~= nil) do 
        local val = _g_head.item;
        _g_head = _g_head.next;
        self:serialize(val);
      end;
      local _this = self.buf;
      local str = "h";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == __haxe_ds_ObjectMap then 
      local _this = self.buf;
      local str = "M";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      local v = v;
      local k = v:keys();
      while (k:hasNext()) do 
        local k = k:next();
        self:serialize(k);
        self:serialize(v.h[k]);
      end;
      local _this = self.buf;
      local str = "h";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == __haxe_ds_StringMap then 
      local _this = self.buf;
      local str = "b";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      local v = v;
      local k = v:keys();
      while (k:hasNext()) do 
        local k = k:next();
        self:serializeString(k);
        local ret = v.h[k];
        if (ret == __haxe_ds_StringMap.tnull) then 
          ret = nil;
        end;
        self:serialize(ret);
      end;
      local _this = self.buf;
      local str = "h";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    elseif (c1) == __haxe_io_Bytes then 
      local v = v;
      local _this = self.buf;
      local str = "s";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      local _this = self.buf;
      local str = Std.string(_G.math.ceil((v.length * 8) / 6));
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      local _this = self.buf;
      local str = ":";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      local i = 0;
      local max = v.length - 2;
      local b64 = __haxe_Serializer.BASE64_CODES;
      if (b64 == nil) then 
        local length = #__haxe_Serializer.BASE64;
        b64 = ({length = length});
        local _g = 0;
        local _g1 = #__haxe_Serializer.BASE64;
        while (_g < _g1) do 
          _g = _g + 1;
          local i = _g - 1;
          b64[i] = _G.string.byte(__haxe_Serializer.BASE64, i + 1);
        end;
        __haxe_Serializer.BASE64_CODES = b64;
      end;
      while (i < max) do 
        i = i + 1;
        local b1 = v.b[i - 1];
        i = i + 1;
        local b2 = v.b[i - 1];
        i = i + 1;
        local b3 = v.b[i - 1];
        local _this = self.buf;
        _G.table.insert(_this.b, _G.string.char(b64[_hx_bit.arshift(b1,2)]));
        local _this = _this;
        _this.length = _this.length + 1;
        local _this = self.buf;
        _G.table.insert(_this.b, _G.string.char(b64[_hx_bit.band((_hx_bit.bor(_hx_bit.lshift(b1,4),_hx_bit.arshift(b2,4))),63)]));
        local _this = _this;
        _this.length = _this.length + 1;
        local _this = self.buf;
        _G.table.insert(_this.b, _G.string.char(b64[_hx_bit.band((_hx_bit.bor(_hx_bit.lshift(b2,2),_hx_bit.arshift(b3,6))),63)]));
        local _this = _this;
        _this.length = _this.length + 1;
        local _this = self.buf;
        _G.table.insert(_this.b, _G.string.char(b64[_hx_bit.band(b3,63)]));
        local _this = _this;
        _this.length = _this.length + 1;
      end;
      if (i == max) then 
        i = i + 1;
        local b1 = v.b[i - 1];
        i = i + 1;
        local b2 = v.b[i - 1];
        local _this = self.buf;
        _G.table.insert(_this.b, _G.string.char(b64[_hx_bit.arshift(b1,2)]));
        local _this = _this;
        _this.length = _this.length + 1;
        local _this = self.buf;
        _G.table.insert(_this.b, _G.string.char(b64[_hx_bit.band((_hx_bit.bor(_hx_bit.lshift(b1,4),_hx_bit.arshift(b2,4))),63)]));
        local _this = _this;
        _this.length = _this.length + 1;
        local _this = self.buf;
        _G.table.insert(_this.b, _G.string.char(b64[_hx_bit.band(_hx_bit.lshift(b2,2),63)]));
        local _this = _this;
        _this.length = _this.length + 1;
      else
        if (i == (max + 1)) then 
          i = i + 1;
          local b1 = v.b[i - 1];
          local _this = self.buf;
          _G.table.insert(_this.b, _G.string.char(b64[_hx_bit.arshift(b1,2)]));
          local _this = _this;
          _this.length = _this.length + 1;
          local _this = self.buf;
          _G.table.insert(_this.b, _G.string.char(b64[_hx_bit.band(_hx_bit.lshift(b1,4),63)]));
          local _this = _this;
          _this.length = _this.length + 1;
        end;
      end;else
    if (self.useCache) then 
      self.cache:pop();
    end;
    if (v.hxSerialize ~= nil) then 
      local _this = self.buf;
      local str = "C";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      self:serializeString(c.__name__);
      if (self.useCache) then 
        self.cache:push(v);
      end;
      v:hxSerialize(self);
      local _this = self.buf;
      local str = "g";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    else
      local _this = self.buf;
      local str = "c";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      self:serializeString(c.__name__);
      if (self.useCache) then 
        self.cache:push(v);
      end;
      self:serializeFields(v);
    end; end;
  elseif (tmp) == 7 then 
    if (self.useCache) then 
      if (self:serializeRef(v)) then 
        do return end;
      end;
      self.cache:pop();
    end;
    local _this = self.buf;
    local str = Std.string((function() 
      local _hx_3
      if (self.useEnumIndex) then 
      _hx_3 = "j"; else 
      _hx_3 = "w"; end
      return _hx_3
    end )());
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
    self:serializeString(Type.getEnumName(_g[2]));
    if (self.useEnumIndex) then 
      local _this = self.buf;
      local str = ":";
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
      local _this = self.buf;
      local str = Std.string(v[1]);
      _G.table.insert(_this.b, str);
      local _this = _this;
      _this.length = _this.length + #str;
    else
      self:serializeString(v[0]);
    end;
    local _this = self.buf;
    local str = ":";
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
    local l = v["length"];
    local _this = self.buf;
    local str = Std.string(l - 2);
    _G.table.insert(_this.b, str);
    local _this = _this;
    _this.length = _this.length + #str;
    local _g = 2;
    local _g1 = l;
    while (_g < _g1) do 
      _g = _g + 1;
      self:serialize(v[_g - 1]);
    end;
    if (self.useCache) then 
      self.cache:push(v);
    end;else
  _G.error(__haxe_Exception.thrown(Std.string("Cannot serialize ") .. Std.string(Std.string(v))),0); end;
end

__haxe_Serializer.prototype.__class__ =  __haxe_Serializer

__haxe_Timer.new = function(time_ms) 
  local self = _hx_new(__haxe_Timer.prototype)
  __haxe_Timer.super(self,time_ms)
  return self
end
__haxe_Timer.super = function(self,time_ms) 
  local _gthis = self;
  local dt = time_ms / 1000;
  self.event = __haxe_MainLoop.add(function() 
    local _gthis1 = _gthis.event;
    _gthis1.nextRun = _gthis1.nextRun + dt;
    _gthis:run();
  end);
  self.event:delay(dt);
end
_hxClasses["haxe.Timer"] = __haxe_Timer
__haxe_Timer.__name__ = "haxe.Timer"
__haxe_Timer.delay = function(f,time_ms) 
  local t = __haxe_Timer.new(time_ms);
  t.run = function(self) 
    t:stop();
    f();
   end;
  do return t end;
end
__haxe_Timer.prototype = _hx_e();
__haxe_Timer.prototype.stop = function(self) 
  if (self.event ~= nil) then 
    self.event:stop();
    self.event = nil;
  end;
end
__haxe_Timer.prototype.run = function(self) 
end

__haxe_Timer.prototype.__class__ =  __haxe_Timer

__haxe__Unserializer_DefaultResolver.new = function() 
  local self = _hx_new(__haxe__Unserializer_DefaultResolver.prototype)
  __haxe__Unserializer_DefaultResolver.super(self)
  return self
end
__haxe__Unserializer_DefaultResolver.super = function(self) 
end
_hxClasses["haxe._Unserializer.DefaultResolver"] = __haxe__Unserializer_DefaultResolver
__haxe__Unserializer_DefaultResolver.__name__ = "haxe._Unserializer.DefaultResolver"
__haxe__Unserializer_DefaultResolver.prototype = _hx_e();
__haxe__Unserializer_DefaultResolver.prototype.resolveClass = function(self,name) 
  do return Type.resolveClass(name) end
end
__haxe__Unserializer_DefaultResolver.prototype.resolveEnum = function(self,name) 
  do return Type.resolveEnum(name) end
end

__haxe__Unserializer_DefaultResolver.prototype.__class__ =  __haxe__Unserializer_DefaultResolver

__haxe_Unserializer.new = function(buf) 
  local self = _hx_new(__haxe_Unserializer.prototype)
  __haxe_Unserializer.super(self,buf)
  return self
end
__haxe_Unserializer.super = function(self,buf) 
  self.buf = buf;
  self.length = #buf;
  self.pos = 0;
  self.scache = Array.new();
  self.cache = Array.new();
  local r = __haxe_Unserializer.DEFAULT_RESOLVER;
  if (r == nil) then 
    r = __haxe__Unserializer_DefaultResolver.new();
    __haxe_Unserializer.DEFAULT_RESOLVER = r;
  end;
  self.resolver = r;
end
_hxClasses["haxe.Unserializer"] = __haxe_Unserializer
__haxe_Unserializer.__name__ = "haxe.Unserializer"
__haxe_Unserializer.initCodes = function() 
  local codes = Array.new();
  local _g = 0;
  local _g1 = #__haxe_Unserializer.BASE64;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    codes[_G.string.byte(__haxe_Unserializer.BASE64, i + 1)] = i;
  end;
  do return codes end;
end
__haxe_Unserializer.run = function(v) 
  do return __haxe_Unserializer.new(v):unserialize() end;
end
__haxe_Unserializer.prototype = _hx_e();
__haxe_Unserializer.prototype.readDigits = function(self) 
  local k = 0;
  local s = false;
  local fpos = self.pos;
  local _hx_continue_1 = false;
  while (true) do repeat 
    local c = _G.string.byte(self.buf, self.pos + 1);
    if (c == nil) then 
      _hx_continue_1 = true;break;
    end;
    if (c == 45) then 
      if (self.pos ~= fpos) then 
        _hx_continue_1 = true;break;
      end;
      s = true;
      self.pos = self.pos + 1;
      break;
    end;
    if ((c < 48) or (c > 57)) then 
      _hx_continue_1 = true;break;
    end;
    k = (k * 10) + (c - 48);
    self.pos = self.pos + 1;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
  if (s) then 
    k = k * -1;
  end;
  do return k end
end
__haxe_Unserializer.prototype.readFloat = function(self) 
  local p1 = self.pos;
  while (true) do 
    local c = _G.string.byte(self.buf, self.pos + 1);
    if (c == nil) then 
      break;
    end;
    if ((((c >= 43) and (c < 58)) or (c == 101)) or (c == 69)) then 
      self.pos = self.pos + 1;
    else
      break;
    end;
  end;
  local _this = self.buf;
  local pos = p1;
  local len = self.pos - p1;
  if ((len == nil) or (len > (p1 + #_this))) then 
    len = #_this;
  else
    if (len < 0) then 
      len = #_this + len;
    end;
  end;
  if (p1 < 0) then 
    pos = #_this + p1;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return Std.parseFloat(_G.string.sub(_this, pos + 1, pos + len)) end
end
__haxe_Unserializer.prototype.unserializeObject = function(self,o) 
  while (true) do 
    if (self.pos >= self.length) then 
      _G.error(__haxe_Exception.thrown("Invalid object"),0);
    end;
    if (_G.string.byte(self.buf, self.pos + 1) == 103) then 
      break;
    end;
    local k = self:unserialize();
    if (not __lua_Boot.__instanceof(k, String)) then 
      _G.error(__haxe_Exception.thrown("Invalid object key"),0);
    end;
    o[k] = self:unserialize();
  end;
  self.pos = self.pos + 1;
end
__haxe_Unserializer.prototype.unserializeEnum = function(self,edecl,tag) 
  local p = (function() 
  local _hx_obj = self;
  local _hx_fld = 'pos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  if (_G.string.byte(self.buf, p + 1) ~= 58) then 
    _G.error(__haxe_Exception.thrown("Invalid enum format"),0);
  end;
  local nargs = self:readDigits();
  if (nargs == 0) then 
    do return Type.createEnum(edecl, tag) end;
  end;
  local args = Array.new();
  while (true) do 
    nargs = nargs - 1;
    if (not ((nargs + 1) > 0)) then 
      break;
    end;
    args:push(self:unserialize());
  end;
  do return Type.createEnum(edecl, tag, args) end
end
__haxe_Unserializer.prototype.unserialize = function(self) 
  local p = (function() 
  local _hx_obj = self;
  local _hx_fld = 'pos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local _g = _G.string.byte(self.buf, p + 1);
  if (_g) == 65 then 
    local name = self:unserialize();
    local cl = self.resolver:resolveClass(name);
    if (cl == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string("Class not found ") .. Std.string(name)),0);
    end;
    do return cl end;
  elseif (_g) == 66 then 
    local name = self:unserialize();
    local e = self.resolver:resolveEnum(name);
    if (e == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string("Enum not found ") .. Std.string(name)),0);
    end;
    do return e end;
  elseif (_g) == 67 then 
    local name = self:unserialize();
    local cl = self.resolver:resolveClass(name);
    if (cl == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string("Class not found ") .. Std.string(name)),0);
    end;
    local o = Type.createEmptyInstance(cl);
    self.cache:push(o);
    o:hxUnserialize(self);
    local p = (function() 
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    if (_G.string.byte(self.buf, p + 1) ~= 103) then 
      _G.error(__haxe_Exception.thrown("Invalid custom data"),0);
    end;
    do return o end;
  elseif (_g) == 77 then 
    local h = __haxe_ds_ObjectMap.new();
    self.cache:push(h);
    while (_G.string.byte(self.buf, self.pos + 1) ~= 104) do 
      local s = self:unserialize();
      local value = self:unserialize();
      h.h[s] = value;
      h.k[s] = true;
    end;
    self.pos = self.pos + 1;
    do return h end;
  elseif (_g) == 82 then 
    local n = self:readDigits();
    if ((n < 0) or (n >= self.scache.length)) then 
      _G.error(__haxe_Exception.thrown("Invalid string reference"),0);
    end;
    do return self.scache[n] end;
  elseif (_g) == 97 then 
    local a = Array.new();
    self.cache:push(a);
    while (true) do 
      local c = _G.string.byte(self.buf, self.pos + 1);
      if (c == 104) then 
        self.pos = self.pos + 1;
        break;
      end;
      if (c == 117) then 
        self.pos = self.pos + 1;
        local n = self:readDigits();
        a[(a.length + n) - 1] = nil;
      else
        a:push(self:unserialize());
      end;
    end;
    do return a end;
  elseif (_g) == 98 then 
    local h = __haxe_ds_StringMap.new();
    self.cache:push(h);
    while (_G.string.byte(self.buf, self.pos + 1) ~= 104) do 
      local s = self:unserialize();
      local value = self:unserialize();
      if (value == nil) then 
        h.h[s] = __haxe_ds_StringMap.tnull;
      else
        h.h[s] = value;
      end;
    end;
    self.pos = self.pos + 1;
    do return h end;
  elseif (_g) == 99 then 
    local name = self:unserialize();
    local cl = self.resolver:resolveClass(name);
    if (cl == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string("Class not found ") .. Std.string(name)),0);
    end;
    local o = Type.createEmptyInstance(cl);
    self.cache:push(o);
    self:unserializeObject(o);
    do return o end;
  elseif (_g) == 100 then 
    do return self:readFloat() end;
  elseif (_g) == 102 then 
    do return false end;
  elseif (_g) == 105 then 
    do return self:readDigits() end;
  elseif (_g) == 106 then 
    local name = self:unserialize();
    local edecl = self.resolver:resolveEnum(name);
    if (edecl == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string("Enum not found ") .. Std.string(name)),0);
    end;
    self.pos = self.pos + 1;
    local index = self:readDigits();
    local tag = Type.getEnumConstructs(edecl)[index];
    if (tag == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Unknown enum index ") .. Std.string(name)) .. Std.string("@")) .. Std.string(index)),0);
    end;
    local e = self:unserializeEnum(edecl, tag);
    self.cache:push(e);
    do return e end;
  elseif (_g) == 107 then 
    do return (0/0) end;
  elseif (_g) == 108 then 
    local l = __haxe_ds_List.new();
    self.cache:push(l);
    while (_G.string.byte(self.buf, self.pos + 1) ~= 104) do 
      l:add(self:unserialize());
    end;
    self.pos = self.pos + 1;
    do return l end;
  elseif (_g) == 109 then 
    do return -_G.math.huge end;
  elseif (_g) == 110 then 
    do return nil end;
  elseif (_g) == 111 then 
    local o = _hx_e();
    self.cache:push(o);
    self:unserializeObject(o);
    do return o end;
  elseif (_g) == 112 then 
    do return _G.math.huge end;
  elseif (_g) == 113 then 
    local h = __haxe_ds_IntMap.new();
    self.cache:push(h);
    local p = (function() 
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local c = _G.string.byte(self.buf, p + 1);
    while (c == 58) do 
      local i = self:readDigits();
      local value = self:unserialize();
      if (value == nil) then 
        h.h[i] = __haxe_ds_IntMap.tnull;
      else
        h.h[i] = value;
      end;
      local p = (function() 
      local _hx_obj = self;
      local _hx_fld = 'pos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      c = _G.string.byte(self.buf, p + 1);
    end;
    if (c ~= 104) then 
      _G.error(__haxe_Exception.thrown("Invalid IntMap format"),0);
    end;
    do return h end;
  elseif (_g) == 114 then 
    local n = self:readDigits();
    if ((n < 0) or (n >= self.cache.length)) then 
      _G.error(__haxe_Exception.thrown("Invalid reference"),0);
    end;
    do return self.cache[n] end;
  elseif (_g) == 115 then 
    local len = self:readDigits();
    local buf = self.buf;
    local p = (function() 
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    if ((_G.string.byte(self.buf, p + 1) ~= 58) or ((self.length - self.pos) < len)) then 
      _G.error(__haxe_Exception.thrown("Invalid bytes length"),0);
    end;
    local codes = __haxe_Unserializer.CODES;
    if (codes == nil) then 
      codes = __haxe_Unserializer.initCodes();
      __haxe_Unserializer.CODES = codes;
    end;
    local i = self.pos;
    local rest = _hx_bit.band(len,3);
    local max = i + (len - rest);
    local bytes = __haxe_io_Bytes.alloc(((_hx_bit.arshift(len,2)) * 3) + (function() 
      local _hx_1
      if (rest >= 2) then 
      _hx_1 = rest - 1; else 
      _hx_1 = 0; end
      return _hx_1
    end )());
    local bpos = 0;
    while (i < max) do 
      i = i + 1;
      local c1 = codes[_G.string.byte(buf, (i - 1) + 1)];
      i = i + 1;
      local c2 = codes[_G.string.byte(buf, (i - 1) + 1)];
      bpos = bpos + 1;
      bytes.b[bpos - 1] = _hx_bit.band((_hx_bit.bor(_hx_bit.lshift(c1,2),_hx_bit.arshift(c2,4))),255);
      i = i + 1;
      local c3 = codes[_G.string.byte(buf, (i - 1) + 1)];
      bpos = bpos + 1;
      bytes.b[bpos - 1] = _hx_bit.band((_hx_bit.bor(_hx_bit.lshift(c2,4),_hx_bit.arshift(c3,2))),255);
      i = i + 1;
      local c4 = codes[_G.string.byte(buf, (i - 1) + 1)];
      bpos = bpos + 1;
      bytes.b[bpos - 1] = _hx_bit.band((_hx_bit.bor(_hx_bit.lshift(c3,6),c4)),255);
    end;
    if (rest >= 2) then 
      i = i + 1;
      local c1 = codes[_G.string.byte(buf, (i - 1) + 1)];
      i = i + 1;
      local c2 = codes[_G.string.byte(buf, (i - 1) + 1)];
      bpos = bpos + 1;
      bytes.b[bpos - 1] = _hx_bit.band((_hx_bit.bor(_hx_bit.lshift(c1,2),_hx_bit.arshift(c2,4))),255);
      if (rest == 3) then 
        i = i + 1;
        local c3 = codes[_G.string.byte(buf, (i - 1) + 1)];
        bpos = bpos + 1;
        bytes.b[bpos - 1] = _hx_bit.band((_hx_bit.bor(_hx_bit.lshift(c2,4),_hx_bit.arshift(c3,2))),255);
      end;
    end;
    local tmp = self;
    tmp.pos = tmp.pos + len;
    self.cache:push(bytes);
    do return bytes end;
  elseif (_g) == 116 then 
    do return true end;
  elseif (_g) == 118 then 
    local d;
    if (((((((((_G.string.byte(self.buf, self.pos + 1) >= 48) and (_G.string.byte(self.buf, self.pos + 1) <= 57)) and (_G.string.byte(self.buf, (self.pos + 1) + 1) >= 48)) and (_G.string.byte(self.buf, (self.pos + 1) + 1) <= 57)) and (_G.string.byte(self.buf, (self.pos + 2) + 1) >= 48)) and (_G.string.byte(self.buf, (self.pos + 2) + 1) <= 57)) and (_G.string.byte(self.buf, (self.pos + 3) + 1) >= 48)) and (_G.string.byte(self.buf, (self.pos + 3) + 1) <= 57)) and (_G.string.byte(self.buf, (self.pos + 4) + 1) == 45)) then 
      local _this = self.buf;
      local pos = self.pos;
      local len = 19;
      if ((len == nil) or (len > (pos + #_this))) then 
        len = #_this;
      else
        if (len < 0) then 
          len = #_this + len;
        end;
      end;
      if (pos < 0) then 
        pos = #_this + pos;
      end;
      if (pos < 0) then 
        pos = 0;
      end;
      d = __lua_Boot.strDate(_G.string.sub(_this, pos + 1, pos + len));
      local tmp = self;
      tmp.pos = tmp.pos + 19;
    else
      local t = self:readFloat();
      local d1 = _hx_e();
      _G.setmetatable(d1, _hx_o({__fields__={__index=true},__index=Date.prototype}));
      d1.t = t / 1000;
      d1.d = _G.os.date("*t", Std.int(d1.t));
      d1.dUTC = _G.os.date("!*t", Std.int(d1.t));
      d = d1;
    end;
    self.cache:push(d);
    do return d end;
  elseif (_g) == 119 then 
    local name = self:unserialize();
    local edecl = self.resolver:resolveEnum(name);
    if (edecl == nil) then 
      _G.error(__haxe_Exception.thrown(Std.string("Enum not found ") .. Std.string(name)),0);
    end;
    local e = self:unserializeEnum(edecl, self:unserialize());
    self.cache:push(e);
    do return e end;
  elseif (_g) == 120 then 
    _G.error(__haxe_Exception.thrown(self:unserialize()),0);
  elseif (_g) == 121 then 
    local len = self:readDigits();
    local p = (function() 
    local _hx_obj = self;
    local _hx_fld = 'pos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    if ((_G.string.byte(self.buf, p + 1) ~= 58) or ((self.length - self.pos) < len)) then 
      _G.error(__haxe_Exception.thrown("Invalid string length"),0);
    end;
    local _this = self.buf;
    local pos = self.pos;
    local len1 = len;
    if ((len1 == nil) or (len1 > (pos + #_this))) then 
      len1 = #_this;
    else
      if (len1 < 0) then 
        len1 = #_this + len1;
      end;
    end;
    if (pos < 0) then 
      pos = #_this + pos;
    end;
    if (pos < 0) then 
      pos = 0;
    end;
    local s = _G.string.sub(_this, pos + 1, pos + len1);
    local tmp = self;
    tmp.pos = tmp.pos + len;
    s = StringTools.urlDecode(s);
    self.scache:push(s);
    do return s end;
  elseif (_g) == 122 then 
    do return 0 end;else end;
  self.pos = self.pos - 1;
  local index = self.pos;
  _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Invalid char ") .. Std.string(_G.string.sub(self.buf, index + 1, index + 1))) .. Std.string(" at position ")) .. Std.string(self.pos)),0);
end

__haxe_Unserializer.prototype.__class__ =  __haxe_Unserializer

__haxe_crypto_Crc32.new = {}
_hxClasses["haxe.crypto.Crc32"] = __haxe_crypto_Crc32
__haxe_crypto_Crc32.__name__ = "haxe.crypto.Crc32"
__haxe_crypto_Crc32.make = function(data) 
  local c_crc = -1;
  local len = data.length;
  local b = data.b;
  local _g = 0;
  while (_g < len) do 
    _g = _g + 1;
    local tmp = _hx_bit.band((_hx_bit.bxor(c_crc,b[_g - 1])),255);
    tmp = _hx_bit.bxor(_hx_bit.rshift(tmp,1),_hx_bit.band(-(_hx_bit.band(tmp,1)),-306674912));
    tmp = _hx_bit.bxor(_hx_bit.rshift(tmp,1),_hx_bit.band(-(_hx_bit.band(tmp,1)),-306674912));
    tmp = _hx_bit.bxor(_hx_bit.rshift(tmp,1),_hx_bit.band(-(_hx_bit.band(tmp,1)),-306674912));
    tmp = _hx_bit.bxor(_hx_bit.rshift(tmp,1),_hx_bit.band(-(_hx_bit.band(tmp,1)),-306674912));
    tmp = _hx_bit.bxor(_hx_bit.rshift(tmp,1),_hx_bit.band(-(_hx_bit.band(tmp,1)),-306674912));
    tmp = _hx_bit.bxor(_hx_bit.rshift(tmp,1),_hx_bit.band(-(_hx_bit.band(tmp,1)),-306674912));
    tmp = _hx_bit.bxor(_hx_bit.rshift(tmp,1),_hx_bit.band(-(_hx_bit.band(tmp,1)),-306674912));
    tmp = _hx_bit.bxor(_hx_bit.rshift(tmp,1),_hx_bit.band(-(_hx_bit.band(tmp,1)),-306674912));
    c_crc = _hx_bit.bxor(_hx_bit.rshift(c_crc,8),tmp);
  end;
  do return _hx_bit.bxor(c_crc,-1) end;
end

__haxe_crypto_Md5.new = function() 
  local self = _hx_new(__haxe_crypto_Md5.prototype)
  __haxe_crypto_Md5.super(self)
  return self
end
__haxe_crypto_Md5.super = function(self) 
end
_hxClasses["haxe.crypto.Md5"] = __haxe_crypto_Md5
__haxe_crypto_Md5.__name__ = "haxe.crypto.Md5"
__haxe_crypto_Md5.make = function(b) 
  local h = __haxe_crypto_Md5.new():doEncode(__haxe_crypto_Md5.bytes2blks(b));
  local out = __haxe_io_Bytes.alloc(16);
  out.b[0] = _hx_bit.band(_hx_bit.band(h[0],255),255);
  out.b[1] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(h[0],8),255),255);
  out.b[2] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(h[0],16),255),255);
  out.b[3] = _hx_bit.band(_hx_bit.rshift(h[0],24),255);
  out.b[4] = _hx_bit.band(_hx_bit.band(h[1],255),255);
  out.b[5] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(h[1],8),255),255);
  out.b[6] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(h[1],16),255),255);
  out.b[7] = _hx_bit.band(_hx_bit.rshift(h[1],24),255);
  out.b[8] = _hx_bit.band(_hx_bit.band(h[2],255),255);
  out.b[9] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(h[2],8),255),255);
  out.b[10] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(h[2],16),255),255);
  out.b[11] = _hx_bit.band(_hx_bit.rshift(h[2],24),255);
  out.b[12] = _hx_bit.band(_hx_bit.band(h[3],255),255);
  out.b[13] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(h[3],8),255),255);
  out.b[14] = _hx_bit.band(_hx_bit.band(_hx_bit.arshift(h[3],16),255),255);
  out.b[15] = _hx_bit.band(_hx_bit.rshift(h[3],24),255);
  do return out end;
end
__haxe_crypto_Md5.bytes2blks = function(b) 
  local nblk = (_hx_bit.arshift(b.length + 8,6)) + 1;
  local blks = Array.new();
  local blksSize = nblk * 16;
  local _g = 0;
  while (_g < blksSize) do 
    _g = _g + 1;
    blks[_g - 1] = 0;
  end;
  local i = 0;
  while (i < b.length) do 
    local tmp = _hx_bit.arshift(i,2);
    blks[tmp] = _hx_bit.bor(blks[tmp],_hx_bit.lshift(b.b[i],(_hx_bit.lshift((_hx_bit.band((_hx_bit.lshift(b.length,3)) + i,3)),3))));
    i = i + 1;
  end;
  local tmp = _hx_bit.arshift(i,2);
  blks[tmp] = _hx_bit.bor(blks[tmp],_hx_bit.lshift(128,(_G.math.fmod(((b.length * 8) + i), 4)) * 8));
  local l = b.length * 8;
  local k = (nblk * 16) - 2;
  blks[k] = _hx_bit.band(l,255);
  blks[k] = _hx_bit.bor(blks[k],_hx_bit.lshift((_hx_bit.band(_hx_bit.rshift(l,8),255)),8));
  blks[k] = _hx_bit.bor(blks[k],_hx_bit.lshift((_hx_bit.band(_hx_bit.rshift(l,16),255)),16));
  blks[k] = _hx_bit.bor(blks[k],_hx_bit.lshift((_hx_bit.band(_hx_bit.rshift(l,24),255)),24));
  do return blks end;
end
__haxe_crypto_Md5.prototype = _hx_e();
__haxe_crypto_Md5.prototype.bitOR = function(self,a,b) 
  do return _hx_bit.bor(_hx_bit.lshift((_hx_bit.bor(_hx_bit.rshift(a,1),_hx_bit.rshift(b,1))),1),(_hx_bit.bor(_hx_bit.band(a,1),_hx_bit.band(b,1)))) end
end
__haxe_crypto_Md5.prototype.bitXOR = function(self,a,b) 
  do return _hx_bit.bor(_hx_bit.lshift((_hx_bit.bxor(_hx_bit.rshift(a,1),_hx_bit.rshift(b,1))),1),_hx_bit.bxor(_hx_bit.band(a,1),_hx_bit.band(b,1))) end
end
__haxe_crypto_Md5.prototype.bitAND = function(self,a,b) 
  do return _hx_bit.bor(_hx_bit.lshift((_hx_bit.band(_hx_bit.rshift(a,1),_hx_bit.rshift(b,1))),1),_hx_bit.band(_hx_bit.band(a,1),(_hx_bit.band(b,1)))) end
end
__haxe_crypto_Md5.prototype.addme = function(self,x,y) 
  local lsw = (_hx_bit.band(x,65535)) + (_hx_bit.band(y,65535));
  do return _hx_bit.bor(_hx_bit.lshift(((_hx_bit.arshift(x,16)) + (_hx_bit.arshift(y,16))) + (_hx_bit.arshift(lsw,16)),16),_hx_bit.band(lsw,65535)) end
end
__haxe_crypto_Md5.prototype.rol = function(self,num,cnt) 
  do return _hx_bit.bor(_hx_bit.lshift(num,cnt),_hx_bit.rshift(num,32 - cnt)) end
end
__haxe_crypto_Md5.prototype.cmn = function(self,q,a,b,x,s,t) 
  do return self:addme(self:rol(self:addme(self:addme(a, q), self:addme(x, t)), s), b) end
end
__haxe_crypto_Md5.prototype.ff = function(self,a,b,c,d,x,s,t) 
  do return self:cmn(self:bitOR(self:bitAND(b, c), self:bitAND(_hx_bit.bnot(b), d)), a, b, x, s, t) end
end
__haxe_crypto_Md5.prototype.gg = function(self,a,b,c,d,x,s,t) 
  do return self:cmn(self:bitOR(self:bitAND(b, d), self:bitAND(c, _hx_bit.bnot(d))), a, b, x, s, t) end
end
__haxe_crypto_Md5.prototype.hh = function(self,a,b,c,d,x,s,t) 
  do return self:cmn(self:bitXOR(self:bitXOR(b, c), d), a, b, x, s, t) end
end
__haxe_crypto_Md5.prototype.ii = function(self,a,b,c,d,x,s,t) 
  do return self:cmn(self:bitXOR(c, self:bitOR(b, _hx_bit.bnot(d))), a, b, x, s, t) end
end
__haxe_crypto_Md5.prototype.doEncode = function(self,x) 
  local a = 1732584193;
  local b = -271733879;
  local c = -1732584194;
  local d = 271733878;
  local i = 0;
  while (i < x.length) do 
    local olda = a;
    local oldb = b;
    local oldc = c;
    local oldd = d;
    a = self:ff(a, b, c, d, x[i], 7, -680876936);
    d = self:ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = self:ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = self:ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = self:ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = self:ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = self:ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = self:ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = self:ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = self:ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = self:ff(c, d, a, b, x[i + 10], 17, -42063);
    b = self:ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = self:ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = self:ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = self:ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = self:ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = self:gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = self:gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = self:gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = self:gg(b, c, d, a, x[i], 20, -373897302);
    a = self:gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = self:gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = self:gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = self:gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = self:gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = self:gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = self:gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = self:gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = self:gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = self:gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = self:gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = self:gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = self:hh(a, b, c, d, x[i + 5], 4, -378558);
    d = self:hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = self:hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = self:hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = self:hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = self:hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = self:hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = self:hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = self:hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = self:hh(d, a, b, c, x[i], 11, -358537222);
    c = self:hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = self:hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = self:hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = self:hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = self:hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = self:hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = self:ii(a, b, c, d, x[i], 6, -198630844);
    d = self:ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = self:ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = self:ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = self:ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = self:ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = self:ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = self:ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = self:ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = self:ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = self:ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = self:ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = self:ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = self:ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = self:ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = self:ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = self:addme(a, olda);
    b = self:addme(b, oldb);
    c = self:addme(c, oldc);
    d = self:addme(d, oldd);
    i = i + 16;
  end;
  do return _hx_tab_array({[0]=a, b, c, d}, 4) end
end

__haxe_crypto_Md5.prototype.__class__ =  __haxe_crypto_Md5

__haxe_ds_BalancedTree.new = function() 
  local self = _hx_new(__haxe_ds_BalancedTree.prototype)
  __haxe_ds_BalancedTree.super(self)
  return self
end
__haxe_ds_BalancedTree.super = function(self) 
end
_hxClasses["haxe.ds.BalancedTree"] = __haxe_ds_BalancedTree
__haxe_ds_BalancedTree.__name__ = "haxe.ds.BalancedTree"
__haxe_ds_BalancedTree.__interfaces__ = {__haxe_IMap}
__haxe_ds_BalancedTree.prototype = _hx_e();
__haxe_ds_BalancedTree.prototype.set = function(self,key,value) 
  self.root = self:setLoop(key, value, self.root);
end
__haxe_ds_BalancedTree.prototype.get = function(self,key) 
  local node = self.root;
  while (node ~= nil) do 
    local c = self:compare(key, node.key);
    if (c == 0) then 
      do return node.value end;
    end;
    if (c < 0) then 
      node = node.left;
    else
      node = node.right;
    end;
  end;
  do return nil end
end
__haxe_ds_BalancedTree.prototype.keys = function(self) 
  local ret = _hx_tab_array({}, 0);
  self:keysLoop(self.root, ret);
  do return __haxe_iterators_ArrayIterator.new(ret) end
end
__haxe_ds_BalancedTree.prototype.setLoop = function(self,k,v,node) 
  if (node == nil) then 
    do return __haxe_ds_TreeNode.new(nil, k, v, nil) end;
  end;
  local c = self:compare(k, node.key);
  if (c == 0) then 
    do return __haxe_ds_TreeNode.new(node.left, k, v, node.right, (function() 
      local _hx_1
      if (node == nil) then 
      _hx_1 = 0; else 
      _hx_1 = node._height; end
      return _hx_1
    end )()) end;
  else
    if (c < 0) then 
      do return self:balance(self:setLoop(k, v, node.left), node.key, node.value, node.right) end;
    else
      local nr = self:setLoop(k, v, node.right);
      do return self:balance(node.left, node.key, node.value, nr) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.keysLoop = function(self,node,acc) 
  if (node ~= nil) then 
    self:keysLoop(node.left, acc);
    acc:push(node.key);
    self:keysLoop(node.right, acc);
  end;
end
__haxe_ds_BalancedTree.prototype.balance = function(self,l,k,v,r) 
  local hl = (function() 
    local _hx_1
    if (l == nil) then 
    _hx_1 = 0; else 
    _hx_1 = l._height; end
    return _hx_1
  end )();
  local hr = (function() 
    local _hx_2
    if (r == nil) then 
    _hx_2 = 0; else 
    _hx_2 = r._height; end
    return _hx_2
  end )();
  if (hl > (hr + 2)) then 
    local _this = l.left;
    local _this1 = l.right;
    if ((function() 
      local _hx_3
      if (_this == nil) then 
      _hx_3 = 0; else 
      _hx_3 = _this._height; end
      return _hx_3
    end )() >= (function() 
      local _hx_4
      if (_this1 == nil) then 
      _hx_4 = 0; else 
      _hx_4 = _this1._height; end
      return _hx_4
    end )()) then 
      do return __haxe_ds_TreeNode.new(l.left, l.key, l.value, __haxe_ds_TreeNode.new(l.right, k, v, r)) end;
    else
      do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l.left, l.key, l.value, l.right.left), l.right.key, l.right.value, __haxe_ds_TreeNode.new(l.right.right, k, v, r)) end;
    end;
  else
    if (hr > (hl + 2)) then 
      local _this = r.right;
      local _this1 = r.left;
      if ((function() 
        local _hx_5
        if (_this == nil) then 
        _hx_5 = 0; else 
        _hx_5 = _this._height; end
        return _hx_5
      end )() > (function() 
        local _hx_6
        if (_this1 == nil) then 
        _hx_6 = 0; else 
        _hx_6 = _this1._height; end
        return _hx_6
      end )()) then 
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left), r.key, r.value, r.right) end;
      else
        do return __haxe_ds_TreeNode.new(__haxe_ds_TreeNode.new(l, k, v, r.left.left), r.left.key, r.left.value, __haxe_ds_TreeNode.new(r.left.right, r.key, r.value, r.right)) end;
      end;
    else
      do return __haxe_ds_TreeNode.new(l, k, v, r, (function() 
        local _hx_7
        if (hl > hr) then 
        _hx_7 = hl; else 
        _hx_7 = hr; end
        return _hx_7
      end )() + 1) end;
    end;
  end;
end
__haxe_ds_BalancedTree.prototype.compare = function(self,k1,k2) 
  do return Reflect.compare(k1, k2) end
end

__haxe_ds_BalancedTree.prototype.__class__ =  __haxe_ds_BalancedTree

__haxe_ds_TreeNode.new = function(l,k,v,r,h) 
  local self = _hx_new(__haxe_ds_TreeNode.prototype)
  __haxe_ds_TreeNode.super(self,l,k,v,r,h)
  return self
end
__haxe_ds_TreeNode.super = function(self,l,k,v,r,h) 
  if (h == nil) then 
    h = -1;
  end;
  self.left = l;
  self.key = k;
  self.value = v;
  self.right = r;
  if (h == -1) then 
    local tmp;
    local _this = self.left;
    local _this1 = self.right;
    if ((function() 
      local _hx_1
      if (_this == nil) then 
      _hx_1 = 0; else 
      _hx_1 = _this._height; end
      return _hx_1
    end )() > (function() 
      local _hx_2
      if (_this1 == nil) then 
      _hx_2 = 0; else 
      _hx_2 = _this1._height; end
      return _hx_2
    end )()) then 
      local _this = self.left;
      tmp = (function() 
        local _hx_3
        if (_this == nil) then 
        _hx_3 = 0; else 
        _hx_3 = _this._height; end
        return _hx_3
      end )();
    else
      local _this = self.right;
      tmp = (function() 
        local _hx_4
        if (_this == nil) then 
        _hx_4 = 0; else 
        _hx_4 = _this._height; end
        return _hx_4
      end )();
    end;
    self._height = tmp + 1;
  else
    self._height = h;
  end;
end
_hxClasses["haxe.ds.TreeNode"] = __haxe_ds_TreeNode
__haxe_ds_TreeNode.__name__ = "haxe.ds.TreeNode"
__haxe_ds_TreeNode.prototype = _hx_e();

__haxe_ds_TreeNode.prototype.__class__ =  __haxe_ds_TreeNode

__haxe_ds_EnumValueMap.new = function() 
  local self = _hx_new(__haxe_ds_EnumValueMap.prototype)
  __haxe_ds_EnumValueMap.super(self)
  return self
end
__haxe_ds_EnumValueMap.super = function(self) 
  __haxe_ds_BalancedTree.super(self);
end
_hxClasses["haxe.ds.EnumValueMap"] = __haxe_ds_EnumValueMap
__haxe_ds_EnumValueMap.__name__ = "haxe.ds.EnumValueMap"
__haxe_ds_EnumValueMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_EnumValueMap.prototype = _hx_e();
__haxe_ds_EnumValueMap.prototype.compare = function(self,k1,k2) 
  local d = k1[1] - k2[1];
  if (d ~= 0) then 
    do return d end;
  end;
  local p1 = k1:slice(2);
  local p2 = k2:slice(2);
  if ((p1.length == 0) and (p2.length == 0)) then 
    do return 0 end;
  end;
  do return self:compareArgs(p1, p2) end
end
__haxe_ds_EnumValueMap.prototype.compareArgs = function(self,a1,a2) 
  local ld = a1.length - a2.length;
  if (ld ~= 0) then 
    do return ld end;
  end;
  local _g = 0;
  local _g1 = a1.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local d = self:compareArg(a1[i], a2[i]);
    if (d ~= 0) then 
      do return d end;
    end;
  end;
  do return 0 end
end
__haxe_ds_EnumValueMap.prototype.compareArg = function(self,v1,v2) 
  if (Reflect.isEnumValue(v1) and Reflect.isEnumValue(v2)) then 
    do return self:compare(v1, v2) end;
  else
    if (__lua_Boot.__instanceof(v1, Array) and __lua_Boot.__instanceof(v2, Array)) then 
      do return self:compareArgs(v1, v2) end;
    else
      do return Reflect.compare(v1, v2) end;
    end;
  end;
end

__haxe_ds_EnumValueMap.prototype.__class__ =  __haxe_ds_EnumValueMap
__haxe_ds_EnumValueMap.__super__ = __haxe_ds_BalancedTree
setmetatable(__haxe_ds_EnumValueMap.prototype,{__index=__haxe_ds_BalancedTree.prototype})

__haxe_ds_List.new = function() 
  local self = _hx_new(__haxe_ds_List.prototype)
  __haxe_ds_List.super(self)
  return self
end
__haxe_ds_List.super = function(self) 
  self.length = 0;
end
_hxClasses["haxe.ds.List"] = __haxe_ds_List
__haxe_ds_List.__name__ = "haxe.ds.List"
__haxe_ds_List.prototype = _hx_e();
__haxe_ds_List.prototype.add = function(self,item) 
  local next = nil;
  local x = __haxe_ds__List_ListNode.new(item, next);
  if (self.h == nil) then 
    self.h = x;
  else
    self.q.next = x;
  end;
  self.q = x;
  self.length = self.length + 1;
end

__haxe_ds_List.prototype.__class__ =  __haxe_ds_List

__haxe_ds__List_ListNode.new = function(item,next) 
  local self = _hx_new(__haxe_ds__List_ListNode.prototype)
  __haxe_ds__List_ListNode.super(self,item,next)
  return self
end
__haxe_ds__List_ListNode.super = function(self,item,next) 
  self.item = item;
  self.next = next;
end
_hxClasses["haxe.ds._List.ListNode"] = __haxe_ds__List_ListNode
__haxe_ds__List_ListNode.__name__ = "haxe.ds._List.ListNode"
__haxe_ds__List_ListNode.prototype = _hx_e();

__haxe_ds__List_ListNode.prototype.__class__ =  __haxe_ds__List_ListNode
_hxClasses["haxe.ds.Option"] = __haxe_ds_Option;
_hxClasses["haxe.ds.Option"] = { __ename__ = "haxe.ds.Option", __constructs__ = _hx_tab_array({[0]="Some","None"},2)}
__haxe_ds_Option = _hxClasses["haxe.ds.Option"];
__haxe_ds_Option.Some = function(v) local _x = _hx_tab_array({[0]="Some",0,v,__enum__=__haxe_ds_Option}, 3); return _x; end 
__haxe_ds_Option.None = _hx_tab_array({[0]="None",1,__enum__ = __haxe_ds_Option},2)


__haxe_io_Bytes.new = function(length,b) 
  local self = _hx_new(__haxe_io_Bytes.prototype)
  __haxe_io_Bytes.super(self,length,b)
  return self
end
__haxe_io_Bytes.super = function(self,length,b) 
  self.length = length;
  self.b = b;
end
_hxClasses["haxe.io.Bytes"] = __haxe_io_Bytes
__haxe_io_Bytes.__name__ = "haxe.io.Bytes"
__haxe_io_Bytes.alloc = function(length) 
  local a = Array.new();
  local _g = 0;
  while (_g < length) do 
    _g = _g + 1;
    a:push(0);
  end;
  do return __haxe_io_Bytes.new(length, a) end;
end
__haxe_io_Bytes.ofString = function(s,encoding) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = _G.string.len(s);
  while (_g1 < _g2) do 
    _g1 = _g1 + 1;
    _g:push(_G.string.byte(s, (_g1 - 1) + 1));
  end;
  do return __haxe_io_Bytes.new(_g.length, _g) end;
end
__haxe_io_Bytes.prototype = _hx_e();
__haxe_io_Bytes.prototype.sub = function(self,pos,len) 
  if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  do return __haxe_io_Bytes.new(len, self.b:slice(pos, pos + len)) end
end
__haxe_io_Bytes.prototype.compare = function(self,other) 
  local b1 = self.b;
  local b2 = other.b;
  local len = (function() 
    local _hx_1
    if (self.length < other.length) then 
    _hx_1 = self.length; else 
    _hx_1 = other.length; end
    return _hx_1
  end )();
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    if (b1[i] ~= b2[i]) then 
      do return b1[i] - b2[i] end;
    end;
  end;
  do return self.length - other.length end
end
__haxe_io_Bytes.prototype.getFloat = function(self,pos) 
  local v = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(self.b[pos],_hx_bit.lshift(self.b[pos + 1],8)),_hx_bit.lshift(self.b[pos + 2],16)),_hx_bit.lshift(self.b[pos + 3],24));
  do return __haxe_io_FPHelper.i32ToFloat(_hx_bit_clamp((function() 
    local _hx_1
    if ((_hx_bit.band(v,-2147483648)) ~= 0) then 
    _hx_1 = _hx_bit.bor(v,-2147483648); else 
    _hx_1 = v; end
    return _hx_1
  end )())) end
end
__haxe_io_Bytes.prototype.getString = function(self,pos,len,encoding) 
  local tmp = encoding == nil;
  if (((pos < 0) or (len < 0)) or ((pos + len) > self.length)) then 
    _G.error(__haxe_Exception.thrown(__haxe_io_Error.OutsideBounds),0);
  end;
  if ((self.b.length - pos) <= __lua_Boot.MAXSTACKSIZE) then 
    local _end = Math.min(self.b.length, pos + len) - 1;
    do return _G.string.char(_hx_table.unpack(self.b, pos, _end)) end;
  else
    local tbl = ({});
    local _g = pos;
    local _g1 = pos + len;
    while (_g < _g1) do 
      _g = _g + 1;
      local idx = _g - 1;
      _G.table.insert(tbl, _G.string.char(self.b[idx]));
    end;
    do return _G.table.concat(tbl, "") end;
  end;
end
__haxe_io_Bytes.prototype.toString = function(self) 
  do return self:getString(0, self.length) end
end
__haxe_io_Bytes.prototype.toHex = function(self) 
  local s_b = ({});
  local chars = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = #"0123456789abcdef";
  while (_g < _g1) do 
    _g = _g + 1;
    chars:push(_G.string.byte("0123456789abcdef", (_g - 1) + 1));
  end;
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local c = self.b[_g - 1];
    _G.table.insert(s_b, _G.string.char(chars[_hx_bit.arshift(c,4)]));
    _G.table.insert(s_b, _G.string.char(chars[_hx_bit.band(c,15)]));
  end;
  do return _G.table.concat(s_b) end
end

__haxe_io_Bytes.prototype.__class__ =  __haxe_io_Bytes

__haxe_io_BytesBuffer.new = function() 
  local self = _hx_new(__haxe_io_BytesBuffer.prototype)
  __haxe_io_BytesBuffer.super(self)
  return self
end
__haxe_io_BytesBuffer.super = function(self) 
  self.b = Array.new();
end
_hxClasses["haxe.io.BytesBuffer"] = __haxe_io_BytesBuffer
__haxe_io_BytesBuffer.__name__ = "haxe.io.BytesBuffer"
__haxe_io_BytesBuffer.prototype = _hx_e();
__haxe_io_BytesBuffer.prototype.addInt32 = function(self,v) 
  self.b:push(_hx_bit.band(v,255));
  self.b:push(_hx_bit.band(_hx_bit.arshift(v,8),255));
  self.b:push(_hx_bit.band(_hx_bit.arshift(v,16),255));
  self.b:push(_hx_bit.rshift(v,24));
end
__haxe_io_BytesBuffer.prototype.addInt64 = function(self,v) 
  self:addInt32(v.low);
  self:addInt32(v.high);
end
__haxe_io_BytesBuffer.prototype.getBytes = function(self) 
  local bytes = __haxe_io_Bytes.new(self.b.length, self.b);
  self.b = nil;
  do return bytes end
end

__haxe_io_BytesBuffer.prototype.__class__ =  __haxe_io_BytesBuffer
_hxClasses["haxe.io.Encoding"] = __haxe_io_Encoding;
_hxClasses["haxe.io.Encoding"] = { __ename__ = "haxe.io.Encoding", __constructs__ = _hx_tab_array({[0]="UTF8","RawNative"},2)}
__haxe_io_Encoding = _hxClasses["haxe.io.Encoding"];
__haxe_io_Encoding.UTF8 = _hx_tab_array({[0]="UTF8",0,__enum__ = __haxe_io_Encoding},2)

__haxe_io_Encoding.RawNative = _hx_tab_array({[0]="RawNative",1,__enum__ = __haxe_io_Encoding},2)


__haxe_io_Eof.new = function() 
  local self = _hx_new(__haxe_io_Eof.prototype)
  __haxe_io_Eof.super(self)
  return self
end
__haxe_io_Eof.super = function(self) 
end
_hxClasses["haxe.io.Eof"] = __haxe_io_Eof
__haxe_io_Eof.__name__ = "haxe.io.Eof"
__haxe_io_Eof.prototype = _hx_e();
__haxe_io_Eof.prototype.toString = function(self) 
  do return "Eof" end
end

__haxe_io_Eof.prototype.__class__ =  __haxe_io_Eof
_hxClasses["haxe.io.Error"] = __haxe_io_Error;
_hxClasses["haxe.io.Error"] = { __ename__ = "haxe.io.Error", __constructs__ = _hx_tab_array({[0]="Blocked","Overflow","OutsideBounds","Custom"},4)}
__haxe_io_Error = _hxClasses["haxe.io.Error"];
__haxe_io_Error.Blocked = _hx_tab_array({[0]="Blocked",0,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Overflow = _hx_tab_array({[0]="Overflow",1,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.OutsideBounds = _hx_tab_array({[0]="OutsideBounds",2,__enum__ = __haxe_io_Error},2)

__haxe_io_Error.Custom = function(e) local _x = _hx_tab_array({[0]="Custom",3,e,__enum__=__haxe_io_Error}, 3); return _x; end 

__haxe_io_FPHelper.new = {}
_hxClasses["haxe.io.FPHelper"] = __haxe_io_FPHelper
__haxe_io_FPHelper.__name__ = "haxe.io.FPHelper"
__haxe_io_FPHelper.i32ToFloat = function(i) 
  local sign = 1 - (_hx_bit.lshift(_hx_bit.rshift(i,31),1));
  local e = _hx_bit.band(_hx_bit.arshift(i,23),255);
  if (e == 255) then 
    if ((_hx_bit.band(i,8388607)) == 0) then 
      if (sign > 0) then 
        do return _G.math.huge end;
      else
        do return -_G.math.huge end;
      end;
    else
      do return (0/0) end;
    end;
  else
    do return (sign * (function() 
      local _hx_1
      if (e == 0) then 
      _hx_1 = _hx_bit.lshift((_hx_bit.band(i,8388607)),1); else 
      _hx_1 = _hx_bit.bor(_hx_bit.band(i,8388607),8388608); end
      return _hx_1
    end )()) * _G.math.pow(2, e - 150) end;
  end;
end
__haxe_io_FPHelper.floatToI32 = function(f) 
  if (f == 0) then 
    do return 0 end;
  else
    local af = (function() 
      local _hx_1
      if (f < 0) then 
      _hx_1 = -f; else 
      _hx_1 = f; end
      return _hx_1
    end )();
    local exp = _G.math.floor(_G.math.log(af) / 0.6931471805599453);
    if (exp > 127) then 
      do return 2139095040 end;
    else
      if (exp <= -127) then 
        exp = -127;
        af = af * 7.1362384635298e+44;
      else
        af = ((af / _G.math.pow(2, exp)) - 1.0) * 8388608;
      end;
      do return _hx_bit.bor(_hx_bit.bor(((function() 
        local _hx_2
        if (f < 0) then 
        _hx_2 = -2147483648; else 
        _hx_2 = 0; end
        return _hx_2
      end )()),_hx_bit.lshift(exp + 127,23)),_G.math.floor(af + 0.5)) end;
    end;
  end;
end

__haxe_iterators_ArrayIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayIterator.prototype)
  __haxe_iterators_ArrayIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
_hxClasses["haxe.iterators.ArrayIterator"] = __haxe_iterators_ArrayIterator
__haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator"
__haxe_iterators_ArrayIterator.prototype = _hx_e();
__haxe_iterators_ArrayIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayIterator.prototype.next = function(self) 
  do return self.array[(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()] end
end

__haxe_iterators_ArrayIterator.prototype.__class__ =  __haxe_iterators_ArrayIterator

__haxe_iterators_ArrayKeyValueIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayKeyValueIterator.prototype)
  __haxe_iterators_ArrayKeyValueIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayKeyValueIterator.super = function(self,array) 
  self.array = array;
end
_hxClasses["haxe.iterators.ArrayKeyValueIterator"] = __haxe_iterators_ArrayKeyValueIterator
__haxe_iterators_ArrayKeyValueIterator.__name__ = "haxe.iterators.ArrayKeyValueIterator"
__haxe_iterators_ArrayKeyValueIterator.prototype = _hx_e();

__haxe_iterators_ArrayKeyValueIterator.prototype.__class__ =  __haxe_iterators_ArrayKeyValueIterator

__haxe_rtti_Meta.new = {}
_hxClasses["haxe.rtti.Meta"] = __haxe_rtti_Meta
__haxe_rtti_Meta.__name__ = "haxe.rtti.Meta"
__haxe_rtti_Meta.getType = function(t) 
  local meta = __haxe_rtti_Meta.getMeta(t);
  if ((meta == nil) or (meta.obj == nil)) then 
    do return _hx_e() end;
  else
    do return meta.obj end;
  end;
end
__haxe_rtti_Meta.getMeta = function(t) 
  do return t.__meta__ end;
end

__hxbit_ConvertField.new = function(path,from,to) 
  local self = _hx_new(__hxbit_ConvertField.prototype)
  __hxbit_ConvertField.super(self,path,from,to)
  return self
end
__hxbit_ConvertField.super = function(self,path,from,to) 
  self.path = path;
  self.from = from;
  self.to = to;
end
_hxClasses["hxbit.ConvertField"] = __hxbit_ConvertField
__hxbit_ConvertField.__name__ = "hxbit.ConvertField"
__hxbit_ConvertField.prototype = _hx_e();

__hxbit_ConvertField.prototype.__class__ =  __hxbit_ConvertField

__hxbit_Convert.new = function(classPath,ourSchema,schema) 
  local self = _hx_new(__hxbit_Convert.prototype)
  __hxbit_Convert.super(self,classPath,ourSchema,schema)
  return self
end
__hxbit_Convert.super = function(self,classPath,ourSchema,schema) 
  local ourMap_h = ({});
  local _g = 0;
  local _g1 = ourSchema.fieldsNames.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local key = ourSchema.fieldsNames[i];
    local value = ourSchema.fieldsTypes[i];
    if (value == nil) then 
      ourMap_h[key] = __haxe_ds_StringMap.tnull;
    else
      ourMap_h[key] = value;
    end;
  end;
  self.read = _hx_tab_array({}, 0);
  self.hadCID = not schema.isFinal;
  self.hasCID = not ourSchema.isFinal;
  local map_h = ({});
  local _g = 0;
  local _g1 = schema.fieldsNames.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local oldT = schema.fieldsTypes[i];
    local ret = ourMap_h[schema.fieldsNames[i]];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local newT = ret;
    local c = __hxbit_ConvertField.new(Std.string(Std.string(classPath) .. Std.string(".")) .. Std.string(schema.fieldsNames[i]), oldT, newT);
    if (newT ~= nil) then 
      if (__hxbit_Convert.sameType(oldT, newT)) then 
        c.same = true;
      else
        local ret = __hxbit_Convert.convFuns.h[c.path];
        if (ret == __haxe_ds_StringMap.tnull) then 
          ret = nil;
        end;
        c.conv = _hx_funcToField(ret);
        c.defaultValue = __hxbit_Convert.getDefault(newT);
      end;
    end;
    c.index = self.read.length;
    self.read:push(c);
    local key = schema.fieldsNames[i];
    if (c == nil) then 
      map_h[key] = __haxe_ds_StringMap.tnull;
    else
      map_h[key] = c;
    end;
  end;
  self.write = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = ourSchema.fieldsNames.length;
  while (_g < _g1) do 
    _g = _g + 1;
    local i = _g - 1;
    local newT = ourSchema.fieldsTypes[i];
    local ret = map_h[ourSchema.fieldsNames[i]];
    if (ret == __haxe_ds_StringMap.tnull) then 
      ret = nil;
    end;
    local c = ret;
    local c1 = c;
    if (c == nil) then 
      c1 = __hxbit_ConvertField.new(nil, nil, newT);
      c1.defaultValue = __hxbit_Convert.getDefault(newT);
    end;
    self.write:push(c1);
  end;
end
_hxClasses["hxbit.Convert"] = __hxbit_Convert
__hxbit_Convert.__name__ = "hxbit.Convert"
__hxbit_Convert.sameType = function(a,b) 
  local _hx_continue_1 = false;
  while (true) do repeat 
    local tmp = a[1];
    if (tmp) == 0 then 
      local tmp = b[1];
      if (tmp) == 10 then 
        b = b[2];
        break;
      elseif (tmp) == 16 then 
        do return true end;else
      do return Type.enumEq(a, b) end; end;
    elseif (tmp) == 7 then 
      local _g = a[3];
      local _g1 = a[2];
      local tmp = b[1];
      if (tmp) == 7 then 
        if (__hxbit_Convert.sameType(_g1, b[2])) then 
          do return __hxbit_Convert.sameType(_g, b[3]) end;
        else
          do return false end;
        end;
      elseif (tmp) == 10 then 
        b = b[2];
        break;else
      do return Type.enumEq(a, b) end; end;
    elseif (tmp) == 8 then 
      local _g = a[2];
      local tmp = b[1];
      if (tmp) == 8 then 
        a = _g;
        b = b[2];
        break;
      elseif (tmp) == 10 then 
        b = b[2];
        break;else
      do return Type.enumEq(a, b) end; end;
    elseif (tmp) == 9 then 
      local _g = a[2];
      local tmp = b[1];
      if (tmp) == 9 then 
        local _g1 = b[2];
        if (_g.length ~= _g1.length) then 
          do return false end;
        end;
        local _g2 = 0;
        local _g3 = _g.length;
        while (_g2 < _g3) do 
          _g2 = _g2 + 1;
          local i = _g2 - 1;
          local a = _g[i];
          local b = _g1[i];
          if (((a.name ~= b.name) or (a.opt ~= b.opt)) or not __hxbit_Convert.sameType(a.type, b.type)) then 
            do return false end;
          end;
        end;
        do return true end;
      elseif (tmp) == 10 then 
        b = b[2];
        break;else
      do return Type.enumEq(a, b) end; end;
    elseif (tmp) == 10 then 
      local _g = a[2];
      if (b[1] == 10) then 
        a = _g;
        b = b[2];
        break;
      else
        a = _g;
        break;
      end;
    elseif (tmp) == 11 then 
      local _g = a[2];
      local tmp = b[1];
      if (tmp) == 10 then 
        b = b[2];
        break;
      elseif (tmp) == 11 then 
        a = _g;
        b = b[2];
        break;else
      do return Type.enumEq(a, b) end; end;
    elseif (tmp) == 12 then 
      local _g = a[2];
      local tmp = b[1];
      if (tmp) == 10 then 
        b = b[2];
        break;
      elseif (tmp) == 12 then 
        a = _g;
        b = b[2];
        break;else
      do return Type.enumEq(a, b) end; end;
    elseif (tmp) == 16 then 
      local tmp = b[1];
      if (tmp) == 0 then 
        do return true end;
      elseif (tmp) == 10 then 
        b = b[2];
        break;else
      do return Type.enumEq(a, b) end; end;else
    if (b[1] == 10) then 
      b = b[2];
      break;
    else
      do return Type.enumEq(a, b) end;
    end; end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
end
__hxbit_Convert.getDefault = function(t) 
  local _hx_continue_1 = false;
  while (true) do repeat 
    local tmp = t[1];
    if (tmp) == 0 then 
      do return 0 end;
    elseif (tmp) == 1 then 
      do return 0. end;
    elseif (tmp) == 2 then 
      do return false end;
    elseif (tmp) == 5 then 
      do return nil end;
    elseif (tmp) == 6 then 
      do return nil end;
    elseif (tmp) == 7 then 
      local tmp = t[2][1];
      if (tmp) == 0 then 
        do return __haxe_ds_IntMap.new() end;
      elseif (tmp) == 3 then 
        do return __haxe_ds_StringMap.new() end;else
      do return __haxe_ds_ObjectMap.new() end; end;
    elseif (tmp) == 8 then 
      do return _hx_tab_array({}, 0) end;
    elseif (tmp) == 9 then 
      do return nil end;
    elseif (tmp) == 10 then 
      t = t[2];
      break;
    elseif (tmp) == 11 then 
      do return ({length = 0}) end;
    elseif (tmp) == 12 then 
      do return nil end;
    elseif (tmp) == 15 then 
      do return __haxe__Int64____Int64.new(0, 0) end;
    elseif (tmp) == 16 then 
      do return 0 end;
    elseif (tmp) == 3 or (tmp) == 4 or (tmp) == 13 or (tmp) == 14 or (tmp) == 17 then 
      do return nil end; end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
end
__hxbit_Convert.prototype = _hx_e();

__hxbit_Convert.prototype.__class__ =  __hxbit_Convert
_hxClasses["hxbit.PropTypeDesc"] = __hxbit_PropTypeDesc;
_hxClasses["hxbit.PropTypeDesc"] = { __ename__ = "hxbit.PropTypeDesc", __constructs__ = _hx_tab_array({[0]="PInt","PFloat","PBool","PString","PBytes","PSerializable","PEnum","PMap","PArray","PObj","PAlias","PVector","PNull","PUnknown","PDynamic","PInt64","PFlags","PStruct"},18)}
__hxbit_PropTypeDesc = _hxClasses["hxbit.PropTypeDesc"];
__hxbit_PropTypeDesc.PInt = _hx_tab_array({[0]="PInt",0,__enum__ = __hxbit_PropTypeDesc},2)

__hxbit_PropTypeDesc.PFloat = _hx_tab_array({[0]="PFloat",1,__enum__ = __hxbit_PropTypeDesc},2)

__hxbit_PropTypeDesc.PBool = _hx_tab_array({[0]="PBool",2,__enum__ = __hxbit_PropTypeDesc},2)

__hxbit_PropTypeDesc.PString = _hx_tab_array({[0]="PString",3,__enum__ = __hxbit_PropTypeDesc},2)

__hxbit_PropTypeDesc.PBytes = _hx_tab_array({[0]="PBytes",4,__enum__ = __hxbit_PropTypeDesc},2)

__hxbit_PropTypeDesc.PSerializable = function(name) local _x = _hx_tab_array({[0]="PSerializable",5,name,__enum__=__hxbit_PropTypeDesc}, 3); return _x; end 
__hxbit_PropTypeDesc.PEnum = function(name) local _x = _hx_tab_array({[0]="PEnum",6,name,__enum__=__hxbit_PropTypeDesc}, 3); return _x; end 
__hxbit_PropTypeDesc.PMap = function(k,v) local _x = _hx_tab_array({[0]="PMap",7,k,v,__enum__=__hxbit_PropTypeDesc}, 4); return _x; end 
__hxbit_PropTypeDesc.PArray = function(k) local _x = _hx_tab_array({[0]="PArray",8,k,__enum__=__hxbit_PropTypeDesc}, 3); return _x; end 
__hxbit_PropTypeDesc.PObj = function(fields) local _x = _hx_tab_array({[0]="PObj",9,fields,__enum__=__hxbit_PropTypeDesc}, 3); return _x; end 
__hxbit_PropTypeDesc.PAlias = function(k) local _x = _hx_tab_array({[0]="PAlias",10,k,__enum__=__hxbit_PropTypeDesc}, 3); return _x; end 
__hxbit_PropTypeDesc.PVector = function(k) local _x = _hx_tab_array({[0]="PVector",11,k,__enum__=__hxbit_PropTypeDesc}, 3); return _x; end 
__hxbit_PropTypeDesc.PNull = function(t) local _x = _hx_tab_array({[0]="PNull",12,t,__enum__=__hxbit_PropTypeDesc}, 3); return _x; end 
__hxbit_PropTypeDesc.PUnknown = _hx_tab_array({[0]="PUnknown",13,__enum__ = __hxbit_PropTypeDesc},2)

__hxbit_PropTypeDesc.PDynamic = _hx_tab_array({[0]="PDynamic",14,__enum__ = __hxbit_PropTypeDesc},2)

__hxbit_PropTypeDesc.PInt64 = _hx_tab_array({[0]="PInt64",15,__enum__ = __hxbit_PropTypeDesc},2)

__hxbit_PropTypeDesc.PFlags = function(t) local _x = _hx_tab_array({[0]="PFlags",16,t,__enum__=__hxbit_PropTypeDesc}, 3); return _x; end 
__hxbit_PropTypeDesc.PStruct = _hx_tab_array({[0]="PStruct",17,__enum__ = __hxbit_PropTypeDesc},2)


__hxbit_ProxyChild.new = {}
_hxClasses["hxbit.ProxyChild"] = __hxbit_ProxyChild
__hxbit_ProxyChild.__name__ = "hxbit.ProxyChild"

__hxbit_BaseProxy.new = {}
_hxClasses["hxbit.BaseProxy"] = __hxbit_BaseProxy
__hxbit_BaseProxy.__name__ = "hxbit.BaseProxy"
__hxbit_BaseProxy.__interfaces__ = {__hxbit_ProxyChild,__hxbit_ProxyHost}

__hxbit_NetworkSerializer.new = function() 
  local self = _hx_new(__hxbit_NetworkSerializer.prototype)
  __hxbit_NetworkSerializer.super(self)
  return self
end
__hxbit_NetworkSerializer.super = function(self) 
  self.enableChecks = true;
  self.hasError = false;
  __hxbit_Serializer.super(self);
end
_hxClasses["hxbit.NetworkSerializer"] = __hxbit_NetworkSerializer
__hxbit_NetworkSerializer.__name__ = "hxbit.NetworkSerializer"
__hxbit_NetworkSerializer.prototype = _hx_e();
__hxbit_NetworkSerializer.prototype.get_error = function(self) 
  if (not self.hasError) then 
    do return false end;
  end;
  self.hasError = false;
  do return true end
end
__hxbit_NetworkSerializer.prototype.addObjRef = function(self,s) 
  if (not self.enableChecks) then 
    __hxbit_Serializer.prototype.addObjRef(self,s);
    do return end;
  end;
  local v = s.__uid;
  if ((v >= 0) and (v < 128)) then 
    self.out.b:push(v);
  else
    self.out.b:push(128);
    self.out:addInt32(v);
  end;
  local ns = (function() 
    local _hx_1
    if (__lua_Boot.__instanceof(s, __hxbit_NetworkSerializable)) then 
    _hx_1 = s; else 
    _hx_1 = nil; end
    return _hx_1
  end )();
  if ((ns ~= nil) and (ns.__host == nil)) then 
    self.out = __haxe_io_BytesBuffer.new();
    _G.error(__haxe_Exception.thrown(Std.string(Std.string("Can't send unbound object ") .. Std.string(Std.string(s))) .. Std.string(" over network")),0);
  end;
  self.out.b:push((function() 
    local _hx_2
    if (self.refs.h[s.__uid] ~= nil) then 
    _hx_2 = 1; else 
    _hx_2 = 0; end
    return _hx_2
  end )());
end
__hxbit_NetworkSerializer.prototype.getObjRef = function(self) 
  if (not self.enableChecks) then 
    do return __hxbit_Serializer.prototype.getObjRef(self) end;
  end;
  local pos = (function() 
  local _hx_obj = self;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local v = self.input.b[pos];
  if (v == 128) then 
    local _this = self.input;
    local pos = self.inPos;
    local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
    v = _hx_bit_clamp((function() 
      local _hx_1
      if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
      _hx_1 = _hx_bit.bor(v1,-2147483648); else 
      _hx_1 = v1; end
      return _hx_1
    end )());
    local tmp = self;
    tmp.inPos = tmp.inPos + 4;
  end;
  local id = v;
  if (id == 0) then 
    do return 0 end;
  end;
  local pos = (function() 
  local _hx_obj = self;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  if ((self.input.b[pos] ~= 0) and (self.refs.h[id] == nil)) then 
    self.hasError = true;
    do return 0 end;
  end;
  do return id end
end

__hxbit_NetworkSerializer.prototype.__class__ =  __hxbit_NetworkSerializer
__hxbit_NetworkSerializer.__super__ = __hxbit_Serializer
setmetatable(__hxbit_NetworkSerializer.prototype,{__index=__hxbit_Serializer.prototype})

__hxbit_NetworkStats.new = function() 
  local self = _hx_new(__hxbit_NetworkStats.prototype)
  __hxbit_NetworkStats.super(self)
  return self
end
__hxbit_NetworkStats.super = function(self) 
  self.classes = __haxe_ds_IntMap.new();
end
_hxClasses["hxbit.NetworkStats"] = __hxbit_NetworkStats
__hxbit_NetworkStats.__name__ = "hxbit.NetworkStats"
__hxbit_NetworkStats.prototype = _hx_e();
__hxbit_NetworkStats.prototype.getClass = function(self,o) 
  local cid = o:getCLID();
  local ret = self.classes.h[cid];
  if (ret == __haxe_ds_IntMap.tnull) then 
    ret = nil;
  end;
  local c = ret;
  if (c == nil) then 
    local c1 = Type.getClass(o);
    c = _hx_o({__fields__={name=true,props=true,rpcs=true,schema=true},name=c1.__name__,props=_hx_tab_array({}, 0),rpcs=_hx_tab_array({}, 0),schema=o:getSerializeSchema()});
    local _this = self.classes;
    if (c == nil) then 
      _this.h[cid] = __haxe_ds_IntMap.tnull;
    else
      _this.h[cid] = c;
    end;
  end;
  do return c end
end
__hxbit_NetworkStats.prototype.isNullable = function(self,t) 
  local tmp = t[1];
  if (tmp) == 0 or (tmp) == 1 or (tmp) == 2 then 
    do return false end;else
  do return true end; end;
end
__hxbit_NetworkStats.prototype.calcPropSize = function(self,t,v) 
  local size = 0;
  local tmp = t[1];
  if (tmp) == 0 then 
    local v = v;
    size = (function() 
      local _hx_1
      if ((v >= 0) and (v < 128)) then 
      _hx_1 = 1; else 
      _hx_1 = 5; end
      return _hx_1
    end )();
  elseif (tmp) == 1 then 
    size = 4;
  elseif (tmp) == 2 then 
    size = 1;
  elseif (tmp) == 3 then 
    if (v == nil) then 
      size = 1;
    else
      local b = __haxe_io_Bytes.ofString(v);
      local v = b.length + 1;
      size = (function() 
        local _hx_2
        if ((v >= 0) and (v < 128)) then 
        _hx_2 = 1; else 
        _hx_2 = 5; end
        return _hx_2
      end )() + b.length;
    end;
  elseif (tmp) == 4 then 
    if (v == nil) then 
      size = 1;
    else
      local b = v;
      local v = b.length + 1;
      size = (function() 
        local _hx_3
        if ((v >= 0) and (v < 128)) then 
        _hx_3 = 1; else 
        _hx_3 = 5; end
        return _hx_3
      end )() + b.length;
    end;
  elseif (tmp) == 5 then 
    local size1;
    if (v == nil) then 
      size1 = 1;
    else
      local v = v.__uid;
      size1 = (function() 
        local _hx_4
        if ((v >= 0) and (v < 128)) then 
        _hx_4 = 1; else 
        _hx_4 = 5; end
        return _hx_4
      end )();
    end;
    size = size1;
  elseif (tmp) == 6 then 
    local size1;
    if (v == nil) then 
      size1 = 1;
    else
      local v = v[1] + 1;
      size1 = (function() 
        local _hx_5
        if ((v >= 0) and (v < 128)) then 
        _hx_5 = 1; else 
        _hx_5 = 5; end
        return _hx_5
      end )();
    end;
    size = size1;
  elseif (tmp) == 7 then 
    local _g = t[3];
    local _g1 = t[2];
    if (v == nil) then 
      size = 1;
    else
      if (__lua_Boot.__instanceof(v, __hxbit_BaseProxy)) then 
        v = v.map;
      end;
      local tmp = _g1[1];
      if (tmp) == 0 then 
        local m = v;
        local _g1 = _hx_tab_array({}, 0);
        local k = m:keys();
        while (k:hasNext()) do 
          _g1:push(k:next());
        end;
        local v = _g1.length + 1;
        size = (function() 
          local _hx_6
          if ((v >= 0) and (v < 128)) then 
          _hx_6 = 1; else 
          _hx_6 = 5; end
          return _hx_6
        end )();
        local _g2 = 0;
        while (_g2 < _g1.length) do 
          local v = _g1[_g2];
          _g2 = _g2 + 1;
          local ret = m.h[v];
          if (ret == __haxe_ds_IntMap.tnull) then 
            ret = nil;
          end;
          size = size + ((function() 
            local _hx_7
            if ((v >= 0) and (v < 128)) then 
            _hx_7 = 1; else 
            _hx_7 = 5; end
            return _hx_7
          end )() + self:calcPropSize(_g, ret));
        end;
      elseif (tmp) == 3 then 
        local m = v;
        local _g2 = _hx_tab_array({}, 0);
        local k = m:keys();
        while (k:hasNext()) do 
          _g2:push(k:next());
        end;
        local v = _g2.length + 1;
        size = (function() 
          local _hx_8
          if ((v >= 0) and (v < 128)) then 
          _hx_8 = 1; else 
          _hx_8 = 5; end
          return _hx_8
        end )();
        local _g3 = 0;
        while (_g3 < _g2.length) do 
          local v = _g2[_g3];
          _g3 = _g3 + 1;
          local size1 = self:calcPropSize(_g1, v);
          local ret = m.h[v];
          if (ret == __haxe_ds_StringMap.tnull) then 
            ret = nil;
          end;
          size = size + (size1 + self:calcPropSize(_g, ret));
        end;else
      local m = v;
      local _g2 = _hx_tab_array({}, 0);
      local k = m:keys();
      while (k:hasNext()) do 
        _g2:push(k:next());
      end;
      local v = _g2.length + 1;
      size = (function() 
        local _hx_9
        if ((v >= 0) and (v < 128)) then 
        _hx_9 = 1; else 
        _hx_9 = 5; end
        return _hx_9
      end )();
      local _g3 = 0;
      while (_g3 < _g2.length) do 
        local v = _g2[_g3];
        _g3 = _g3 + 1;
        size = size + (self:calcPropSize(_g1, v) + self:calcPropSize(_g, m:get(v)));
      end; end;
    end;
  elseif (tmp) == 8 then 
    local _g = t[2];
    if (__lua_Boot.__instanceof(v, __hxbit_BaseProxy)) then 
      v = v.array;
    end;
    local a = v;
    if (a == nil) then 
      size = 1;
    else
      local v = a.length + 1;
      size = (function() 
        local _hx_10
        if ((v >= 0) and (v < 128)) then 
        _hx_10 = 1; else 
        _hx_10 = 5; end
        return _hx_10
      end )();
      local _g1 = 0;
      while (_g1 < a.length) do 
        local v = a[_g1];
        _g1 = _g1 + 1;
        size = size + self:calcPropSize(_g, v);
      end;
    end;
  elseif (tmp) == 9 then 
    local _g = t[2];
    if (v == nil) then 
      size = 1;
    else
      local fbits = 0;
      local _g1 = _hx_tab_array({}, 0);
      local _g2 = 0;
      while (_g2 < _g.length) do 
        local f = _g[_g2];
        _g2 = _g2 + 1;
        if (self:isNullable(f.type)) then 
          _g1:push(f);
        end;
      end;
      local _g2 = 0;
      local _g3 = _g1.length;
      while (_g2 < _g3) do 
        _g2 = _g2 + 1;
        local i = _g2 - 1;
        if (Reflect.field(v, _g1[i].name) ~= nil) then 
          fbits = _hx_bit.bor(fbits,_hx_bit.lshift(1,i));
        end;
      end;
      local v1 = fbits + 1;
      size = (function() 
        local _hx_11
        if ((v1 >= 0) and (v1 < 128)) then 
        _hx_11 = 1; else 
        _hx_11 = 5; end
        return _hx_11
      end )();
      local _g2 = 0;
      local _hx_continue_1 = false;
      while (_g2 < _g.length) do repeat 
        local f = _g[_g2];
        _g2 = _g2 + 1;
        local nidx = _g1:indexOf(f);
        if ((nidx >= 0) and ((_hx_bit.band(fbits,_hx_bit.lshift(1,nidx))) == 0)) then 
          break;
        end;
        size = size + self:calcPropSize(f.type, Reflect.field(v, f.name));until true
        if _hx_continue_1 then 
        _hx_continue_1 = false;
        break;
        end;
        
      end;
    end;
  elseif (tmp) == 10 then 
    do return self:calcPropSize(t[2], v) end;
  elseif (tmp) == 11 then 
    local _g = t[2];
    if (v == nil) then 
      size = 1;
    else
      local v = v;
      local v1 = v.length + 1;
      size = (function() 
        local _hx_12
        if ((v1 >= 0) and (v1 < 128)) then 
        _hx_12 = 1; else 
        _hx_12 = 5; end
        return _hx_12
      end )();
      local _g1 = 0;
      while (_g1 < v.length) do 
        local e = v[_g1];
        _g1 = _g1 + 1;
        size = size + self:calcPropSize(_g, e);
      end;
    end;
  elseif (tmp) == 12 then 
    size = 1 + self:calcPropSize(t[2], v);
  elseif (tmp) == 13 then 
    _G.error(__haxe_Exception.thrown("assert"),0);
  elseif (tmp) == 14 then 
    local s = __hxbit_Serializer.new();
    s:begin();
    s:addDynamic(v);
    size = s.out.b.length;
  elseif (tmp) == 15 then 
    size = 8;
  elseif (tmp) == 16 then 
    if (__lua_Boot.__instanceof(v, __hxbit_BaseProxy)) then 
      v = v.value;
    end;
    local v = v;
    size = (function() 
      local _hx_13
      if ((v >= 0) and (v < 128)) then 
      _hx_13 = 1; else 
      _hx_13 = 5; end
      return _hx_13
    end )();
  elseif (tmp) == 17 then  end;
  do return size end
end
__hxbit_NetworkStats.prototype.sync = function(self,o) 
  local c = self:getClass(o);
  local i = 0;
  while ((_hx_bit.lshift(1,i)) <= o.__bits) do 
    if ((_hx_bit.band(o.__bits,_hx_bit.lshift(1,i))) ~= 0) then 
      local p = c.props[i];
      if (p == nil) then 
        p = _hx_o({__fields__={cl=true,name=true,count=true,bytes=true,size=true},cl=c,name=o:networkGetName(i),count=0,bytes=0,size=0});
        c.props[i] = p;
      end;
      p.count = p.count + 1;
      local p1 = p;
      p1.bytes = p1.bytes + self:calcPropSize(c.schema.fieldsTypes[i], Reflect.field(o, p.name));
    end;
    i = i + 1;
  end;
end
__hxbit_NetworkStats.prototype.beginRPC = function(self,o,id) 
  local c = self:getClass(o);
  local r = c.rpcs[id];
  if (r == nil) then 
    r = _hx_o({__fields__={cl=true,name=true,count=true,bytes=true,size=true},cl=c,name=o:networkGetName(id, true),count=0,bytes=0,size=0});
    c.rpcs[id] = r;
  end;
  self.curRPC = r;
  r.count = r.count + 1;
  do return r end
end

__hxbit_NetworkStats.prototype.__class__ =  __hxbit_NetworkStats

__hxbit_Schema.new = function() 
  local self = _hx_new(__hxbit_Schema.prototype)
  __hxbit_Schema.super(self)
  return self
end
__hxbit_Schema.super = function(self) 
  self.__uid = _hx_bit.bor(_hx_bit.lshift(__hxbit_Serializer.SEQ,24),(function() 
  local _hx_obj = __hxbit_Serializer;
  local _hx_fld = 'UID';
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _hx_obj[_hx_fld];
   end)());
  self.fieldsNames = _hx_tab_array({}, 0);
  self.fieldsTypes = _hx_tab_array({}, 0);
end
_hxClasses["hxbit.Schema"] = __hxbit_Schema
__hxbit_Schema.__name__ = "hxbit.Schema"
__hxbit_Schema.__interfaces__ = {__hxbit_Serializable}
__hxbit_Schema.prototype = _hx_e();
__hxbit_Schema.prototype.get_checkSum = function(self) 
  local s = __hxbit_Serializer.new();
  s:begin();
  local old = self.__uid;
  self.__uid = 0;
  s:addKnownRef(self);
  self.__uid = old;
  do return __haxe_crypto_Crc32.make(_hx_apply_self(s,"end")) end
end
__hxbit_Schema.prototype.getCLID = function(self) 
  do return __hxbit_Schema.__clid end
end
__hxbit_Schema.prototype.serialize = function(self,__ctx) 
  __ctx.out.b:push((function() 
    local _hx_1
    if (self.isFinal) then 
    _hx_1 = 1; else 
    _hx_1 = 0; end
    return _hx_1
  end )());
  local a = self.fieldsNames;
  if (a == nil) then 
    __ctx.out.b:push(0);
  else
    local v = a.length + 1;
    if ((v >= 0) and (v < 128)) then 
      __ctx.out.b:push(v);
    else
      __ctx.out.b:push(128);
      __ctx.out:addInt32(v);
    end;
    local _g = 0;
    while (_g < a.length) do 
      local v = a[_g];
      _g = _g + 1;
      if (v == nil) then 
        __ctx.out.b:push(0);
      else
        local b = __haxe_io_Bytes.ofString(v);
        local v = b.length + 1;
        if ((v >= 0) and (v < 128)) then 
          __ctx.out.b:push(v);
        else
          __ctx.out.b:push(128);
          __ctx.out:addInt32(v);
        end;
        local _this = __ctx.out;
        local b2 = b.b;
        local _g = 0;
        local _g1 = b.length;
        while (_g < _g1) do 
          _g = _g + 1;
          _this.b:push(b2[_g - 1]);
        end;
      end;
    end;
  end;
  local a = self.fieldsTypes;
  if (a == nil) then 
    __ctx.out.b:push(0);
  else
    local v = a.length + 1;
    if ((v >= 0) and (v < 128)) then 
      __ctx.out.b:push(v);
    else
      __ctx.out.b:push(128);
      __ctx.out:addInt32(v);
    end;
    local _g = 0;
    while (_g < a.length) do 
      local v = a[_g];
      _g = _g + 1;
      __hxbit_enumSer_Hxbit_PropTypeDesc.doSerialize(__ctx, v);
    end;
  end;
end
__hxbit_Schema.prototype.getSerializeSchema = function(self) 
  local schema = __hxbit_Schema.new();
  schema.fieldsNames:push("isFinal");
  schema.fieldsTypes:push(__hxbit_PropTypeDesc.PBool);
  schema.fieldsNames:push("fieldsNames");
  schema.fieldsTypes:push(__hxbit_PropTypeDesc.PArray(__hxbit_PropTypeDesc.PString));
  schema.fieldsNames:push("fieldsTypes");
  schema.fieldsTypes:push(__hxbit_PropTypeDesc.PArray(__hxbit_PropTypeDesc.PEnum("hxbit.PropTypeDesc")));
  schema.isFinal = __hxbit_Serializer.isClassFinal(__hxbit_Schema.__clid);
  do return schema end
end
__hxbit_Schema.prototype.unserializeInit = function(self) 
end
__hxbit_Schema.prototype.unserialize = function(self,__ctx) 
  local pos = (function() 
  local _hx_obj = __ctx;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  self.isFinal = __ctx.input.b[pos] ~= 0;
  local e0;
  local pos = (function() 
  local _hx_obj = __ctx;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local v = __ctx.input.b[pos];
  if (v == 128) then 
    local _this = __ctx.input;
    local pos = __ctx.inPos;
    local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
    v = _hx_bit_clamp((function() 
      local _hx_1
      if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
      _hx_1 = _hx_bit.bor(v1,-2147483648); else 
      _hx_1 = v1; end
      return _hx_1
    end )());
    local __ctx = __ctx;
    __ctx.inPos = __ctx.inPos + 4;
  end;
  local len = v;
  local tmp;
  if (len == 0) then 
    tmp = nil;
  else
    len = len - 1;
    local a = _hx_tab_array({}, 0);
    local _g = 0;
    local _g1 = len;
    while (_g < _g1) do 
      _g = _g + 1;
      local pos = (function() 
      local _hx_obj = __ctx;
      local _hx_fld = 'inPos';
      local _ = _hx_obj[_hx_fld];
      _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
       return _;
       end)();
      local v = __ctx.input.b[pos];
      if (v == 128) then 
        local _this = __ctx.input;
        local pos = __ctx.inPos;
        local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
        v = _hx_bit_clamp((function() 
          local _hx_2
          if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
          _hx_2 = _hx_bit.bor(v1,-2147483648); else 
          _hx_2 = v1; end
          return _hx_2
        end )());
        local __ctx = __ctx;
        __ctx.inPos = __ctx.inPos + 4;
      end;
      local len = v;
      if (len == 0) then 
        e0 = nil;
      else
        len = len - 1;
        local s = __ctx.input:getString(__ctx.inPos, len);
        local __ctx = __ctx;
        __ctx.inPos = __ctx.inPos + len;
        e0 = s;
      end;
      a[_g - 1] = e0;
    end;
    tmp = a;
  end;
  self.fieldsNames = tmp;
  local e0;
  local pos = (function() 
  local _hx_obj = __ctx;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local v = __ctx.input.b[pos];
  if (v == 128) then 
    local _this = __ctx.input;
    local pos = __ctx.inPos;
    local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
    v = _hx_bit_clamp((function() 
      local _hx_3
      if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
      _hx_3 = _hx_bit.bor(v1,-2147483648); else 
      _hx_3 = v1; end
      return _hx_3
    end )());
    local __ctx = __ctx;
    __ctx.inPos = __ctx.inPos + 4;
  end;
  local len = v;
  local tmp;
  if (len == 0) then 
    tmp = nil;
  else
    len = len - 1;
    local a = _hx_tab_array({}, 0);
    local _g = 0;
    local _g1 = len;
    while (_g < _g1) do 
      _g = _g + 1;
      e0 = __hxbit_enumSer_Hxbit_PropTypeDesc.doUnserialize(__ctx);
      a[_g - 1] = e0;
    end;
    tmp = a;
  end;
  self.fieldsTypes = tmp;
end

__hxbit_Schema.prototype.__class__ =  __hxbit_Schema

__hxbit_StructSerializable.new = {}
_hxClasses["hxbit.StructSerializable"] = __hxbit_StructSerializable
__hxbit_StructSerializable.__name__ = "hxbit.StructSerializable"
__hxbit_StructSerializable.prototype = _hx_e();

__hxbit_StructSerializable.prototype.__class__ =  __hxbit_StructSerializable

__hxbit_enumSer_Deceptinfect_infection_INF_STATE.new = {}
_hxClasses["hxbit.enumSer.Deceptinfect_infection_INF_STATE"] = __hxbit_enumSer_Deceptinfect_infection_INF_STATE
__hxbit_enumSer_Deceptinfect_infection_INF_STATE.__name__ = "hxbit.enumSer.Deceptinfect_infection_INF_STATE"
__hxbit_enumSer_Deceptinfect_infection_INF_STATE.doSerialize = function(ctx,v) 
  if (v == nil) then 
    ctx.out.b:push(0);
  else
    local tmp = v[1];
    if (tmp) == 0 then 
      ctx.out.b:push(1);
      local a = v[2];
      if (a == nil) then 
        ctx.out.b:push(0);
      else
        local v = a.length + 1;
        if ((v >= 0) and (v < 128)) then 
          ctx.out.b:push(v);
        else
          ctx.out.b:push(128);
          ctx.out:addInt32(v);
        end;
        local _g = 0;
        while (_g < a.length) do 
          local v = a[_g];
          _g = _g + 1;
          ctx.out:addInt32(__haxe_io_FPHelper.floatToI32(v));
        end;
      end;
    elseif (tmp) == 1 then 
      ctx.out.b:push(2); end;
  end;
end
__hxbit_enumSer_Deceptinfect_infection_INF_STATE.doUnserialize = function(ctx) 
  local pos = (function() 
  local _hx_obj = ctx;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local b = ctx.input.b[pos];
  if (b == 0) then 
    do return nil end;
  end;
  local b1 = b;
  if (b1) == 1 then 
    local _inf;
    local v0;
    local e1;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_1
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_1 = _hx_bit.bor(v1,-2147483648); else 
        _hx_1 = v1; end
        return _hx_1
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local len = v;
    if (len == 0) then 
      v0 = nil;
    else
      len = len - 1;
      local a = ({length = len});
      local _g = 0;
      local _g1 = len;
      while (_g < _g1) do 
        _g = _g + 1;
        local v = ctx.input:getFloat(ctx.inPos);
        local ctx = ctx;
        ctx.inPos = ctx.inPos + 4;
        e1 = v;
        a[_g - 1] = e1;
      end;
      v0 = a;
    end;
    _inf = v0;
    do return __deceptinfect_infection_INF_STATE.NOT_INFECTED(_inf) end;
  elseif (b1) == 2 then 
    do return __deceptinfect_infection_INF_STATE.INFECTED end;else
  _G.error(__haxe_Exception.thrown(Std.string("Invalid enum index ") .. Std.string(b)),0); end;
end

__hxbit_enumSer_Hxbit_PropTypeDesc.new = {}
_hxClasses["hxbit.enumSer.Hxbit_PropTypeDesc"] = __hxbit_enumSer_Hxbit_PropTypeDesc
__hxbit_enumSer_Hxbit_PropTypeDesc.__name__ = "hxbit.enumSer.Hxbit_PropTypeDesc"
__hxbit_enumSer_Hxbit_PropTypeDesc.doSerialize = function(ctx,v) 
  local _hx_continue_1 = false;
  while (true) do repeat 
    local _gctx = ctx;
    if (v == nil) then 
      _gctx.out.b:push(0);
    else
      local tmp = v[1];
      if (tmp) == 0 then 
        _gctx.out.b:push(1);
      elseif (tmp) == 1 then 
        _gctx.out.b:push(2);
      elseif (tmp) == 2 then 
        _gctx.out.b:push(3);
      elseif (tmp) == 3 then 
        _gctx.out.b:push(4);
      elseif (tmp) == 4 then 
        _gctx.out.b:push(5);
      elseif (tmp) == 5 then 
        local _g = v[2];
        _gctx.out.b:push(6);
        if (_g == nil) then 
          _gctx.out.b:push(0);
        else
          local b = __haxe_io_Bytes.ofString(_g);
          local v = b.length + 1;
          if ((v >= 0) and (v < 128)) then 
            _gctx.out.b:push(v);
          else
            _gctx.out.b:push(128);
            _gctx.out:addInt32(v);
          end;
          local _this = _gctx.out;
          local b2 = b.b;
          local _g = 0;
          local _g1 = b.length;
          while (_g < _g1) do 
            _g = _g + 1;
            _this.b:push(b2[_g - 1]);
          end;
        end;
      elseif (tmp) == 6 then 
        local _g = v[2];
        _gctx.out.b:push(7);
        if (_g == nil) then 
          _gctx.out.b:push(0);
        else
          local b = __haxe_io_Bytes.ofString(_g);
          local v = b.length + 1;
          if ((v >= 0) and (v < 128)) then 
            _gctx.out.b:push(v);
          else
            _gctx.out.b:push(128);
            _gctx.out:addInt32(v);
          end;
          local _this = _gctx.out;
          local b2 = b.b;
          local _g = 0;
          local _g1 = b.length;
          while (_g < _g1) do 
            _g = _g + 1;
            _this.b:push(b2[_g - 1]);
          end;
        end;
      elseif (tmp) == 7 then 
        _gctx.out.b:push(8);
        __hxbit_enumSer_Hxbit_PropTypeDesc.doSerialize(_gctx, v[2]);
        ctx = _gctx;
        v = v[3];
        break;
      elseif (tmp) == 8 then 
        _gctx.out.b:push(9);
        ctx = _gctx;
        v = v[2];
        break;
      elseif (tmp) == 9 then 
        local _g = v[2];
        _gctx.out.b:push(10);
        if (_g == nil) then 
          _gctx.out.b:push(0);
        else
          local v = _g.length + 1;
          if ((v >= 0) and (v < 128)) then 
            _gctx.out.b:push(v);
          else
            _gctx.out.b:push(128);
            _gctx.out:addInt32(v);
          end;
          local _g1 = 0;
          while (_g1 < _g.length) do 
            local v = _g[_g1];
            _g1 = _g1 + 1;
            if (v == nil) then 
              _gctx.out.b:push(0);
            else
              local fbits = 0;
              if (v.name ~= nil) then 
                fbits = 1;
              end;
              if (v.type ~= nil) then 
                fbits = _hx_bit.bor(fbits,2);
              end;
              local v1 = fbits + 1;
              if ((v1 >= 0) and (v1 < 128)) then 
                _gctx.out.b:push(v1);
              else
                _gctx.out.b:push(128);
                _gctx.out:addInt32(v1);
              end;
              if ((_hx_bit.band(fbits,1)) ~= 0) then 
                local s = v.name;
                if (s == nil) then 
                  _gctx.out.b:push(0);
                else
                  local b = __haxe_io_Bytes.ofString(s);
                  local v = b.length + 1;
                  if ((v >= 0) and (v < 128)) then 
                    _gctx.out.b:push(v);
                  else
                    _gctx.out.b:push(128);
                    _gctx.out:addInt32(v);
                  end;
                  local _this = _gctx.out;
                  local b2 = b.b;
                  local _g = 0;
                  local _g1 = b.length;
                  while (_g < _g1) do 
                    _g = _g + 1;
                    _this.b:push(b2[_g - 1]);
                  end;
                end;
              end;
              _gctx.out.b:push((function() 
                local _hx_1
                if (v.opt) then 
                _hx_1 = 1; else 
                _hx_1 = 0; end
                return _hx_1
              end )());
              if ((_hx_bit.band(fbits,2)) ~= 0) then 
                __hxbit_enumSer_Hxbit_PropTypeDesc.doSerialize(_gctx, v.type);
              end;
            end;
          end;
        end;
      elseif (tmp) == 10 then 
        _gctx.out.b:push(11);
        ctx = _gctx;
        v = v[2];
        break;
      elseif (tmp) == 11 then 
        _gctx.out.b:push(12);
        ctx = _gctx;
        v = v[2];
        break;
      elseif (tmp) == 12 then 
        _gctx.out.b:push(13);
        ctx = _gctx;
        v = v[2];
        break;
      elseif (tmp) == 13 then 
        _gctx.out.b:push(14);
      elseif (tmp) == 14 then 
        _gctx.out.b:push(15);
      elseif (tmp) == 15 then 
        _gctx.out.b:push(16);
      elseif (tmp) == 16 then 
        _gctx.out.b:push(17);
        ctx = _gctx;
        v = v[2];
        break;
      elseif (tmp) == 17 then 
        _gctx.out.b:push(18); end;
    end;
    do return end;until true
    if _hx_continue_1 then 
    _hx_continue_1 = false;
    break;
    end;
    
  end;
end
__hxbit_enumSer_Hxbit_PropTypeDesc.doUnserialize = function(ctx) 
  local pos = (function() 
  local _hx_obj = ctx;
  local _hx_fld = 'inPos';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)();
  local b = ctx.input.b[pos];
  if (b == 0) then 
    do return nil end;
  end;
  local b1 = b;
  if (b1) == 1 then 
    do return __hxbit_PropTypeDesc.PInt end;
  elseif (b1) == 2 then 
    do return __hxbit_PropTypeDesc.PFloat end;
  elseif (b1) == 3 then 
    do return __hxbit_PropTypeDesc.PBool end;
  elseif (b1) == 4 then 
    do return __hxbit_PropTypeDesc.PString end;
  elseif (b1) == 5 then 
    do return __hxbit_PropTypeDesc.PBytes end;
  elseif (b1) == 6 then 
    local _name;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_1
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_1 = _hx_bit.bor(v1,-2147483648); else 
        _hx_1 = v1; end
        return _hx_1
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local len = v;
    if (len == 0) then 
      _name = nil;
    else
      len = len - 1;
      local s = ctx.input:getString(ctx.inPos, len);
      local ctx = ctx;
      ctx.inPos = ctx.inPos + len;
      _name = s;
    end;
    do return __hxbit_PropTypeDesc.PSerializable(_name) end;
  elseif (b1) == 7 then 
    local _name;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_2
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_2 = _hx_bit.bor(v1,-2147483648); else 
        _hx_2 = v1; end
        return _hx_2
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local len = v;
    if (len == 0) then 
      _name = nil;
    else
      len = len - 1;
      local s = ctx.input:getString(ctx.inPos, len);
      local ctx = ctx;
      ctx.inPos = ctx.inPos + len;
      _name = s;
    end;
    do return __hxbit_PropTypeDesc.PEnum(_name) end;
  elseif (b1) == 8 then 
    do return __hxbit_PropTypeDesc.PMap(__hxbit_enumSer_Hxbit_PropTypeDesc.doUnserialize(ctx), __hxbit_enumSer_Hxbit_PropTypeDesc.doUnserialize(ctx)) end;
  elseif (b1) == 9 then 
    do return __hxbit_PropTypeDesc.PArray(__hxbit_enumSer_Hxbit_PropTypeDesc.doUnserialize(ctx)) end;
  elseif (b1) == 10 then 
    local _fields;
    local e0;
    local pos = (function() 
    local _hx_obj = ctx;
    local _hx_fld = 'inPos';
    local _ = _hx_obj[_hx_fld];
    _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
     return _;
     end)();
    local v = ctx.input.b[pos];
    if (v == 128) then 
      local _this = ctx.input;
      local pos = ctx.inPos;
      local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
      v = _hx_bit_clamp((function() 
        local _hx_3
        if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
        _hx_3 = _hx_bit.bor(v1,-2147483648); else 
        _hx_3 = v1; end
        return _hx_3
      end )());
      local ctx = ctx;
      ctx.inPos = ctx.inPos + 4;
    end;
    local len = v;
    if (len == 0) then 
      _fields = nil;
    else
      len = len - 1;
      local a = _hx_tab_array({}, 0);
      local _g = 0;
      local _g1 = len;
      while (_g < _g1) do 
        _g = _g + 1;
        local pos = (function() 
        local _hx_obj = ctx;
        local _hx_fld = 'inPos';
        local _ = _hx_obj[_hx_fld];
        _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
         return _;
         end)();
        local v = ctx.input.b[pos];
        if (v == 128) then 
          local _this = ctx.input;
          local pos = ctx.inPos;
          local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
          v = _hx_bit_clamp((function() 
            local _hx_4
            if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
            _hx_4 = _hx_bit.bor(v1,-2147483648); else 
            _hx_4 = v1; end
            return _hx_4
          end )());
          local ctx = ctx;
          ctx.inPos = ctx.inPos + 4;
        end;
        local fbits = v;
        if (fbits == 0) then 
          e0 = nil;
        else
          fbits = fbits - 1;
          local type = nil;
          local name = nil;
          if ((_hx_bit.band(fbits,1)) ~= 0) then 
            local pos = (function() 
            local _hx_obj = ctx;
            local _hx_fld = 'inPos';
            local _ = _hx_obj[_hx_fld];
            _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
             return _;
             end)();
            local v = ctx.input.b[pos];
            if (v == 128) then 
              local _this = ctx.input;
              local pos = ctx.inPos;
              local v1 = _hx_bit.bor(_hx_bit.bor(_hx_bit.bor(_this.b[pos],_hx_bit.lshift(_this.b[pos + 1],8)),_hx_bit.lshift(_this.b[pos + 2],16)),_hx_bit.lshift(_this.b[pos + 3],24));
              v = _hx_bit_clamp((function() 
                local _hx_5
                if ((_hx_bit.band(v1,-2147483648)) ~= 0) then 
                _hx_5 = _hx_bit.bor(v1,-2147483648); else 
                _hx_5 = v1; end
                return _hx_5
              end )());
              local ctx = ctx;
              ctx.inPos = ctx.inPos + 4;
            end;
            local len = v;
            if (len == 0) then 
              name = nil;
            else
              len = len - 1;
              local s = ctx.input:getString(ctx.inPos, len);
              local ctx = ctx;
              ctx.inPos = ctx.inPos + len;
              name = s;
            end;
          end;
          local pos = (function() 
          local _hx_obj = ctx;
          local _hx_fld = 'inPos';
          local _ = _hx_obj[_hx_fld];
          _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
           return _;
           end)();
          local opt = ctx.input.b[pos] ~= 0;
          if ((_hx_bit.band(fbits,2)) ~= 0) then 
            type = __hxbit_enumSer_Hxbit_PropTypeDesc.doUnserialize(ctx);
          end;
          e0 = _hx_o({__fields__={name=true,opt=true,type=true},name=name,opt=opt,type=type});
        end;
        a[_g - 1] = e0;
      end;
      _fields = a;
    end;
    do return __hxbit_PropTypeDesc.PObj(_fields) end;
  elseif (b1) == 11 then 
    do return __hxbit_PropTypeDesc.PAlias(__hxbit_enumSer_Hxbit_PropTypeDesc.doUnserialize(ctx)) end;
  elseif (b1) == 12 then 
    do return __hxbit_PropTypeDesc.PVector(__hxbit_enumSer_Hxbit_PropTypeDesc.doUnserialize(ctx)) end;
  elseif (b1) == 13 then 
    do return __hxbit_PropTypeDesc.PNull(__hxbit_enumSer_Hxbit_PropTypeDesc.doUnserialize(ctx)) end;
  elseif (b1) == 14 then 
    do return __hxbit_PropTypeDesc.PUnknown end;
  elseif (b1) == 15 then 
    do return __hxbit_PropTypeDesc.PDynamic end;
  elseif (b1) == 16 then 
    do return __hxbit_PropTypeDesc.PInt64 end;
  elseif (b1) == 17 then 
    do return __hxbit_PropTypeDesc.PFlags(__hxbit_enumSer_Hxbit_PropTypeDesc.doUnserialize(ctx)) end;
  elseif (b1) == 18 then 
    do return __hxbit_PropTypeDesc.PStruct end;else
  _G.error(__haxe_Exception.thrown(Std.string("Invalid enum index ") .. Std.string(b)),0); end;
end

__tink_core__Callback_Callback_Impl_.new = {}
_hxClasses["tink.core._Callback.Callback_Impl_"] = __tink_core__Callback_Callback_Impl_
__tink_core__Callback_Callback_Impl_.__name__ = "tink.core._Callback.Callback_Impl_"
__tink_core__Callback_Callback_Impl_.invoke = function(this1,data) 
  if (__tink_core__Callback_Callback_Impl_.depth < 500) then 
    __tink_core__Callback_Callback_Impl_.depth = __tink_core__Callback_Callback_Impl_.depth + 1;
    this1(data);
    __tink_core__Callback_Callback_Impl_.depth = __tink_core__Callback_Callback_Impl_.depth - 1;
  else
    local _e = this1;
    local _g = function(data) 
      __tink_core__Callback_Callback_Impl_.invoke(_e, data);
    end;
    local data = data;
    __tink_core__Callback_Callback_Impl_.defer(function() 
      _g(data);
    end);
  end;
end
__tink_core__Callback_Callback_Impl_.fromNiladic = function(f) 
  do return function(_) 
    f();
  end end;
end
__tink_core__Callback_Callback_Impl_.defer = function(f) 
  __haxe_Timer.delay(f, 0);
end

__tink_core_LinkObject.new = {}
_hxClasses["tink.core.LinkObject"] = __tink_core_LinkObject
__tink_core_LinkObject.__name__ = "tink.core.LinkObject"

__tink_core__Callback_ListCell.new = function(cb,list) 
  local self = _hx_new(__tink_core__Callback_ListCell.prototype)
  __tink_core__Callback_ListCell.super(self,cb,list)
  return self
end
__tink_core__Callback_ListCell.super = function(self,cb,list) 
  if (cb == nil) then 
    _G.error(__haxe_Exception.thrown("callback expected but null received"),0);
  end;
  self.cb = cb;
  self.list = list;
end
_hxClasses["tink.core._Callback.ListCell"] = __tink_core__Callback_ListCell
__tink_core__Callback_ListCell.__name__ = "tink.core._Callback.ListCell"
__tink_core__Callback_ListCell.__interfaces__ = {__tink_core_LinkObject}
__tink_core__Callback_ListCell.prototype = _hx_e();

__tink_core__Callback_ListCell.prototype.__class__ =  __tink_core__Callback_ListCell

__tink_core_CallbackList.new = function() 
  local self = _hx_new(__tink_core_CallbackList.prototype)
  __tink_core_CallbackList.super(self)
  return self
end
__tink_core_CallbackList.super = function(self) 
  self.busy = false;
  self.queue = _hx_tab_array({}, 0);
  self.used = 0;
  self.cells = _hx_tab_array({}, 0);
end
_hxClasses["tink.core.CallbackList"] = __tink_core_CallbackList
__tink_core_CallbackList.__name__ = "tink.core.CallbackList"
__tink_core_CallbackList.prototype = _hx_e();
__tink_core_CallbackList.prototype.ondrain = function(self) 
end
__tink_core_CallbackList.prototype.invoke = function(self,data,destructive) 
  if (self.busy) then 
    local _g = _hx_bind(self,self.invoke);
    local data = data;
    local destructive = destructive;
    local tmp = function() 
      _g(data, destructive);
    end;
    self.queue:push(tmp);
  else
    self.busy = true;
    local length = self.cells.length;
    local _g = 0;
    while (_g < length) do 
      _g = _g + 1;
      local _this = self.cells[_g - 1];
      if (_this.list ~= nil) then 
        __tink_core__Callback_Callback_Impl_.invoke(_this.cb, data);
      end;
    end;
    self.busy = false;
    if (destructive) then 
      local added = self.cells.length - length;
      local _g = 0;
      while (_g < length) do 
        _g = _g + 1;
        local _this = self.cells[_g - 1];
        _this.cb = nil;
        _this.list = nil;
      end;
      local _g = 0;
      while (_g < added) do 
        _g = _g + 1;
        local i = _g - 1;
        self.cells[i] = self.cells[length + i];
      end;
      self:resize(added);
    else
      if (self.used < self.cells.length) then 
        self:compact();
      end;
    end;
    if (self.queue.length > 0) then 
      (self.queue:shift())();
    end;
  end;
end
__tink_core_CallbackList.prototype.compact = function(self) 
  if (self.busy) then 
    do return end;
  else
    if (self.used == 0) then 
      self:resize(0);
      self:ondrain();
    else
      local compacted = 0;
      local _g = 0;
      local _g1 = self.cells.length;
      while (_g < _g1) do 
        _g = _g + 1;
        local i = _g - 1;
        local _g = self.cells[i];
        if (_g.cb ~= nil) then 
          if (compacted ~= i) then 
            self.cells[compacted] = _g;
          end;
          compacted = compacted + 1;
          if (compacted == self.used) then 
            break;
          end;
        end;
      end;
      self:resize(self.used);
    end;
  end;
end
__tink_core_CallbackList.prototype.resize = function(self,length) 
  self.cells:resize(length);
end
__tink_core_CallbackList.prototype.clear = function(self) 
  if (self.busy) then 
    self.queue:push(_hx_bind(self,self.clear));
  end;
  local _g = 0;
  local _g1 = self.cells;
  while (_g < _g1.length) do 
    local cell = _g1[_g];
    _g = _g + 1;
    cell.cb = nil;
    cell.list = nil;
  end;
  self:resize(0);
end

__tink_core_CallbackList.prototype.__class__ =  __tink_core_CallbackList
-- require this for lua 5.1
pcall(require, 'bit')
if bit then
  _hx_bit_raw = bit
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
else
  _hx_bit_raw = _G.require('bit32')
  _hx_bit = setmetatable({}, { __index = _hx_bit_raw });
  -- lua 5.2 weirdness
  _hx_bit.bnot = function(...) return _hx_bit_clamp(_hx_bit_raw.bnot(...)) end;
  _hx_bit.bxor = function(...) return _hx_bit_clamp(_hx_bit_raw.bxor(...)) end;
end
-- see https://github.com/HaxeFoundation/haxe/issues/8849
_hx_bit.bor = function(...) return _hx_bit_clamp(_hx_bit_raw.bor(...)) end;
_hx_bit.band = function(...) return _hx_bit_clamp(_hx_bit_raw.band(...)) end;
_hx_bit.arshift = function(...) return _hx_bit_clamp(_hx_bit_raw.arshift(...)) end;

if _hx_bit_raw then
    _hx_bit_clamp = function(v)
    if v <= 2147483647 and v >= -2147483648 then
        if v > 0 then return _G.math.floor(v)
        else return _G.math.ceil(v)
        end
    end
    if v > 2251798999999999 then v = v*2 end;
    if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
    return _hx_bit_raw.band(v, 2147483647 ) - math.abs(_hx_bit_raw.band(v, 2147483648))
    end
else
    _hx_bit_clamp = function(v)
        if v < -2147483648 then
            return -2147483648
        elseif v > 2147483647 then
            return 2147483647
        elseif v > 0 then
            return _G.math.floor(v)
        else
            return _G.math.ceil(v)
        end
    end
end;



_hx_array_mt.__index = Array.prototype

local _hx_static_init = function()
  
  String.__name__ = "String";
  _hxClasses.Array = Array;
  Array.__name__ = "Array";__haxe_ds_StringMap.tnull = ({});
  
  __lua_Boot.MAXSTACKSIZE = 1000;
  
  __deceptinfect_GameManager.state = __deceptinfect_GAME_STATE.WAIT;
  
  __deceptinfect_GameManager.stateTrig = __tink_core_SignalTrigger.new();
  
  __deceptinfect_GameManager.net_gamestate = NETMESSAGE_gamestate.new();
  
  __deceptinfect_GameManager.net_cleanup = NETMESSAGE_di_cleanup.new();
  
  __deceptinfect_GameValues.MIN_PLAYERS = 3;
  
  __deceptinfect_GameValues.INF_INIT_MIN = 1.5;
  
  __deceptinfect_GameValues.INF_INIT_MAX = 7.5;
  
  __deceptinfect_GameValues.CONTAMINATE_WARNING_TIME = 4;
  
  __deceptinfect_GameValues.RADIATION_WARNING_TIME = 1.5;
  
  __deceptinfect_GameValues.MAX_INF_RATE = 12;
  
  __deceptinfect_GameValues.GAME_TIMER = 540;
  
  __deceptinfect_GameValues.GAME_TIMER_VARIANCE = 45;
  
  __deceptinfect_GameValues.EVAC_ARRIVAL = 25;
  
  __deceptinfect_GameValues.LOW_HEALTH_SLOW = 0.75;
  
  __deceptinfect_GameValues.LOW_HEALTH_RATE = 1.6;
  
  __deceptinfect_GameValues.LOW_HEALTH_SLOW_START = 0.4;
  
  __deceptinfect_GameValues.LOW_HEALTH_RATE_START = 0.25;
  
  __deceptinfect_GameValues.AVERAGE_RATE_SAMPLES = 15;
  
  __deceptinfect_GameValues.AVERAGE_RATE_TIME = 3;
  
  __deceptinfect_GameValues.MIN_BATTERY_TIME = 45;
  
  __deceptinfect_GameValues.MAX_BATTERY_TIME = 90;
  
  __deceptinfect_GameValues.MULTIPLE_SOURCES_MODE = 0;
  
  __deceptinfect_GameValues.MULTIPLE_SOURCES_DIMINISH_PERCENT = 0.75;
  
  __deceptinfect_GameValues.MAX_IDENT_DIST = 1000;
  
  __deceptinfect_GameValues.BATTERIES_SPAWNED = 2;
  
  __deceptinfect_GameValues.EVAC_INFECTION_RATE = 0.5;
  
  __deceptinfect_GameValues.BEGIN_EVAC_INF = 0.65;
  
  __deceptinfect_GameValues.BATTERIES_REQUIRED = 4;
  
  __deceptinfect_GameValues.GRAB_TIME = 6;
  
  __deceptinfect_GameValues.SETUP_TIME = 10;
  
  __deceptinfect_MapStorage.spawns = (function() 
    local _hx_1
    
    local _g = __haxe_ds_StringMap.new();
    
    local this1 = _G.Vector(-20.135118, 293.638184, 62.682350);
    local this2 = _G.Vector(214.035873, 252.134552, 46.033661);
    local this3 = _G.Vector(45.967289, -942.858459, 64.031250);
    local this4 = _G.Vector(-4.848439, -1728.742920, 64.031250);
    local this5 = _G.Vector(-481.968323, -1022.401917, 64.031250);
    local this6 = _G.Vector(571.895020, -1031.322632, 64.031250);
    local this7 = _G.Vector(10.328067, -1039.059570, 64.031250);
    local this8 = _G.Vector(-64.220894, -989.030090, 60.787186);
    local this9 = _G.Vector(111.524712, -1094.413208, 110.729080);
    local this10 = _G.Vector(29.061092, 1006.951233, 93.697433);
    local value = _hx_o({__fields__={items=true,objectives=true,evacs=true,nests=true},items=_hx_tab_array({[0]=this1, this2}, 2),objectives=_hx_tab_array({[0]=this3, this4, this5, this6, this7}, 5),evacs=_hx_tab_array({[0]=_hx_o({__fields__={mins=true,maxs=true},mins=this8,maxs=this9})}, 1),nests=_hx_tab_array({[0]=this10}, 1)});
    if (value == nil) then 
      _g.h.mor_temple_v1 = __haxe_ds_StringMap.tnull;
    else
      _g.h.mor_temple_v1 = value;
    end;
    
    _hx_1 = _g;
    return _hx_1
  end )();
  
  __deceptinfect_Misc.roundModels = _hx_tab_array({[0]="models/player/mossman.mdl", "models/player/alyx.mdl", "models/player/barney.mdl", "models/player/breen.mdl", "models/player/Eli.mdl", "models/player/gman_high.mdl", "models/player/kleiner.mdl", "models/player/monk.mdl", "models/player/odessa.mdl", "models/player/Group03/Female_01.mdl", "models/player/Group03/Female_02.mdl", "models/player/Group03/Female_03.mdl", "models/player/Group03/Female_04.mdl", "models/player/Group03/Female_06.mdl", "models/player/Group03/Male_01.mdl", "models/player/Group03/Male_02.mdl", "models/player/Group03/Male_03.mdl", "models/player/Group03/Male_04.mdl", "models/player/Group03/Male_05.mdl", "models/player/Group03/Male_06.mdl", "models/player/Group03/Male_07.mdl", "models/player/Group03/Male_08.mdl", "models/player/Group03/Male_09.mdl"}, 23);
  
  __deceptinfect_Misc.infModel = "models/player/zombie_classic.mdl";
  
  __deceptinfect_PlayerManager.indexLookup = __haxe_ds_IntMap.new();
  
  __hxbit_Serializer.UID = 0;
  
  __hxbit_Serializer.SEQ = 0;
  
  __hxbit_Serializer.CLASSES = _hx_tab_array({}, 0);
  
  __hxbit_Serializer.ENUM_CLASSES = __haxe_ds_StringMap.new();
  
  __deceptinfect_TestObject.__clid = __hxbit_Serializer.registerClass(__deceptinfect_TestObject);
  
  __deceptinfect_client_GeigerSystem.net_geiger = NETMESSAGE_geiger.new();
  
  __deceptinfect_client_GeigerSystem.geiger = 0.0;
  
  __deceptinfect_client_GeigerSystem.sounds = _hx_tab_array({[0]=_G.Sound("player/geiger1.wav"), _G.Sound("player/geiger2.wav"), _G.Sound("player/geiger3.wav")}, 3);
  
  __deceptinfect_client_GeigerSystem.playTime = 0.0;
  
  __deceptinfect_client_Hud.cache = (function() 
    local _hx_2
    
    local _g = __haxe_ds_EnumValueMap.new();
    
    _g:set(__deceptinfect_client__Hud_Axis.X, __haxe_ds_IntMap.new());
    
    _g:set(__deceptinfect_client__Hud_Axis.Y, __haxe_ds_IntMap.new());
    
    _hx_2 = _g;
    return _hx_2
  end )();
  
  __deceptinfect_client_Hud.baseReso = (function() 
    local _hx_3
    
    local _g = __haxe_ds_EnumValueMap.new();
    
    _g:set(__deceptinfect_client__Hud_Axis.X, 1920);
    
    _g:set(__deceptinfect_client__Hud_Axis.Y, 1080);
    
    _hx_3 = _g;
    return _hx_3
  end )();
  
  __deceptinfect_client_PVS.pvs = __haxe_ds_IntMap.new();
  
  __deceptinfect_client_SabotagePanel.gclass = "SabotagePanel";
  
  __deceptinfect_client_SaboPanel3.gclass = "SaboPanel3";
  
  __deceptinfect_client_SaboPanel4.gclass = "SaboPanel4";
  
  __deceptinfect_client_SaboPanel2.gclass = "SaboPanel2";
  
  __deceptinfect_ecswip_ComponentManager.components = __haxe_ds_ObjectMap.new();
  
  __deceptinfect_ecswip_ComponentManager.componentSignals = __haxe_ds_ObjectMap.new();
  
  __deceptinfect_ecswip_ComponentManager.entities = 0;
  
  __deceptinfect_ecswip_ComponentManager.activeEntities = 0;
  
  __deceptinfect_ecswip_GrabSystem.net_grabupdate = NETMESSAGE_grabupdate.new();
  
  __deceptinfect_ecswip_GrabSystem.net_grabend = NETMESSAGE_grabend.new();
  
  __deceptinfect_ecswip_GrabSystem.hycord = _G.Material("cable/new_cable_lit");
  
  __deceptinfect_ecswip_GrabSystem.activeDraws = __haxe_ds_IntMap.new();
  
  __deceptinfect_ecswip_SignalStorage.entDamageTrigger = __tink_core_SignalTrigger.new();
  
  __deceptinfect_infection_InfectionSystem.net_inf = NETMESSAGE_di_infection.new();
  
  __deceptinfect_infection_InfectionSystem.net_infected = NETMESSAGE_di_infected.new();
  
  __deceptinfect_game_SpawnSystem.obj = __deceptinfect_game_SpawnPointTable.new();
  
  __deceptinfect_game_SpawnSystem.item = __deceptinfect_game_SpawnPointTable.new();
  
  __deceptinfect_game_SpawnSystem.nest = __deceptinfect_game_SpawnPointTable.new();
  
  __deceptinfect_game_SpawnSystem.evac = __deceptinfect_game_SpawnPointTable.new();
  
  __deceptinfect_game_EvacSystem.evac_state = NETMESSAGE_di_evac.new();
  
  __deceptinfect_game_RagdollSystem.statue = NETMESSAGE_statue.new();
  
  __deceptinfect_game_RagdollSystem.statueinfo = NETMESSAGE_di_statinfo.new();
  
  __deceptinfect_game_RagdollSystem.raginfo = NETMESSAGE_di_raginfo.new();
  
  __deceptinfect_infection_InfectionLookSystem.infectioninfo = NETMESSAGE_di_infinfo.new();
  
  __deceptinfect_ecswip_SystemManager.getSystems = __haxe_ds_ObjectMap.new();
  
  __deceptinfect_ecswip_SystemManager.runSystems = _hx_tab_array({[0]=__deceptinfect_infection_InfectionSystem, __deceptinfect_client_GeigerSystem, __deceptinfect_radiation_RadiationSystem, __deceptinfect_ecswip_GrabSystem, __deceptinfect_ecswip_HiddenHealthSystem, __deceptinfect_game_WinSystem, __deceptinfect_game_BatterySystem, __deceptinfect_game_SpawnSystem, __deceptinfect_statuses_WalkthroughSystem, __deceptinfect_game_NestSystem, __deceptinfect_game_EvacSystem, __deceptinfect_game_RagdollSystem, __deceptinfect_game_SlowMotionSystem, __deceptinfect_infection_InfectionLookSystem, __deceptinfect_radiation_ContaminationSystem, __deceptinfect_radiation_RadSourceSystem, __deceptinfect_game_LowHealthSystem, __deceptinfect_items_ScannerSystem}, 18);
  
  __deceptinfect_infection_InfectionComponent.__clid = __hxbit_Serializer.registerClass(__deceptinfect_infection_InfectionComponent);
  
  __deceptinfect_util_Util.mappy_2 = __haxe_ds_IntMap.new();
  
  __hxbit_NetworkHost.CLIENT_TIMEOUT = 3600.;
  
  __haxe_ds_IntMap.tnull = ({});
  
  __haxe_EntryPoint.pending = Array.new();
  
  __haxe_EntryPoint.threadCount = 0;
  
  __haxe_Serializer.USE_CACHE = false;
  
  __haxe_Serializer.USE_ENUM_INDEX = false;
  
  __haxe_Serializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
  
  __haxe_Unserializer.DEFAULT_RESOLVER = __haxe__Unserializer_DefaultResolver.new();
  
  __haxe_Unserializer.BASE64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789%:";
  
  __hxbit_Convert.convFuns = __haxe_ds_StringMap.new();
  
  __hxbit_Schema.__clid = __hxbit_Serializer.registerClass(__hxbit_Schema);
  
  __tink_core__Callback_Callback_Impl_.depth = 0;
  
  
end

_hx_bind = function(o,m)
  if m == nil then return nil end;
  local f;
  if o._hx__closures == nil then
    _G.rawset(o, '_hx__closures', {});
  else
    f = o._hx__closures[m];
  end
  if (f == nil) then
    f = function(...) return m(o, ...) end;
    o._hx__closures[m] = f;
  end
  return f;
end

_hx_funcToField = function(f)
  if type(f) == 'function' then
    return function(self,...)
      return f(...)
    end
  else
    return f
  end
end

_G.math.randomseed(_G.os.time());

_hx_print = print or (function() end)

_hx_apply_self = function(self, f, ...)
  return self[f](self,...)
end

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

_hx_wrap_if_string_field = function(o, fld)
  if _G.type(o) == 'string' then
    if fld == 'length' then
      return _G.string.len(o)
    else
      return String.prototype[fld]
    end
  else
    return o[fld]
  end
end

_hx_static_init();
_G.xpcall(function() 
  Main.main();
  __haxe_EntryPoint.run();
end, _hx_error)
return _hx_exports
